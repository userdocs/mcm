From 844d54233b2119f00378cc3be1f9108358e57365 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Mon, 19 Mar 2018 21:18:23 +0900
Subject: [PATCH 001/108] or1k: initial support for openrisc

---
 README.md                      | 16 ++++++++
 gcc/config.gcc                 | 10 +++++
 gcc/config/or1k/constraints.md | 30 ++++++++++++++
 gcc/config/or1k/or1k.c         | 50 ++++++++++++++++++++++++
 gcc/config/or1k/or1k.h         | 24 ++++++++++++
 gcc/config/or1k/or1k.md        | 71 ++++++++++++++++++++++++++++++++++
 gcc/config/or1k/predicates.md  | 25 ++++++++++++
 gcc/config/or1k/t-or1k         | 21 ++++++++++
 8 files changed, 247 insertions(+)
 create mode 100644 README.md
 create mode 100644 gcc/config/or1k/constraints.md
 create mode 100644 gcc/config/or1k/or1k.c
 create mode 100644 gcc/config/or1k/or1k.h
 create mode 100644 gcc/config/or1k/or1k.md
 create mode 100644 gcc/config/or1k/predicates.md
 create mode 100644 gcc/config/or1k/t-or1k

diff --git a/README.md b/README.md
new file mode 100644
index 00000000000..0de2deb1588
--- /dev/null
+++ b/README.md
@@ -0,0 +1,16 @@
+# OpenRISC GCC port
+
+this is the start of a new OpenRISC fsf clean port for gcc.
+
+## Todo
+
+- build infra + basic files - DONE
+- register definitions
+- calling conventions
+- memory layout
+- load/store
+- moves
+- jump
+- branches
+
+## building
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 532c33f4c2b..3800383690b 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -455,6 +455,10 @@ nios2-*-*)
 nvptx-*-*)
 	cpu_type=nvptx
 	;;
+or1k*-*-*)
+	cpu_type=or1k
+	target_has_targetm_common=no
+	;;
 powerpc*-*-*spe*)
 	cpu_type=powerpcspe
 	extra_headers="ppc-asm.h altivec.h spe.h ppu_intrinsics.h paired.h spu2vmx.h vec_types.h si2vmx.h htmintrin.h htmxlintrin.h"
@@ -2373,6 +2377,12 @@ nvptx-*)
 		tm_file="${tm_file} nvptx/offload.h"
 	fi
 	;;
+or1k*-*-elf)
+	gas=yes
+	gnu_ld=yes
+	tm_file="dbxelf.h elfos.h newlib-stdint.h ${tm_file}"
+	tmake_file="${tmake_file} or1k/t-or1k"
+	;;
 pdp11-*-*)
 	tm_file="${tm_file} newlib-stdint.h"
 	use_gcc_stdint=wrap
diff --git a/gcc/config/or1k/constraints.md b/gcc/config/or1k/constraints.md
new file mode 100644
index 00000000000..914cd1990d3
--- /dev/null
+++ b/gcc/config/or1k/constraints.md
@@ -0,0 +1,30 @@
+;; Constraint definitions for OpenRISC
+;; Copyright (C) 2018 Free Software Foundation, Inc.
+;; Contributed by Stafford Horne
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 3, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; -------------------------------------------------------------------------
+;; Constraints
+;; -------------------------------------------------------------------------
+
+(define_constraint "O"
+  "The constant zero"
+  (and (match_code "const_int")
+       (match_test "ival == 0")))
+
+
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
new file mode 100644
index 00000000000..7fa9ce003f3
--- /dev/null
+++ b/gcc/config/or1k/or1k.c
@@ -0,0 +1,50 @@
+/* Target Code for OpenRISC
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   Contributed by Stafford Horne based on other ports.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#define IN_TARGET_CODE 1
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "target.h"
+#include "rtl.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "attribs.h"
+#include "df.h"
+#include "regs.h"
+#include "memmodel.h"
+#include "emit-rtl.h"
+#include "diagnostic-core.h"
+#include "output.h"
+#include "stor-layout.h"
+#include "varasm.h"
+#include "calls.h"
+#include "expr.h"
+#include "builtins.h"
+
+/* This file should be included last.  */
+#include "target-def.h"
+
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+#include "gt-or1k.h"
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
new file mode 100644
index 00000000000..2684185fedf
--- /dev/null
+++ b/gcc/config/or1k/or1k.h
@@ -0,0 +1,24 @@
+/* Target Definitions for OpenRISC.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   Contributed by Stafford Horne.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_OR1K_H
+#define GCC_OR1K_H
+
+#endif /* GCC_OR1K_H */
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
new file mode 100644
index 00000000000..b9ba0b0a618
--- /dev/null
+++ b/gcc/config/or1k/or1k.md
@@ -0,0 +1,71 @@
+;; Machine description for OpenRISC
+;; Copyright (C) 2018 Free Software Foundation, Inc.
+;; Contributed by Stafford Horne
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 3, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; -------------------------------------------------------------------------
+;; Moxie specific constraints, predicates and attributes
+;; -------------------------------------------------------------------------
+
+(include "constraints.md")
+(include "predicates.md")
+
+; Most instructions are 4 bytes long.
+(define_attr "length" "" (const_int 4))
+
+;; -------------------------------------------------------------------------
+;; nop instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "l.nop")
+
+;; -------------------------------------------------------------------------
+;; Arithmetic instructions
+;; -------------------------------------------------------------------------
+
+;; -------------------------------------------------------------------------
+;; Unary arithmetic instructions
+;; -------------------------------------------------------------------------
+
+;; -------------------------------------------------------------------------
+;; Logical operators
+;; -------------------------------------------------------------------------
+
+;; -------------------------------------------------------------------------
+;; Move instructions
+;; -------------------------------------------------------------------------
+
+;; -------------------------------------------------------------------------
+;; Compare instructions
+;; -------------------------------------------------------------------------
+
+;; -------------------------------------------------------------------------
+;; Branch instructions
+;; -------------------------------------------------------------------------
+
+;; -------------------------------------------------------------------------
+;; Call and Jump instructions
+;; -------------------------------------------------------------------------
+
+;; -------------------------------------------------------------------------
+;; Prologue & Epilogue
+;; -------------------------------------------------------------------------
+
diff --git a/gcc/config/or1k/predicates.md b/gcc/config/or1k/predicates.md
new file mode 100644
index 00000000000..fd537bea3e9
--- /dev/null
+++ b/gcc/config/or1k/predicates.md
@@ -0,0 +1,25 @@
+;; Predicate definitions for OpenRISC
+;; Copyright (C) 2018 Free Software Foundation, Inc.
+;; Contributed by Stafford Horne
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 3, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; -------------------------------------------------------------------------
+;; Predicates
+;; -------------------------------------------------------------------------
+
+
diff --git a/gcc/config/or1k/t-or1k b/gcc/config/or1k/t-or1k
new file mode 100644
index 00000000000..e8b4d60fe90
--- /dev/null
+++ b/gcc/config/or1k/t-or1k
@@ -0,0 +1,21 @@
+# Target Makefile Fragment for OpenRISC
+# Copyright (C) 2018 Free Software Foundation, Inc.
+# Contributed by Stafford Horne.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published
+# by the Free Software Foundation; either version 3, or (at your
+# option) any later version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+# License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+
-- 
2.18.0


From ba514fb47bfabb6bbbf5dfe4852a66d4c731ba5d Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Mon, 19 Mar 2018 22:45:59 +0900
Subject: [PATCH 002/108] or1k: Add some basic definitions for regs/storage etc

---
 README.md              |   2 +-
 gcc/config/or1k/or1k.h | 104 +++++++++++++++++++++++++++++++++++++++++
 2 files changed, 105 insertions(+), 1 deletion(-)

diff --git a/README.md b/README.md
index 0de2deb1588..193844cbed2 100644
--- a/README.md
+++ b/README.md
@@ -5,7 +5,7 @@ this is the start of a new OpenRISC fsf clean port for gcc.
 ## Todo
 
 - build infra + basic files - DONE
-- register definitions
+- register definitions - DONE
 - calling conventions
 - memory layout
 - load/store
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 2684185fedf..50a3fd1cb72 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -21,4 +21,108 @@
 #ifndef GCC_OR1K_H
 #define GCC_OR1K_H
 
+/* Storage layout.  */
+
+#define DEFAULT_SIGNED_CHAR 1
+#define BITS_BIG_ENDIAN 0
+#define BYTES_BIG_ENDIAN 1
+#define WORDS_BIG_ENDIAN 1
+#define BITS_PER_WORD 32
+#define UNITS_PER_WORD 4
+#define POINTER_SIZE 32
+#define BIGGEST_ALIGNMENT 32
+#define STRICT_ALIGNMENT 1
+#define FUNCTION_BOUNDARY 32
+#define PARM_BOUNDARY 32
+#define STACK_BOUNDARY 32
+#define PREFERRED_STACK_BOUNDARY 32
+#define MAX_FIXED_MODE_SIZE 64
+
+/* Layout of source language data types.  */
+
+#define INT_TYPE_SIZE 32
+#define SHORT_TYPE_SIZE 16
+#define LONG_TYPE_SIZE 32
+#define LONG_LONG_TYPE_SIZE 64
+#define FLOAT_TYPE_SIZE 32
+#define DOUBLE_TYPE_SIZE 64
+#define LONG_DOUBLE_TYPE_SIZE DOUBLE_TYPE_SIZE
+
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+/* Describing Relative Costs of Operations.  */
+#define MOVE_MAX 4
+#define SLOW_BYTE_ACCESS 1
+
+/* Register usage, class and contents.  */
+
+#define FIRST_PSEUDO_REGISTER  32
+
+#define ZERO_REGNUM   0
+#define SP_REGNUM   1
+#define FP_REGNUM   2
+#define LR_REGNUM   10
+#define TLS_REGNUM  11
+#define RV_REGNUM   12
+#define RVH_REGNUM  13
+
+#define FIXED_REGISTERS   \
+{ 1, 1, 0, 0, 0, 0, 0, 0, \
+  0, 0, 1, 0, 0, 0, 0, 0, \
+  0, 0, 0, 0, 0, 0, 0, 0, \
+  0, 0, 0, 0, 0, 0, 0, 0}
+
+#define CALL_USED_REGISTERS \
+{ 1, 1, 0, 0, 0, 0, 0, 0, \
+  0, 1, 1, 1, 1, 0, 0, 0, \
+  0, 0, 0, 0, 0, 0, 0, 0, \
+  0, 0, 0, 0, 0, 0, 0, 0}
+
+enum reg_class
+{
+  NO_REGS,
+  GENERAL_REGS,
+  ALL_REGS,
+  LIM_REG_CLASSES
+};
+
+#define N_REG_CLASSES (int) LIM_REG_CLASSES
+
+#define REG_CLASS_NAMES { "NO_REGS", "GENERAL_REGS", "ALL_REGS" }
+
+#define REG_CLASS_CONTENTS      \
+{ {0x00000000},                 \
+  {0xffffffff},                 \
+  {0xffffffff}                  \
+}
+
+/* Assembly definitions.  */
+
+#define ASM_APP_ON "#APP\n"
+#define ASM_APP_OFF "#NO_APP\n"
+
+#define ASM_COMMENT_START "# "
+
+#define GLOBAL_ASM_OP "\t.global\t"
+
+#define REGISTER_NAMES {						\
+  "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",		\
+  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",	\
+  "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",	\
+  "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31" 	\
+}
+
+/* Calling convention definitions.  */
+typedef struct or1k_args
+{
+  int regs_used;
+} CUMULATIVE_ARGS;
+
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \
+  do { (CUM).regs_used = 0; } while (0)
+
 #endif /* GCC_OR1K_H */
-- 
2.18.0


From 49bc961fa6842909f265d7f9c06a7fd60e9827be Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 20 Mar 2018 06:17:07 +0900
Subject: [PATCH 003/108] or1k: fix register indexes

---
 gcc/config/or1k/or1k.h | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 50a3fd1cb72..570b33274b6 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -65,10 +65,10 @@
 #define ZERO_REGNUM   0
 #define SP_REGNUM   1
 #define FP_REGNUM   2
-#define LR_REGNUM   10
-#define TLS_REGNUM  11
-#define RV_REGNUM   12
-#define RVH_REGNUM  13
+#define LR_REGNUM   9
+#define TLS_REGNUM  10
+#define RV_REGNUM   11
+#define RVH_REGNUM  12
 
 #define FIXED_REGISTERS   \
 { 1, 1, 0, 0, 0, 0, 0, 0, \
-- 
2.18.0


From d521064ecff972ddf0f13fe595b978732c9ec684 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Wed, 21 Mar 2018 06:39:53 +0900
Subject: [PATCH 004/108] or1k: add basic moves and load/store

---
 README.md                      |  7 ++++--
 gcc/config/or1k/constraints.md | 20 ++++++++++++++--
 gcc/config/or1k/or1k-protos.h  | 20 ++++++++++++++++
 gcc/config/or1k/or1k.c         | 17 ++++++++++++++
 gcc/config/or1k/or1k.md        | 42 ++++++++++++++++++++++++++++++++++
 5 files changed, 102 insertions(+), 4 deletions(-)
 create mode 100644 gcc/config/or1k/or1k-protos.h

diff --git a/README.md b/README.md
index 193844cbed2..cb2468efcdf 100644
--- a/README.md
+++ b/README.md
@@ -4,12 +4,15 @@ this is the start of a new OpenRISC fsf clean port for gcc.
 
 ## Todo
 
+These items should be done to get to a point where very basic things compile.
+`DONE` - just means something is in place so we can move on not done and tested.
+
 - build infra + basic files - DONE
 - register definitions - DONE
 - calling conventions
 - memory layout
-- load/store
-- moves
+- load/store - DONE
+- moves - DONE
 - jump
 - branches
 
diff --git a/gcc/config/or1k/constraints.md b/gcc/config/or1k/constraints.md
index 914cd1990d3..0bc3a29a7eb 100644
--- a/gcc/config/or1k/constraints.md
+++ b/gcc/config/or1k/constraints.md
@@ -22,9 +22,25 @@
 ;; Constraints
 ;; -------------------------------------------------------------------------
 
-(define_constraint "O"
-  "The constant zero"
+;; Memory
+(define_constraint "W"
+  "A register indirect memory operand."
+  (and (match_code "mem")
+       (match_test "or1k_legitimate_address_p (mode, op, false)")))
+
+;; Immediates
+(define_constraint "I"
+  "The constant zerK"
   (and (match_code "const_int")
        (match_test "ival == 0")))
 
+(define_constraint "J"
+  "A signed 16-bit immediate in the range -32768 to 32767."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, -32768, 32767)")))
 
+(define_constraint "K"
+  "A shifted signed 16-bit constant suitable for l.movhi."
+  (and (match_code "const_int")
+       (match_test "(ival & 0xffff) == 0
+                    && (ival >> 31 == -1 || ival >> 31 == 0)")))
diff --git a/gcc/config/or1k/or1k-protos.h b/gcc/config/or1k/or1k-protos.h
new file mode 100644
index 00000000000..dca3f5dd4db
--- /dev/null
+++ b/gcc/config/or1k/or1k-protos.h
@@ -0,0 +1,20 @@
+/* Prototypes for OpenRISC functions used in the md file & elsewhere.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+extern bool or1k_legitimate_address_p (machine_mode, rtx, bool);
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 7fa9ce003f3..d6c20be4da9 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -44,6 +44,23 @@
 /* This file should be included last.  */
 #include "target-def.h"
 
+/* Worker function for TARGET_LEGITIMATE_ADDRESS_P.  */
+
+static bool
+or1k_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,
+			   rtx x, bool strict_p)
+{
+  if (GET_CODE(x) == PLUS
+      && REG_P (XEXP (x, 0))
+      && satisfies_constraint_J (XEXP (x, 1)))
+    return true;
+
+  return false;
+}
+
+#undef TARGET_LEGITIMATE_ADDRESS_P
+#define TARGET_LEGITIMATE_ADDRESS_P or1k_legitimate_address_p
+
 
 struct gcc_target targetm = TARGET_INITIALIZER;
 
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index b9ba0b0a618..f2bc7af8eba 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -41,6 +41,25 @@
 ;; Arithmetic instructions
 ;; -------------------------------------------------------------------------
 
+(define_insn "addsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	  (plus:SI
+	   (match_operand:SI 1 "register_operand" "0,0")
+	   (match_operand:SI 2 "general_operand" "0,J")))]
+  ""
+  "@
+  l.add\t%0, %1, %2
+  l.addi\t%0, %1, %2")
+
+(define_insn "subsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	  (minus:SI
+	   (match_operand:SI 1 "register_operand" "0")
+	   (match_operand:SI 2 "register_operand" "0")))]
+  ""
+  "@
+  l.sub\t%0, %1 %2")
+
 ;; -------------------------------------------------------------------------
 ;; Unary arithmetic instructions
 ;; -------------------------------------------------------------------------
@@ -53,6 +72,29 @@
 ;; Move instructions
 ;; -------------------------------------------------------------------------
 
+(define_expand "movsi"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "")
+	(match_operand:SI 1 "general_operand" ""))]
+  ""
+{
+  if (MEM_P (operands[0]))
+    operands[1] = force_reg (SImode, operands[1]);
+})
+
+(define_insn "*movsi_internal"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,r,W,r")
+	(match_operand:SI 1 "general_operand" "r,I,J,K,r,W"))]
+  "register_operand (operands[0], SImode) || register_operand (operands[1], SImode)"
+  "@
+   l.ori\t%0, r0, %1
+   l.movhi\t%0, %1
+   l.ori\t%0, r0, %1
+   l.movhi\t%0, %1
+   l.sw\t%0, %1
+   l.lwz\t%0, %1
+")
+
+
 ;; -------------------------------------------------------------------------
 ;; Compare instructions
 ;; -------------------------------------------------------------------------
-- 
2.18.0


From 53dcbdd7b6fa9f07fa6c26de0937eb56ecf51ade Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Wed, 21 Mar 2018 13:01:56 +0900
Subject: [PATCH 005/108] or1k: get a bit farther with compiling, need jump now

---
 gcc/config/or1k/or1k-protos.h |   1 +
 gcc/config/or1k/or1k.c        |  37 ++++++++-
 gcc/config/or1k/or1k.h        | 140 +++++++++++++++++++++++++++++++---
 gcc/config/or1k/or1k.md       |   6 +-
 4 files changed, 166 insertions(+), 18 deletions(-)

diff --git a/gcc/config/or1k/or1k-protos.h b/gcc/config/or1k/or1k-protos.h
index dca3f5dd4db..e5109612f78 100644
--- a/gcc/config/or1k/or1k-protos.h
+++ b/gcc/config/or1k/or1k-protos.h
@@ -18,3 +18,4 @@ along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
 extern bool or1k_legitimate_address_p (machine_mode, rtx, bool);
+extern int  or1k_initial_elimination_offset (int, int);
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index d6c20be4da9..3471ad3a09a 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -41,27 +41,58 @@
 #include "expr.h"
 #include "builtins.h"
 
+/* These 4 are needed to allow using satisfies_constraint_J.  */
+#include "insn-config.h"
+#include "recog.h"
+#include "tm_p.h"
+#include "tm-constrs.h"
+
 /* This file should be included last.  */
 #include "target-def.h"
 
+int
+or1k_initial_elimination_offset (int from ATTRIBUTE_UNUSED, int to ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+
 /* Worker function for TARGET_LEGITIMATE_ADDRESS_P.  */
 
-static bool
+bool
 or1k_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,
-			   rtx x, bool strict_p)
+			   rtx x, bool strict_p ATTRIBUTE_UNUSED)
 {
   if (GET_CODE(x) == PLUS
       && REG_P (XEXP (x, 0))
       && satisfies_constraint_J (XEXP (x, 1)))
     return true;
 
+  if (REG_P (x))
+    return true;
+
   return false;
 }
 
+/* Worker function for TARGET_FUNCTION_VALUE.  */
+
+static rtx
+or1k_function_value (const_tree valtype,
+		     const_tree fn_decl_or_type ATTRIBUTE_UNUSED,
+		     bool outgoing ATTRIBUTE_UNUSED)
+{
+  /* TODO support 2 reg return values and return on stack?  */
+  return gen_rtx_REG (TYPE_MODE (valtype), RV_REGNUM);
+}
+
+
 #undef TARGET_LEGITIMATE_ADDRESS_P
 #define TARGET_LEGITIMATE_ADDRESS_P or1k_legitimate_address_p
 
+#undef TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE or1k_function_value
 
 struct gcc_target targetm = TARGET_INITIALIZER;
 
-#include "gt-or1k.h"
+/* Enable when we need option_override TARGET_OPTION_OVERRIDE.  */
+//#include "gt-or1k.h"
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 570b33274b6..bd7d84d29f9 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -21,6 +21,19 @@
 #ifndef GCC_OR1K_H
 #define GCC_OR1K_H
 
+/* Names to predefine in the preprocessor for this target machine.  */
+/* __M32R__ is defined by the existing compiler so we use that.  */
+#define TARGET_CPU_CPP_BUILTINS()		\
+  do						\
+    {						\
+      builtin_define ("__OR1K__");		\
+      builtin_define ("__or1k__");		\
+      builtin_assert ("cpu=or1k");		\
+      builtin_assert ("machine=or1k");		\
+      builtin_define ("__BIG_ENDIAN__");	\
+    }						\
+  while (0)
+
 /* Storage layout.  */
 
 #define DEFAULT_SIGNED_CHAR 1
@@ -60,7 +73,7 @@
 
 /* Register usage, class and contents.  */
 
-#define FIRST_PSEUDO_REGISTER  32
+#define FIRST_PSEUDO_REGISTER  33
 
 #define ZERO_REGNUM   0
 #define SP_REGNUM   1
@@ -74,36 +87,50 @@
 { 1, 1, 0, 0, 0, 0, 0, 0, \
   0, 0, 1, 0, 0, 0, 0, 0, \
   0, 0, 0, 0, 0, 0, 0, 0, \
-  0, 0, 0, 0, 0, 0, 0, 0}
+  0, 0, 0, 0, 0, 0, 0, 0, \
+  1}
 
 #define CALL_USED_REGISTERS \
 { 1, 1, 0, 0, 0, 0, 0, 0, \
   0, 1, 1, 1, 1, 0, 0, 0, \
   0, 0, 0, 0, 0, 0, 0, 0, \
-  0, 0, 0, 0, 0, 0, 0, 0}
+  0, 0, 0, 0, 0, 0, 0, 0, \
+  1}
 
 enum reg_class
 {
   NO_REGS,
   GENERAL_REGS,
+  SPECIAL_REGS,
   ALL_REGS,
   LIM_REG_CLASSES
 };
 
 #define N_REG_CLASSES (int) LIM_REG_CLASSES
 
-#define REG_CLASS_NAMES { "NO_REGS", "GENERAL_REGS", "ALL_REGS" }
+#define REG_CLASS_NAMES { \
+  "NO_REGS", 			\
+  "GENERAL_REGS",		\
+  "SPECIAL_REGS",		\
+  "ALL_REGS" }
 
 #define REG_CLASS_CONTENTS      \
-{ {0x00000000},                 \
-  {0xffffffff},                 \
-  {0xffffffff}                  \
+{ {0x00000000, 0x00000000},	\
+  {0xffffffff, 0x00000000},	\
+  {0xffffffff, 0x00000001}	\
 }
 
+/* A C expression whose value is a register class containing hard
+   register REGNO.  In general there is more that one such class;
+   choose a class which is "minimal", meaning that no smaller class
+   also contains the register.  */
+#define REGNO_REG_CLASS(REGNO) \
+  (REGNO < FIRST_PSEUDO_REGISTER ? GENERAL_REGS : SPECIAL_REGS)
+
 /* Assembly definitions.  */
 
-#define ASM_APP_ON "#APP\n"
-#define ASM_APP_OFF "#NO_APP\n"
+#define ASM_APP_ON ""
+#define ASM_APP_OFF ""
 
 #define ASM_COMMENT_START "# "
 
@@ -113,8 +140,19 @@ enum reg_class
   "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",		\
   "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",	\
   "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",	\
-  "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31" 	\
-}
+  "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",	\
+  "?ap" }
+
+/* This is how to output an assembler line
+   that says to advance the location counter
+   to a multiple of 2**LOG bytes.  */
+#define ASM_OUTPUT_ALIGN(FILE,LOG)			\
+  do							\
+    {							\
+      if ((LOG) != 0)					\
+	fprintf (FILE, "\t.align %d\n", 1 << (LOG));	\
+    }							\
+  while (0)
 
 /* Calling convention definitions.  */
 typedef struct or1k_args
@@ -125,4 +163,84 @@ typedef struct or1k_args
 #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \
   do { (CUM).regs_used = 0; } while (0)
 
+
+/* Trampolines, for nested functions */
+#define TRAMPOLINE_SIZE (abort (), 0)
+#define TRAMPOLINE_ALIGNMENT (abort (), 0)
+
+/* Pointer mode */
+#define Pmode	SImode
+#define FUNCTION_MODE	SImode
+#define STACK_POINTER_REGNUM SP_REGNUM
+#define FRAME_POINTER_REGNUM FP_REGNUM
+
+#define HARD_FRAME_POINTER_REGNUM FP_REGNUM
+
+/* The register number of the arg pointer register, which is used to
+   access the function's argument list.  */
+#define ARG_POINTER_REGNUM 32
+
+/* A C expression that is nonzero if REGNO is the number of a hard
+   register in which function arguments are sometimes passed.  */
+#define FUNCTION_ARG_REGNO_P(r) (r >= 3 && r <= 8)
+
+/* A macro whose definition is the name of the class to which a vqalid
+   base register must belong.  A base register is one used in an
+   address which is the register value plus a displacement.  */
+#define BASE_REG_CLASS GENERAL_REGS
+
+#define INDEX_REG_CLASS NO_REGS
+
+#define MAX_REGS_PER_ADDRESS 1
+
+/* The ELIMINABLE_REGS macro specifies a table of register pairs used to
+   eliminate unneeded registers that point into the stack frame. Note,
+   the only elimination attempted by the compiler is to replace references
+   to the frame pointer with references to the stack pointer.  */
+
+#define ELIMINABLE_REGS					\
+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },	\
+ { ARG_POINTER_REGNUM,	 STACK_POINTER_REGNUM },	\
+ { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM }}
+
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
+  do {							\
+    (OFFSET) = or1k_initial_elimination_offset ((FROM), (TO)); \
+  } while (0)
+
+#define REGNO_OK_FOR_INDEX_P(REGNO) 0
+#define REGNO_OK_FOR_BASE_P(REGNO) \
+  ((REGNO) < FIRST_PSEUDO_REGISTER			\
+   || (reg_renumber[REGNO]) < FIRST_PSEUDO_REGISTER)
+
+/* If defined, the maximum amount of space required for outgoing
+   arguments will be computed and placed into the variable
+   'crtl->outgoing_args_size'.  No space will be pushed
+   onto the stack for each call; instead, the function prologue
+   should increase the stack frame size by this amount.  */
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+/* Offset from the argument pointer register to the first argument's
+   address.  On some machines it may depend on the data type of the
+   function.  If 'ARGS_GROW_DOWNWARD', this is the offset to the
+   location above the first argument's address.  */
+#define FIRST_PARM_OFFSET(FNDECL) 0
+
+/* Stack layout and stack pointer usage.  */
+
+/* Define this macro if pushing a word onto the stack moves the stack
+   pointer to a smaller address.  */
+#define STACK_GROWS_DOWNWARD 1
+
+/* Offset from the stack pointer register to the first location at which
+   outgoing arguments are placed.  */
+#define STACK_POINTER_OFFSET 0
+
+/* An alias for a machine mode name.  This is the machine mode that
+   elements of a jump-table should have.  */
+#define CASE_VECTOR_MODE SImode
+
+/* Profiling */
+#define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)
+
 #endif /* GCC_OR1K_H */
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index f2bc7af8eba..e071cfddb09 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -57,8 +57,7 @@
 	   (match_operand:SI 1 "register_operand" "0")
 	   (match_operand:SI 2 "register_operand" "0")))]
   ""
-  "@
-  l.sub\t%0, %1 %2")
+  "l.sub\t%0, %1 %2")
 
 ;; -------------------------------------------------------------------------
 ;; Unary arithmetic instructions
@@ -91,8 +90,7 @@
    l.ori\t%0, r0, %1
    l.movhi\t%0, %1
    l.sw\t%0, %1
-   l.lwz\t%0, %1
-")
+   l.lwz\t%0, %1")
 
 
 ;; -------------------------------------------------------------------------
-- 
2.18.0


From 8ca79653ea04876852d13a4fd6801521ca2220fc Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Wed, 21 Mar 2018 17:23:55 +0900
Subject: [PATCH 006/108] or1k: add jump/call, now compiler compiles

---
 gcc/config/or1k/constraints.md |  5 +++
 gcc/config/or1k/or1k.md        | 65 ++++++++++++++++++++++++++++++++++
 2 files changed, 70 insertions(+)

diff --git a/gcc/config/or1k/constraints.md b/gcc/config/or1k/constraints.md
index 0bc3a29a7eb..536c6b77cbb 100644
--- a/gcc/config/or1k/constraints.md
+++ b/gcc/config/or1k/constraints.md
@@ -44,3 +44,8 @@
   (and (match_code "const_int")
        (match_test "(ival & 0xffff) == 0
                     && (ival >> 31 == -1 || ival >> 31 == 0)")))
+
+(define_constraint "L"
+  "A signed 26-bit constant suitable for l.jal."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, -33554432, 33554431)")))
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index e071cfddb09..5ba46925614 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -25,6 +25,11 @@
 (include "constraints.md")
 (include "predicates.md")
 
+;; Register numbers
+(define_constants
+  [(LR_REGNUM       9)]
+)
+
 ; Most instructions are 4 bytes long.
 (define_attr "length" "" (const_int 4))
 
@@ -104,6 +109,66 @@
 ;; -------------------------------------------------------------------------
 ;; Call and Jump instructions
 ;; -------------------------------------------------------------------------
+(define_insn "jump"
+  [(set (pc) (label_ref (match_operand 0 "" "")))]
+  ""
+  "l.j\t%0"
+)
+
+(define_insn "indirect_jump"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
+  ""
+  "l.jr\t%0"
+)
+
+(define_expand "call"
+  [(parallel [(call (match_operand 0 "" "")
+		    (match_operand 1 "" ""))
+	      (clobber (reg:SI LR_REGNUM))
+	     ])]
+  ""
+  "
+{
+  rtx addr = XEXP (operands[0], 0);
+  if (!CONSTANT_ADDRESS_P (addr))
+    XEXP (operands[0], 0) = force_reg (Pmode, addr);
+}")
+
+(define_insn "*call"
+  [(call (mem:SI (match_operand:SI 0 "general_operand" "r,s"))
+	 (match_operand 1 "" ""))
+   (clobber (reg:SI LR_REGNUM))]
+  ""
+  "@
+   l.jalr\t%0
+   l.jal\t%0"
+)
+
+;; Call with a retun value
+(define_expand "call_value"
+  [(parallel [(set (match_operand 0 "" "")
+		   (call (match_operand 1 "" "")
+		   (match_operand 2 "" "")))
+	      (clobber (reg:SI LR_REGNUM))
+             ])]
+  ""
+  "
+{
+  rtx addr = XEXP (operands[1], 0);
+  if (!CONSTANT_ADDRESS_P (addr))
+    XEXP (operands[1], 0) = force_reg (Pmode, addr);
+}")
+
+(define_insn "*call_value"
+  [(set (match_operand 0 "register_operand" "=r,r")
+	(call (mem:SI (match_operand:SI 1 "general_operand" "r,L"))
+	      (match_operand 2 "" "")))
+   (clobber (reg:SI LR_REGNUM))]
+  ""
+  "@
+   l.jalr\t%1
+   l.jal\t%1"
+)
 
 ;; -------------------------------------------------------------------------
 ;; Prologue & Epilogue
-- 
2.18.0


From 81f6283b31b695c24c6344ceaf9c2b633432a656 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Wed, 21 Mar 2018 18:53:26 +0900
Subject: [PATCH 007/108] or1k: mark jumps done in readme

---
 README.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/README.md b/README.md
index cb2468efcdf..27181d47722 100644
--- a/README.md
+++ b/README.md
@@ -13,7 +13,7 @@ These items should be done to get to a point where very basic things compile.
 - memory layout
 - load/store - DONE
 - moves - DONE
-- jump
+- jump - DONE
 - branches
 
 ## building
-- 
2.18.0


From c67a041717e084057fe6ebcbb1fe9a5b8a2fab55 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Sat, 24 Mar 2018 07:28:58 +0900
Subject: [PATCH 008/108] or1k: implement epilog/prolog calling conventions

This is just a checkpoint, currently compiling the following code
is causing an reload error during handling for return value. Need to
fix this before moving on.

    int foo(int, int);
    int main()
    {
      return foo (111, 222);
    }
---
 README.md                     |   6 +-
 gcc/config/or1k/or1k-protos.h |   3 +
 gcc/config/or1k/or1k.c        | 280 +++++++++++++++++++++++++++++++++-
 gcc/config/or1k/or1k.h        |  46 +++++-
 gcc/config/or1k/or1k.md       |  22 ++-
 5 files changed, 344 insertions(+), 13 deletions(-)

diff --git a/README.md b/README.md
index 27181d47722..cf5df4efefb 100644
--- a/README.md
+++ b/README.md
@@ -9,7 +9,7 @@ These items should be done to get to a point where very basic things compile.
 
 - build infra + basic files - DONE
 - register definitions - DONE
-- calling conventions
+- calling conventions - DONE
 - memory layout
 - load/store - DONE
 - moves - DONE
@@ -17,3 +17,7 @@ These items should be done to get to a point where very basic things compile.
 - branches
 
 ## building
+
+### Stage 1 build
+../gcc/configure --target=or1k-elf --disable-shared --enable-stage1-languages=c --prefix=/home/shorne/work/gnu-toolchain/local
+make -j5
diff --git a/gcc/config/or1k/or1k-protos.h b/gcc/config/or1k/or1k-protos.h
index e5109612f78..14963cc791d 100644
--- a/gcc/config/or1k/or1k-protos.h
+++ b/gcc/config/or1k/or1k-protos.h
@@ -19,3 +19,6 @@ along with GCC; see the file COPYING3.  If not see
 
 extern bool or1k_legitimate_address_p (machine_mode, rtx, bool);
 extern int  or1k_initial_elimination_offset (int, int);
+extern void or1k_expand_prologue (void);
+extern void or1k_expand_epilogue (void);
+
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 3471ad3a09a..bbbc4cf5e7f 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -50,13 +50,219 @@
 /* This file should be included last.  */
 #include "target-def.h"
 
+/* Per-function machine data.  */
+struct GTY(()) machine_function
+ {
+   /* Number of bytes saved on the stack for callee saved registers.  */
+   int callee_saved_reg_size;
+
+   /* Number of bytes saved on the stack for local variables.  */
+   int local_vars_size;
+
+   /* The sum of sizes: locals vars, called saved regs, stack pointer
+    * and an optional frame pointer.
+    * Used in expand_prologue () and expand_epilogue().  */
+   int total_size;
+ };
+
+/* Zero initialization is OK for all current fields.  */
+
+static struct machine_function *
+or1k_init_machine_status (void)
+{
+  return ggc_cleared_alloc<machine_function> ();
+}
+
+
+/* The TARGET_OPTION_OVERRIDE worker.  */
+static void
+or1k_option_override (void)
+{
+  /* Set the per-function-data initializer.  */
+  init_machine_status = or1k_init_machine_status;
+}
+
+/* OpenRISC callee saved regs are even regs r14-r30.  */
+static bool
+callee_saved_regno_p (int regno)
+{
+  return regno <= 30
+         && regno >= 14
+         && (regno % 2 == 0);
+}
+
+/* Compute the size of the local area and the size to be adjusted by the
+ * prologue and epilogue.  This is now the TARGET_COMPUTE_FRAME_LAYOUT worker.
+ *
+ * OpenRISC stack grows downwards and contains:
+ *
+ *  ---- previous frame --------
+ *  current func arg[n]
+ *  current func arg[0]   <-- r2 [FP]
+ *  ---- current stack frame ---  ^
+ *  return address      r9        |
+ *  old frame pointer   r2       (+)
+ *  callee saved regs             |
+ *  local variables               |
+ *  sub function args     <-- r1 [SP]
+ *  ----------------------------  |
+ *                               (-)
+ *         (future)               |
+ *                                V
+ *
+ * All of these contents are optional.
+ *
+ * */
+static void
+or1k_compute_frame_layout (void)
+{
+  /* For aligning the local variables.  */
+  int stack_alignment = STACK_BOUNDARY / BITS_PER_UNIT;
+  int padding_locals;
+  int regno;
+
+  /* Padding needed for each element of the frame.  */
+  cfun->machine->local_vars_size = get_frame_size ();
+
+  /* Align to the stack alignment.  */
+  padding_locals = cfun->machine->local_vars_size % stack_alignment;
+  if (padding_locals)
+    padding_locals = stack_alignment - padding_locals;
+
+  cfun->machine->local_vars_size += padding_locals;
+
+  /* Save callee-saved registers.  */
+  cfun->machine->callee_saved_reg_size = 0;
+
+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    if (df_regs_ever_live_p (regno) && callee_saved_regno_p (regno))
+      cfun->machine->callee_saved_reg_size += 4;
+
+  cfun->machine->total_size =
+    + cfun->machine->local_vars_size
+    + cfun->machine->callee_saved_reg_size;
+
+  if (frame_pointer_needed)
+    cfun->machine->total_size += 4;
+
+  /* Add space for the stack pointer.  */
+  cfun->machine->total_size += 4;
+}
+
+static void
+or1k_save_restore_reg (int regno, int offset, bool save_p)
+{
+  rtx reg;
+  rtx mem;
+
+  reg = gen_rtx_REG (Pmode, regno);
+  mem = gen_rtx_MEM (SImode, gen_rtx_PLUS (Pmode, stack_pointer_rtx,
+                                           GEN_INT (offset)));
+  if (save_p)
+    {
+      rtx insn = emit_move_insn (mem, reg);
+      RTX_FRAME_RELATED_P (insn) = 1;
+    }
+  else
+    emit_move_insn (reg, mem);
+}
+
+void
+or1k_expand_prologue (void)
+{
+  int offset;
+  int regno;
+
+  offset = -1 * cfun->machine->total_size;
+
+  if (flag_stack_usage_info)
+    current_function_static_stack_size = cfun->machine->total_size;
+
+  /* Reserve space for local vars.  */
+  offset += cfun->machine->local_vars_size;
+
+  /* Save callee-saved registers.  */
+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    {
+      if (df_regs_ever_live_p (regno) && callee_saved_regno_p (regno))
+	{
+	  or1k_save_restore_reg (regno, offset, true);
+
+	  offset += 4;
+	}
+    }
+
+  /* Save frame pointer.  */
+  if (frame_pointer_needed)
+    {
+      gcc_assert (offset == -8);
+      or1k_save_restore_reg (FP_REGNUM, offset, true);
+      offset += 4;
+    }
+
+  /* Save the linkr register.  */
+  gcc_assert (offset == -4);
+  or1k_save_restore_reg (LR_REGNUM, offset, true);
+
+  /* Finally, adjust the stack pointer.  */
+  offset = cfun->machine->total_size;
+  if (offset != 0)
+    {
+      rtx insn = emit_insn (gen_subsi3 (stack_pointer_rtx,
+					stack_pointer_rtx,
+				    	GEN_INT (offset)));
+      RTX_FRAME_RELATED_P (insn) = 1;
+    }
+}
+
+void
+or1k_expand_epilogue (void)
+{
+  int regno;
+  int offset;
+
+  /* First, restore the stack pointer.  */
+  offset = -1 * cfun->machine->total_size;
+
+  if (offset != 0)
+    rtx insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
+				      stack_pointer_rtx,
+				      GEN_INT (-1 * offset)));
+
+  /* Reverse space for local vars.  */
+  offset += cfun->machine->local_vars_size;
+
+  /* Restore callee-saved registers.  */
+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    {
+      if (df_regs_ever_live_p (regno) && callee_saved_regno_p (regno))
+	{
+	  or1k_save_restore_reg (regno, offset, false);
+	  offset += 4;
+	}
+    }
+
+  /* Restore frame pointer.  */
+  if (frame_pointer_needed)
+    {
+      gcc_assert (offset == -8);
+      or1k_save_restore_reg (FP_REGNUM, offset, false);
+      offset += 4;
+    }
+
+  /* Restore link register.  */
+  gcc_assert (offset == -4);
+  or1k_save_restore_reg (LR_REGNUM, offset, false);
+
+  emit_jump_insn (gen_indirect_jump (gen_rtx_REG (Pmode, LR_REGNUM)));
+}
+
 int
 or1k_initial_elimination_offset (int from ATTRIBUTE_UNUSED, int to ATTRIBUTE_UNUSED)
 {
   return 0;
 }
 
-
 /* Worker function for TARGET_LEGITIMATE_ADDRESS_P.  */
 
 bool
@@ -85,14 +291,82 @@ or1k_function_value (const_tree valtype,
   return gen_rtx_REG (TYPE_MODE (valtype), RV_REGNUM);
 }
 
+/* Worker function for TARGET_FUNCTION_VALUE_REGNO_P.  */
+
+static bool
+or1k_function_value_regno_p (const unsigned int regno)
+{
+  return (regno == RV_REGNUM);
+}
+
+/* Worker function for TARGET_FUNCTION_ARG.  Return the next register to be
+   used to hold a function argument or NULL_RTX if there's no more space.  */
+
+static rtx
+or1k_function_arg (cumulative_args_t cum_v, machine_mode mode,
+		   const_tree type ATTRIBUTE_UNUSED,
+		   bool named ATTRIBUTE_UNUSED)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+
+  if (*cum <= 6)
+    return gen_rtx_REG (mode, *cum + 3);
+  else
+    return NULL_RTX;
+}
+
+#define OR1K_FUNCTION_ARG_SIZE(MODE, TYPE)	\
+  ((MODE) != BLKmode ? GET_MODE_SIZE (MODE)	\
+   : (unsigned) int_size_in_bytes (TYPE))
+
+/* Worker function for TARGET_FUNCTION_ARG_ADVANCE.  Update the cumulative
+   args to advnaced past the next function argument.  This is not needed
+   for arguments passed on the stack.  */
+
+static void
+or1k_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,
+			   const_tree type, bool named ATTRIBUTE_UNUSED)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+
+  *cum += ((3 + OR1K_FUNCTION_ARG_SIZE (mode, type)) / 4);
+}
+
+/* worker function for TARGET_RETURN_IN_MEMORY.  What type of args get returned
+   in memory?  Any value bigger than 64-bits is returned in memory.  */
+
+static bool
+or1k_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
+{
+  const HOST_WIDE_INT size = int_size_in_bytes (type);
+  return (size == -1 || size > (2 * UNITS_PER_WORD));
+}
+
+#undef TARGET_OPTION_OVERRIDE
+#define TARGET_OPTION_OVERRIDE or1k_option_override
+
+#undef TARGET_COMPUTE_FRAME_LAYOUT
+#define TARGET_COMPUTE_FRAME_LAYOUT or1k_compute_frame_layout
 
 #undef TARGET_LEGITIMATE_ADDRESS_P
 #define TARGET_LEGITIMATE_ADDRESS_P or1k_legitimate_address_p
 
+/* Calling Conventions.  */
 #undef TARGET_FUNCTION_VALUE
 #define TARGET_FUNCTION_VALUE or1k_function_value
+#undef TARGET_FUNCTION_VALUE_REGNO_P
+#define TARGET_FUNCTION_VALUE_REGNO_P or1k_function_value_regno_p
+#undef TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG or1k_function_arg
+#undef TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE or1k_function_arg_advance
+#undef TARGET_RETURN_IN_MEMORY
+#define TARGET_RETURN_IN_MEMORY	or1k_return_in_memory
+#undef TARGET_MUST_PASS_IN_STACK
+#define	TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size
+#undef TARGET_PASS_BY_REFERENCE
+#define	TARGET_PASS_BY_REFERENCE hook_pass_by_reference_must_pass_in_stack
 
 struct gcc_target targetm = TARGET_INITIALIZER;
 
-/* Enable when we need option_override TARGET_OPTION_OVERRIDE.  */
-//#include "gt-or1k.h"
+#include "gt-or1k.h"
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index bd7d84d29f9..f5a9e18da18 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -73,6 +73,42 @@
 
 /* Register usage, class and contents.  */
 
+/* In OpenRISC there are 32 general purpose registers with the following
+   designations:
+
+   r0    always 0
+   r1    stack pointer
+   r2    frame pointer (optional)
+   r3    arg 0
+   r4    arg 1
+   r5    arg 2
+   r6    arg 3
+   r7    arg 4
+   r8    arg 5
+   r9    function call return link address
+   r10   thread local storage
+   r11   function return value
+   r12   function return value high (upper 64-bit)
+   r13   temporary
+   r14   callee saved
+   r15   temporary
+   r16   callee saved
+   r17   position independent code base pointer
+   r18   callee saved
+   r19   temporary
+   r20   callee saved
+   r21   temporary
+   r22   callee saved
+   r23   temporary
+   r24   callee saved
+   r25   temporary
+   r26   callee saved
+   r27   temporary
+   r28   callee saved
+   r29   temporary
+   r30   callee saved
+   r31   temporary  */
+
 #define FIRST_PSEUDO_REGISTER  33
 
 #define ZERO_REGNUM   0
@@ -155,13 +191,9 @@ enum reg_class
   while (0)
 
 /* Calling convention definitions.  */
-typedef struct or1k_args
-{
-  int regs_used;
-} CUMULATIVE_ARGS;
-
+#define CUMULATIVE_ARGS int
 #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \
-  do { (CUM).regs_used = 0; } while (0)
+  do { (CUM) = 0; } while (0)
 
 
 /* Trampolines, for nested functions */
@@ -218,7 +250,7 @@ typedef struct or1k_args
    'crtl->outgoing_args_size'.  No space will be pushed
    onto the stack for each call; instead, the function prologue
    should increase the stack frame size by this amount.  */
-#define ACCUMULATE_OUTGOING_ARGS 1
+#define ACCUMULATE_OUTGOING_ARGS 0
 
 /* Offset from the argument pointer register to the first argument's
    address.  On some machines it may depend on the data type of the
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 5ba46925614..8e459b58408 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -135,7 +135,7 @@
 }")
 
 (define_insn "*call"
-  [(call (mem:SI (match_operand:SI 0 "general_operand" "r,s"))
+  [(call (mem:SI (match_operand:SI 0 "general_operand" "r,i"))
 	 (match_operand 1 "" ""))
    (clobber (reg:SI LR_REGNUM))]
   ""
@@ -161,7 +161,7 @@
 
 (define_insn "*call_value"
   [(set (match_operand 0 "register_operand" "=r,r")
-	(call (mem:SI (match_operand:SI 1 "general_operand" "r,L"))
+	(call (mem:SI (match_operand:SI 1 "general_operand" "r,i"))
 	      (match_operand 2 "" "")))
    (clobber (reg:SI LR_REGNUM))]
   ""
@@ -173,4 +173,22 @@
 ;; -------------------------------------------------------------------------
 ;; Prologue & Epilogue
 ;; -------------------------------------------------------------------------
+(define_expand "prologue"
+  [(const_int 1)]
+  ""
+  "
+{
+  or1k_expand_prologue ();
+  DONE;
+}")
+
+;; Expand epilogue as RTL
+(define_expand "epilogue"
+  [(return)]
+  ""
+  "
+{
+  or1k_expand_epilogue ();
+  DONE;
+}")
 
-- 
2.18.0


From 575b582d3e54da67af5493ffb86e96ea96fbe040 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Mon, 26 Mar 2018 06:21:49 +0900
Subject: [PATCH 009/108] or1k: expand readme, a few cleanup for style

---
 README.md               | 58 +++++++++++++++++++++++++++++++++++++++++
 gcc/config/or1k/or1k.h  |  3 ++-
 gcc/config/or1k/or1k.md | 23 +++++++---------
 3 files changed, 70 insertions(+), 14 deletions(-)

diff --git a/README.md b/README.md
index cf5df4efefb..2dd63445e70 100644
--- a/README.md
+++ b/README.md
@@ -15,9 +15,67 @@ These items should be done to get to a point where very basic things compile.
 - moves - DONE
 - jump - DONE
 - branches
+- tuning
+  - ensure varargs are to spec
+  - ensure we can return 64-bit values in r11 and r12
+  - proper support for returning small structs/vectors in regs
+  - optional support for frame pointers
+  - delay slot
+  - optional support for delay slot
+  - correct predicates and constraints
 
 ## building
 
 ### Stage 1 build
+
+```
+mkdir build
+cd build
 ../gcc/configure --target=or1k-elf --disable-shared --enable-stage1-languages=c --prefix=/home/shorne/work/gnu-toolchain/local
 make -j5
+
+# Currently the entire build will not complete, but gcc will work, you can build
+# gcc in the directory using
+cd gcc
+./xgcc -B. -S ../../gcc/test2.c -fdump-rtl-all
+
+```
+
+## bootstrap tests
+
+Below are some really basic test programs we can compile before we move on to
+the testsuite to check things.
+
+### Verify types
+```
+/* Just test some types */
+    int myint;
+    short myshort;
+    double mydouble;
+```
+
+### Verify call/return
+```
+    int foo(int, int);
+    int main()
+    {
+       return foo (111, 222);
+    }
+```
+
+### Verify prolog/epilog
+```
+
+    int g;
+
+    int add(int a, int b, int c, int d, int e, int f)
+    {
+      return a + b + c + d + e + f + g;
+    }
+
+    int main()
+    {
+      g = 7;
+      return (add (1, 2, 3, 4, 5, 6));
+    }
+```
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index f5a9e18da18..215b00e4b3a 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -118,6 +118,7 @@
 #define TLS_REGNUM  10
 #define RV_REGNUM   11
 #define RVH_REGNUM  12
+#define AP_REGNUM   32
 
 #define FIXED_REGISTERS   \
 { 1, 1, 0, 0, 0, 0, 0, 0, \
@@ -161,7 +162,7 @@ enum reg_class
    choose a class which is "minimal", meaning that no smaller class
    also contains the register.  */
 #define REGNO_REG_CLASS(REGNO) \
-  (REGNO < FIRST_PSEUDO_REGISTER ? GENERAL_REGS : SPECIAL_REGS)
+  (REGNO == AP_REGNUM ? SPECIAL_REGS : GENERAL_REGS)
 
 /* Assembly definitions.  */
 
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 8e459b58408..df6e611e1da 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -49,8 +49,8 @@
 (define_insn "addsi3"
   [(set (match_operand:SI 0 "register_operand" "=r,r")
 	  (plus:SI
-	   (match_operand:SI 1 "register_operand" "0,0")
-	   (match_operand:SI 2 "general_operand" "0,J")))]
+	   (match_operand:SI 1 "register_operand" "r,r")
+	   (match_operand:SI 2 "general_operand" "r,J")))]
   ""
   "@
   l.add\t%0, %1, %2
@@ -59,8 +59,8 @@
 (define_insn "subsi3"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	  (minus:SI
-	   (match_operand:SI 1 "register_operand" "0")
-	   (match_operand:SI 2 "register_operand" "0")))]
+	   (match_operand:SI 1 "register_operand" "r")
+	   (match_operand:SI 2 "register_operand" "r")))]
   ""
   "l.sub\t%0, %1 %2")
 
@@ -80,10 +80,11 @@
   [(set (match_operand:SI 0 "nonimmediate_operand" "")
 	(match_operand:SI 1 "general_operand" ""))]
   ""
+  "
 {
   if (MEM_P (operands[0]))
     operands[1] = force_reg (SImode, operands[1]);
-})
+}")
 
 (define_insn "*movsi_internal"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,r,W,r")
@@ -112,14 +113,12 @@
 (define_insn "jump"
   [(set (pc) (label_ref (match_operand 0 "" "")))]
   ""
-  "l.j\t%0"
-)
+  "l.j\t%0")
 
 (define_insn "indirect_jump"
   [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
   ""
-  "l.jr\t%0"
-)
+  "l.jr\t%0")
 
 (define_expand "call"
   [(parallel [(call (match_operand 0 "" "")
@@ -141,8 +140,7 @@
   ""
   "@
    l.jalr\t%0
-   l.jal\t%0"
-)
+   l.jal\t%0")
 
 ;; Call with a retun value
 (define_expand "call_value"
@@ -167,8 +165,7 @@
   ""
   "@
    l.jalr\t%1
-   l.jal\t%1"
-)
+   l.jal\t%1")
 
 ;; -------------------------------------------------------------------------
 ;; Prologue & Epilogue
-- 
2.18.0


From 6e43f55f1364c1271f35f463a17e2bb4d10c7257 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Mon, 26 Mar 2018 10:34:32 +0900
Subject: [PATCH 010/108] or1k: readme updates

---
 README.md | 13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

diff --git a/README.md b/README.md
index 2dd63445e70..c19a7c5550c 100644
--- a/README.md
+++ b/README.md
@@ -32,19 +32,20 @@ These items should be done to get to a point where very basic things compile.
 mkdir build
 cd build
 ../gcc/configure --target=or1k-elf --disable-shared --enable-stage1-languages=c --prefix=/home/shorne/work/gnu-toolchain/local
-make -j5
+make -j5 all-gcc
+make install-gcc
 
-# Currently the entire build will not complete, but gcc will work, you can build
-# gcc in the directory using
-cd gcc
-./xgcc -B. -S ../../gcc/test2.c -fdump-rtl-all
+# Currently the entire build will not complete, but gcc will work, you can then
+# test gcc using one of the below tests
+../local/bin/or1k-elf-gcc -S ../gcc/test2.c -fdump-rtl-all
 
 ```
 
 ## bootstrap tests
 
 Below are some really basic test programs we can compile before we move on to
-the testsuite to check things.
+the testsuite to check things.  I pulled these from the ggx toolchain porting
+tutorial.
 
 ### Verify types
 ```
-- 
2.18.0


From 2e7b60c5364c13ae7290c7c43850e491fb54c9e1 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Mon, 26 Mar 2018 20:40:28 +0900
Subject: [PATCH 011/108] or1k: fix reload bug, actually define all_regs class

The all regs class was broken after adding the special_regs
class.  Fix this, which now should fix the whole reload not
being able to find any registers issue.
---
 gcc/config/or1k/or1k.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 215b00e4b3a..6c34d8b44cc 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -154,6 +154,7 @@ enum reg_class
 #define REG_CLASS_CONTENTS      \
 { {0x00000000, 0x00000000},	\
   {0xffffffff, 0x00000000},	\
+  {0x00000000, 0x00000001},	\
   {0xffffffff, 0x00000001}	\
 }
 
-- 
2.18.0


From ac443132d2881434c80d10916dccda295008bef3 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 27 Mar 2018 05:58:48 +0900
Subject: [PATCH 012/108] or1k: a few fixups proper memory constrints, returner

Could not compile without these.
---
 gcc/config/or1k/constraints.md | 3 ++-
 gcc/config/or1k/or1k.c         | 4 ++--
 gcc/config/or1k/or1k.md        | 6 ++++++
 3 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/gcc/config/or1k/constraints.md b/gcc/config/or1k/constraints.md
index 536c6b77cbb..29c310a9893 100644
--- a/gcc/config/or1k/constraints.md
+++ b/gcc/config/or1k/constraints.md
@@ -26,7 +26,8 @@
 (define_constraint "W"
   "A register indirect memory operand."
   (and (match_code "mem")
-       (match_test "or1k_legitimate_address_p (mode, op, false)")))
+       (match_test "or1k_legitimate_address_p (GET_MODE (op),
+					       XEXP (op, 0), false)")))
 
 ;; Immediates
 (define_constraint "I"
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index bbbc4cf5e7f..5f7bc05b798 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -208,7 +208,7 @@ or1k_expand_prologue (void)
   offset = cfun->machine->total_size;
   if (offset != 0)
     {
-      rtx insn = emit_insn (gen_subsi3 (stack_pointer_rtx,
+      rtx insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
 					stack_pointer_rtx,
 				    	GEN_INT (offset)));
       RTX_FRAME_RELATED_P (insn) = 1;
@@ -254,7 +254,7 @@ or1k_expand_epilogue (void)
   gcc_assert (offset == -4);
   or1k_save_restore_reg (LR_REGNUM, offset, false);
 
-  emit_jump_insn (gen_indirect_jump (gen_rtx_REG (Pmode, LR_REGNUM)));
+  emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, LR_REGNUM)));
 }
 
 int
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index df6e611e1da..9d09697178b 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -189,3 +189,9 @@
   DONE;
 }")
 
+(define_insn "return_internal"
+  [(use (match_operand:SI 0 "register_operand" "r"))
+   (return)]
+  ""
+  "l.jr\t%0")
+
-- 
2.18.0


From f4302171c94cec27a5d4f6b10dd8812efbf756e7 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 27 Mar 2018 06:25:22 +0900
Subject: [PATCH 013/108] or1k: add print operands, needs some cleanup

This is copied from moxie, but I think its possible for this to be a bit
more simple using less macros.  But it works for us now.
---
 gcc/config/or1k/or1k.c | 105 +++++++++++++++++++++++++++++++++++++++--
 1 file changed, 101 insertions(+), 4 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 5f7bc05b798..a1c37bc9703 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -205,7 +205,7 @@ or1k_expand_prologue (void)
   or1k_save_restore_reg (LR_REGNUM, offset, true);
 
   /* Finally, adjust the stack pointer.  */
-  offset = cfun->machine->total_size;
+  offset = -1 * cfun->machine->total_size;
   if (offset != 0)
     {
       rtx insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
@@ -225,9 +225,9 @@ or1k_expand_epilogue (void)
   offset = -1 * cfun->machine->total_size;
 
   if (offset != 0)
-    rtx insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
-				      stack_pointer_rtx,
-				      GEN_INT (-1 * offset)));
+    emit_insn (gen_addsi3 (stack_pointer_rtx,
+			   stack_pointer_rtx,
+			   GEN_INT (-1 * offset)));
 
   /* Reverse space for local vars.  */
   offset += cfun->machine->local_vars_size;
@@ -342,6 +342,96 @@ or1k_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
   return (size == -1 || size > (2 * UNITS_PER_WORD));
 }
 
+/* Worker function for TARGET_PRINT_OPERAND_ADDRESS.  */
+
+static void
+or1k_print_operand_address (FILE *file, machine_mode, rtx x)
+{
+  switch (GET_CODE (x))
+    {
+    case REG:
+      fprintf (file, "(%s)", reg_names[REGNO (x)]);
+      break;
+
+    case PLUS:
+      switch (GET_CODE (XEXP (x, 1)))
+	{
+	case CONST_INT:
+	  fprintf (file, "%ld(%s)",
+		   INTVAL(XEXP (x, 1)), reg_names[REGNO (XEXP (x, 0))]);
+	  break;
+	case SYMBOL_REF:
+	  output_addr_const (file, XEXP (x, 1));
+	  fprintf (file, "(%s)", reg_names[REGNO (XEXP (x, 0))]);
+	  break;
+	case CONST:
+	  {
+	    rtx plus = XEXP (XEXP (x, 1), 0);
+	    if (GET_CODE (XEXP (plus, 0)) == SYMBOL_REF
+		&& CONST_INT_P (XEXP (plus, 1)))
+	      {
+		output_addr_const(file, XEXP (plus, 0));
+		fprintf (file,"+%ld(%s)", INTVAL (XEXP (plus, 1)),
+			 reg_names[REGNO (XEXP (x, 0))]);
+	      }
+	    else
+	      abort();
+	  }
+	  break;
+	default:
+	  abort();
+	}
+      break;
+
+    default:
+      output_addr_const (file, x);
+      break;
+    }
+}
+
+/* Worker function for TARGET_PRINT_OPERAND.  */
+
+static void
+or1k_print_operand (FILE *file, rtx x, int code)
+{
+  rtx operand = x;
+
+  switch (code)
+    {
+    case 0:
+      /* No code, print as usual.  */
+      break;
+
+    default:
+      internal_error ("invalid operand modifier letter: %d", code);
+    }
+
+  /* Print an operand as without a modifier letter.  */
+  switch (GET_CODE (operand))
+    {
+    case REG:
+      if (REGNO (operand) > 31)
+	internal_error ("internal error: bad register: %d", REGNO (operand));
+      fprintf (file, "%s", reg_names[REGNO (operand)]);
+      return;
+
+    case MEM:
+      output_address (GET_MODE (XEXP (operand, 0)), XEXP (operand, 0));
+      return;
+
+    default:
+      /* No need to handle all strange variants, let output_addr_const
+	 do it for us.  */
+      if (CONSTANT_P (operand))
+	{
+	  output_addr_const (file, operand);
+	  return;
+	}
+
+      internal_error ("unexpected operand: %d", GET_CODE (operand));
+    }
+}
+
 #undef TARGET_OPTION_OVERRIDE
 #define TARGET_OPTION_OVERRIDE or1k_option_override
 
@@ -367,6 +457,13 @@ or1k_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
 #undef TARGET_PASS_BY_REFERENCE
 #define	TARGET_PASS_BY_REFERENCE hook_pass_by_reference_must_pass_in_stack
 
+/* Assembly generation.  */
+#undef  TARGET_PRINT_OPERAND
+#define TARGET_PRINT_OPERAND or1k_print_operand
+#undef  TARGET_PRINT_OPERAND_ADDRESS
+#define TARGET_PRINT_OPERAND_ADDRESS or1k_print_operand_address
+
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-or1k.h"
-- 
2.18.0


From 11e7c442bbed52f8c3222cbd104dce4ee7106166 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 27 Mar 2018 06:33:03 +0900
Subject: [PATCH 014/108] or1k: fix reg-to-reg moves

---
 gcc/config/or1k/or1k.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 9d09697178b..cee7234acaa 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -91,7 +91,7 @@
 	(match_operand:SI 1 "general_operand" "r,I,J,K,r,W"))]
   "register_operand (operands[0], SImode) || register_operand (operands[1], SImode)"
   "@
-   l.ori\t%0, r0, %1
+   l.or\t%0, r0, %1
    l.movhi\t%0, %1
    l.ori\t%0, r0, %1
    l.movhi\t%0, %1
-- 
2.18.0


From 29c7eeb66d01e73da7fca1cf8cfc3724bcab3a81 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Wed, 28 Mar 2018 07:48:46 +0900
Subject: [PATCH 015/108] or1k: fix frame pointer saving and handling of label
 loads

hack here, Need to use split instead of the 2 line instruction.
---
 gcc/config/or1k/or1k.c  | 5 +++--
 gcc/config/or1k/or1k.md | 7 ++++---
 2 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index a1c37bc9703..91ece2229cd 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -192,15 +192,16 @@ or1k_expand_prologue (void)
 	}
     }
 
-  /* Save frame pointer.  */
+  /* Save and update frame pointer.  */
   if (frame_pointer_needed)
     {
       gcc_assert (offset == -8);
       or1k_save_restore_reg (FP_REGNUM, offset, true);
+      emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);
       offset += 4;
     }
 
-  /* Save the linkr register.  */
+  /* Save the link register.  */
   gcc_assert (offset == -4);
   or1k_save_restore_reg (LR_REGNUM, offset, true);
 
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index cee7234acaa..f7d8b4d7b85 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -87,8 +87,8 @@
 }")
 
 (define_insn "*movsi_internal"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,r,W,r")
-	(match_operand:SI 1 "general_operand" "r,I,J,K,r,W"))]
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,r,W,r,r")
+	(match_operand:SI 1 "general_operand" "r,I,J,K,r,W,i"))]
   "register_operand (operands[0], SImode) || register_operand (operands[1], SImode)"
   "@
    l.or\t%0, r0, %1
@@ -96,7 +96,8 @@
    l.ori\t%0, r0, %1
    l.movhi\t%0, %1
    l.sw\t%0, %1
-   l.lwz\t%0, %1")
+   l.lwz\t%0, %1
+   l.movhi\t%0, hi(%1)\n\tl.ori\t%0, %0, lo(%1)")
 
 
 ;; -------------------------------------------------------------------------
-- 
2.18.0


From 834bf881ab3eafb33a91a8bca1ac591158917b83 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Mon, 2 Apr 2018 06:25:42 +0900
Subject: [PATCH 016/108] or1k: Implement branching

This is the first change which I really couldnt find a good example
in other architectures, that means I really needed to understand
define_expand and define_split and interators.  It seems to work
pretty well to split a branch into the compare and branch if flag
instructions.
---
 README.md               |  2 +-
 gcc/config/or1k/or1k.c  |  6 ++++-
 gcc/config/or1k/or1k.h  | 16 ++++++-------
 gcc/config/or1k/or1k.md | 51 ++++++++++++++++++++++++++++++++++++++++-
 4 files changed, 64 insertions(+), 11 deletions(-)

diff --git a/README.md b/README.md
index c19a7c5550c..0c9b6a626e4 100644
--- a/README.md
+++ b/README.md
@@ -14,7 +14,7 @@ These items should be done to get to a point where very basic things compile.
 - load/store - DONE
 - moves - DONE
 - jump - DONE
-- branches
+- branches - DONE
 - tuning
   - ensure varargs are to spec
   - ensure we can return 64-bit values in r11 and r12
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 91ece2229cd..4c6bf9d65d4 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -420,6 +420,11 @@ or1k_print_operand (FILE *file, rtx x, int code)
       output_address (GET_MODE (XEXP (operand, 0)), XEXP (operand, 0));
       return;
 
+    case CODE_LABEL:
+    case LABEL_REF:
+      output_asm_label (operand);
+      break;
+
     default:
       /* No need to handle all strange variants, let output_addr_const
 	 do it for us.  */
@@ -428,7 +433,6 @@ or1k_print_operand (FILE *file, rtx x, int code)
 	  output_addr_const (file, operand);
 	  return;
 	}
-
       internal_error ("unexpected operand: %d", GET_CODE (operand));
     }
 }
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 6c34d8b44cc..5657bfd6b1c 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -109,8 +109,6 @@
    r30   callee saved
    r31   temporary  */
 
-#define FIRST_PSEUDO_REGISTER  33
-
 #define ZERO_REGNUM   0
 #define SP_REGNUM   1
 #define FP_REGNUM   2
@@ -119,20 +117,22 @@
 #define RV_REGNUM   11
 #define RVH_REGNUM  12
 #define AP_REGNUM   32
+#define CC_REGNUM   33
+#define FIRST_PSEUDO_REGISTER  34
 
 #define FIXED_REGISTERS   \
 { 1, 1, 0, 0, 0, 0, 0, 0, \
   0, 0, 1, 0, 0, 0, 0, 0, \
   0, 0, 0, 0, 0, 0, 0, 0, \
   0, 0, 0, 0, 0, 0, 0, 0, \
-  1}
+  1, 1}
 
 #define CALL_USED_REGISTERS \
 { 1, 1, 0, 0, 0, 0, 0, 0, \
   0, 1, 1, 1, 1, 0, 0, 0, \
   0, 0, 0, 0, 0, 0, 0, 0, \
   0, 0, 0, 0, 0, 0, 0, 0, \
-  1}
+  1, 1}
 
 enum reg_class
 {
@@ -154,8 +154,8 @@ enum reg_class
 #define REG_CLASS_CONTENTS      \
 { {0x00000000, 0x00000000},	\
   {0xffffffff, 0x00000000},	\
-  {0x00000000, 0x00000001},	\
-  {0xffffffff, 0x00000001}	\
+  {0x00000000, 0x00000003},	\
+  {0xffffffff, 0x00000003}	\
 }
 
 /* A C expression whose value is a register class containing hard
@@ -163,7 +163,7 @@ enum reg_class
    choose a class which is "minimal", meaning that no smaller class
    also contains the register.  */
 #define REGNO_REG_CLASS(REGNO) \
-  (REGNO == AP_REGNUM ? SPECIAL_REGS : GENERAL_REGS)
+  (REGNO == AP_REGNUM || REGNO == CC_REGNUM ? SPECIAL_REGS : GENERAL_REGS)
 
 /* Assembly definitions.  */
 
@@ -179,7 +179,7 @@ enum reg_class
   "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",	\
   "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",	\
   "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",	\
-  "?ap" }
+  "?ap",  "?cc" }
 
 /* This is how to output an assembler line
    that says to advance the location counter
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index f7d8b4d7b85..0c7f07195cd 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -27,7 +27,8 @@
 
 ;; Register numbers
 (define_constants
-  [(LR_REGNUM       9)]
+  [(LR_REGNUM       9)
+   (CC_REGNUM      33)]
 )
 
 ; Most instructions are 4 bytes long.
@@ -104,10 +105,58 @@
 ;; Compare instructions
 ;; -------------------------------------------------------------------------
 
+;; OpenRISC supports these integer comparisons:
+;;
+;;     l.sfeq[i] - equality, r r or r i
+;;     l.sfne[i] - not equal, r r or r i
+;;     l.sflt{s,u}[i] - less than, signed or unsigned, r r or r i
+;;     l.sfle{s,u}[i] - less than or equal, signed or unsigned, r r or r i
+;;     l.sfgt{s,u}[i] - greater than, signed or unsigned, r r or r i
+;;     l.sfge{s,u}[i] - greater than or equal, signed or unsigned, r r or r i
+;;
+;;  EQ,NE,LT,LTU,LE,LEU,GT,GTU,GE,GEU
+;;  We try to iterate all of thse
+;;
+
+(define_code_iterator cond [ne eq lt ltu gt gtu ge le geu leu])
+(define_code_attr insn [(ne "ne") (eq "eq") (lt "lts") (ltu "ltu")
+			(gt "gts") (gtu "gtu") (ge "ges") (le "les")
+			(geu "geu") (leu "leu") ])
+
+(define_insn "sf<code>_insn"
+  [(set (reg:CC CC_REGNUM)
+	(cond (match_operand:SI 0 "register_operand" "r,r")
+	      (match_operand:SI 1 "general_operand" "r,J")))]
+  ""
+  "@
+   l.sf<insn>\t%0, %1
+   l.sf<insn>i\t%0, %1")
+
 ;; -------------------------------------------------------------------------
 ;; Branch instructions
 ;; -------------------------------------------------------------------------
 
+(define_insn "*cbranchsi4_internal"
+  [(set (pc)
+	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "l.bf\t%0")
+
+
+(define_expand "cbranchsi4"
+  [(set (reg:CC CC_REGNUM)
+	(match_operator 0 "comparison_operator"
+	  [(match_operand:SI 1 "register_operand" "")
+	   (match_operand:SI 2 "general_operand" "")]))
+   (set (pc)
+	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
+		      (label_ref (match_operand 3 "" ""))
+		      (pc)))]
+  ""
+  "")
+
 ;; -------------------------------------------------------------------------
 ;; Call and Jump instructions
 ;; -------------------------------------------------------------------------
-- 
2.18.0


From 670343709ec667fadefdeb088e3a4d7ea5db6ae3 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Mon, 2 Apr 2018 12:00:10 +0900
Subject: [PATCH 017/108] or1k: use 0 for 0 offset reg loads

This is what the assembler expects.
---
 gcc/config/or1k/or1k.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 4c6bf9d65d4..147759e300e 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -351,7 +351,7 @@ or1k_print_operand_address (FILE *file, machine_mode, rtx x)
   switch (GET_CODE (x))
     {
     case REG:
-      fprintf (file, "(%s)", reg_names[REGNO (x)]);
+      fprintf (file, "0(%s)", reg_names[REGNO (x)]);
       break;
 
     case PLUS:
-- 
2.18.0


From 03efad946e81e0d8da5991a94f1efd57fc83b5c7 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Mon, 2 Apr 2018 12:02:30 +0900
Subject: [PATCH 018/108] or1k: simplication for branches

No need to do any comparison for CC since we dont actually
do it.
---
 gcc/config/or1k/or1k.md | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 0c7f07195cd..5881fd5aa9d 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -138,7 +138,7 @@
 
 (define_insn "*cbranchsi4_internal"
   [(set (pc)
-	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
+	(if_then_else (reg:CC CC_REGNUM)
 		      (label_ref (match_operand 0 "" ""))
 		      (pc)))]
   ""
@@ -151,7 +151,7 @@
 	  [(match_operand:SI 1 "register_operand" "")
 	   (match_operand:SI 2 "general_operand" "")]))
    (set (pc)
-	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
+	(if_then_else (reg:CC CC_REGNUM)
 		      (label_ref (match_operand 3 "" ""))
 		      (pc)))]
   ""
-- 
2.18.0


From 9d84bd2d0228d70b96ed74a5be7c594a794a17d3 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Mon, 2 Apr 2018 21:01:33 +0900
Subject: [PATCH 019/108] Revert "or1k: simplication for branches"

This reverts commit bdbfa1949c0c3eaf51371e2cc87d6ac899d9aaba.

It seems no comparison in the if/then/else causes optimization failures
at -O2.
---
 gcc/config/or1k/or1k.md | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 5881fd5aa9d..0c7f07195cd 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -138,7 +138,7 @@
 
 (define_insn "*cbranchsi4_internal"
   [(set (pc)
-	(if_then_else (reg:CC CC_REGNUM)
+	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
 		      (label_ref (match_operand 0 "" ""))
 		      (pc)))]
   ""
@@ -151,7 +151,7 @@
 	  [(match_operand:SI 1 "register_operand" "")
 	   (match_operand:SI 2 "general_operand" "")]))
    (set (pc)
-	(if_then_else (reg:CC CC_REGNUM)
+	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
 		      (label_ref (match_operand 3 "" ""))
 		      (pc)))]
   ""
-- 
2.18.0


From 78fb9623f772292e46fef8f7f850df2eab7e5ba5 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 3 Apr 2018 22:28:33 +0900
Subject: [PATCH 020/108] or1k: Add sections and some dwarf macros

This is to get things compiling with -g.
---
 gcc/config/or1k/or1k.h | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 5657bfd6b1c..95e7e288d26 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -173,6 +173,10 @@ enum reg_class
 #define ASM_COMMENT_START "# "
 
 #define GLOBAL_ASM_OP "\t.global\t"
+#define TEXT_SECTION_ASM_OP "\t.section\t.text"
+#define DATA_SECTION_ASM_OP "\t.section\t.data"
+#define BSS_SECTION_ASM_OP "\t.section\t.bss"
+#define SBSS_SECTION_ASM_OP "\t.section\t.sbss"
 
 #define REGISTER_NAMES {						\
   "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",		\
@@ -277,4 +281,9 @@ enum reg_class
 /* Profiling */
 #define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)
 
+/* Dwarf 2 Support */
+#define DWARF2_DEBUGGING_INFO 1
+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, LR_REGNUM)
+#define DWARF_FRAME_RETURN_COLUMN LR_REGNUM
+
 #endif /* GCC_OR1K_H */
-- 
2.18.0


From c73e7cfecb2bf87fadb927acb37b84d007002516 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 3 Apr 2018 23:55:58 +0900
Subject: [PATCH 021/108] gcc: getting libgcc to compile
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Just stubs for now.  Failing on:

../../../gcc/libgcc/libgcc2.c: In function __addvsi3:
../../../gcc/libgcc/libgcc2.c:80:7: internal compiler error: in
emit_move_multi_word, at expr.c:3581
   if (b >= 0 ? w < a : w > a)
       ^
0x7ad929 emit_move_multi_word
        ../../gcc/gcc/expr.c:3581
0x7a9dbe emit_move_insn(rtx_def*, rtx_def*)
        ../../gcc/gcc/expr.c:3757
0x798a65 emit_store_flag_force(rtx_def*, rtx_code, rtx_def*, rtx_def*,
machine_mode, int, int)
        ../../gcc/gcc/expmed.c:6146
0x7ba2ea do_store_flag
        ../../gcc/gcc/expr.c:11676
0x7ba2ea expand_expr_real_2(separate_ops*, rtx_def*, machine_mode,
expand_modifier)
        ../../gcc/gcc/expr.c:9405
---
 gcc/config/or1k/or1k.c    | 13 +++++++++++++
 gcc/config/or1k/or1k.h    |  2 +-
 gcc/config/or1k/or1k.md   |  2 +-
 libgcc/config.host        |  6 ++++++
 libgcc/config/or1k/t-or1k | 21 +++++++++++++++++++++
 5 files changed, 42 insertions(+), 2 deletions(-)
 create mode 100644 libgcc/config/or1k/t-or1k

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 147759e300e..4cd148e4250 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -292,6 +292,17 @@ or1k_function_value (const_tree valtype,
   return gen_rtx_REG (TYPE_MODE (valtype), RV_REGNUM);
 }
 
+/* Worker function for TARGET_LIBCALL_VALUE.  */
+
+static rtx
+or1k_libcall_value (machine_mode mode,
+		    const_rtx fun ATTRIBUTE_UNUSED)
+{
+  /* TODO support 2 reg return values and return on stack?  */
+  return gen_rtx_REG (mode, RV_REGNUM);
+}
+
+
 /* Worker function for TARGET_FUNCTION_VALUE_REGNO_P.  */
 
 static bool
@@ -449,6 +460,8 @@ or1k_print_operand (FILE *file, rtx x, int code)
 /* Calling Conventions.  */
 #undef TARGET_FUNCTION_VALUE
 #define TARGET_FUNCTION_VALUE or1k_function_value
+#undef TARGET_LIBCALL_VALUE
+#define TARGET_LIBCALL_VALUE or1k_libcall_value
 #undef TARGET_FUNCTION_VALUE_REGNO_P
 #define TARGET_FUNCTION_VALUE_REGNO_P or1k_function_value_regno_p
 #undef TARGET_FUNCTION_ARG
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 95e7e288d26..273b7add613 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -203,7 +203,7 @@ enum reg_class
 
 
 /* Trampolines, for nested functions */
-#define TRAMPOLINE_SIZE (abort (), 0)
+#define TRAMPOLINE_SIZE 12
 #define TRAMPOLINE_ALIGNMENT (abort (), 0)
 
 /* Pointer mode */
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 0c7f07195cd..df08f4512a0 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -63,7 +63,7 @@
 	   (match_operand:SI 1 "register_operand" "r")
 	   (match_operand:SI 2 "register_operand" "r")))]
   ""
-  "l.sub\t%0, %1 %2")
+  "l.sub\t%0, %1, %2")
 
 ;; -------------------------------------------------------------------------
 ;; Unary arithmetic instructions
diff --git a/libgcc/config.host b/libgcc/config.host
index 11b4acaff55..f98c7ae9fb1 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -162,6 +162,9 @@ nds32*-*)
 nios2*-*-*)
 	cpu_type=nios2
 	;;
+or1k*-*-*)
+	cpu_type=or1k
+	;;
 powerpc*-*-*)
 	cpu_type=rs6000
 	;;
@@ -1005,6 +1008,9 @@ nios2-*-*)
 	tmake_file="$tmake_file nios2/t-nios2 t-softfp-sfdf t-softfp-excl t-softfp"
 	extra_parts="$extra_parts crti.o crtn.o"
 	;;
+or1k-*-*)
+	tmake_file="$tmake_file or1k/t-or1k"
+	;;
 pdp11-*-*)
 	tmake_file="pdp11/t-pdp11 t-fdpbit"
 	;;
diff --git a/libgcc/config/or1k/t-or1k b/libgcc/config/or1k/t-or1k
new file mode 100644
index 00000000000..583470af589
--- /dev/null
+++ b/libgcc/config/or1k/t-or1k
@@ -0,0 +1,21 @@
+# Libgcc Makefile fragment for OpenRISC
+# Copyright (C) 2018 Free Software Foundation, Inc.
+# Contributed by Stafford Horne.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published
+# by the Free Software Foundation; either version 3, or (at your
+# option) any later version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+# License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+
-- 
2.18.0


From 6ba8b806d67e6c690ffb36843d4b32e723b3ca61 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Fri, 6 Apr 2018 08:15:00 +0900
Subject: [PATCH 022/108] or1k: support for 8-bit and 16-bit ops

---
 gcc/config/or1k/or1k.h  |  8 +++++++
 gcc/config/or1k/or1k.md | 46 +++++++++++++++++++++++++++++++++++++++++
 2 files changed, 54 insertions(+)

diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 273b7add613..032f56ce52d 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -165,6 +165,14 @@ enum reg_class
 #define REGNO_REG_CLASS(REGNO) \
   (REGNO == AP_REGNUM || REGNO == CC_REGNUM ? SPECIAL_REGS : GENERAL_REGS)
 
+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)               \
+do {                                                    \
+  if (GET_MODE_CLASS (MODE) == MODE_INT                 \
+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)         \
+    (MODE) = word_mode;                                 \
+} while (0)
+
+
 /* Assembly definitions.  */
 
 #define ASM_APP_ON ""
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index df08f4512a0..7d087b796ad 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -77,6 +77,52 @@
 ;; Move instructions
 ;; -------------------------------------------------------------------------
 
+;; 8-bit moves
+
+(define_expand "movqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "")
+	(match_operand:QI 1 "general_operand" ""))]
+  ""
+  "
+{
+  if (MEM_P (operands[0]))
+    operands[1] = force_reg (QImode, operands[1]);
+}")
+
+(define_insn "*movqi_internal"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,W,r")
+	(match_operand:QI 1 "general_operand"       "r,J,r,W"))]
+  "register_operand (operands[0], QImode) || register_operand (operands[1], QImode)"
+  "@
+   l.or\t%0, r0, %1
+   l.ori\t%0, r0, %1
+   l.sb\t%0, %1
+   l.lbz\t%0, %1")
+
+;; 16-bit moves
+
+(define_expand "movhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "")
+	(match_operand:HI 1 "general_operand" ""))]
+  ""
+  "
+{
+  if (MEM_P (operands[0]))
+    operands[1] = force_reg (HImode, operands[1]);
+}")
+
+(define_insn "*movhi_internal"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,W,r")
+	(match_operand:HI 1 "general_operand"       "r,J,r,W"))]
+  "register_operand (operands[0], HImode) || register_operand (operands[1], HImode)"
+  "@
+   l.or\t%0, r0, %1
+   l.ori\t%0, r0, %1
+   l.sh\t%0, %1
+   l.lhz\t%0, %1")
+
+;; 32-bit moves
+
 (define_expand "movsi"
   [(set (match_operand:SI 0 "nonimmediate_operand" "")
 	(match_operand:SI 1 "general_operand" ""))]
-- 
2.18.0


From c43247a635f8e4d0233cedbb72ad4e500a53b58e Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Thu, 19 Apr 2018 21:59:52 +0900
Subject: [PATCH 023/108] or1k: Few cleanups, proper offsets, still have reload
 bug

---
 gcc/config/or1k/or1k.c  | 30 +++++++++++++++++++++++-------
 gcc/config/or1k/or1k.h  | 34 ++++++++++++++++++----------------
 gcc/config/or1k/or1k.md |  6 +++---
 3 files changed, 44 insertions(+), 26 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 4cd148e4250..c5aaec75044 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -99,11 +99,11 @@ callee_saved_regno_p (int regno)
  *  ---- previous frame --------
  *  current func arg[n]
  *  current func arg[0]   <-- r2 [FP]
- *  ---- current stack frame ---  ^
- *  return address      r9        |
- *  old frame pointer   r2       (+)
- *  callee saved regs             |
- *  local variables               |
+ *  ---- current stack frame ---  ^  ---\
+ *  return address      r9        |     |
+ *  old frame pointer   r2       (+)    |-- machine->total_size
+ *  callee saved regs             |     | > machine->callee_saved_reg_size
+ *  local variables               |  ---/ > machine->local_vars_size
  *  sub function args     <-- r1 [SP]
  *  ----------------------------  |
  *                               (-)
@@ -259,9 +259,25 @@ or1k_expand_epilogue (void)
 }
 
 int
-or1k_initial_elimination_offset (int from ATTRIBUTE_UNUSED, int to ATTRIBUTE_UNUSED)
+or1k_initial_elimination_offset (int from, int to)
 {
-  return 0;
+  int offset;
+
+  /* Set OFFSET to the offset from the stack pointer.  */
+  switch (from)
+    {
+    case FRAME_POINTER_REGNUM:
+      /* This is the high end of the local variable storage, not the
+	 hard frame pointer.  */
+      offset = cfun->machine->total_size;
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+
+  return offset;
+
 }
 
 /* Worker function for TARGET_LEGITIMATE_ADDRESS_P.  */
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 032f56ce52d..f9d23022272 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -51,6 +51,8 @@
 #define PREFERRED_STACK_BOUNDARY 32
 #define MAX_FIXED_MODE_SIZE 64
 
+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT
+
 /* Layout of source language data types.  */
 
 #define INT_TYPE_SIZE 32
@@ -59,7 +61,7 @@
 #define LONG_LONG_TYPE_SIZE 64
 #define FLOAT_TYPE_SIZE 32
 #define DOUBLE_TYPE_SIZE 64
-#define LONG_DOUBLE_TYPE_SIZE DOUBLE_TYPE_SIZE
+#define LONG_DOUBLE_TYPE_SIZE 64
 
 #undef SIZE_TYPE
 #define SIZE_TYPE "unsigned int"
@@ -129,7 +131,7 @@
 
 #define CALL_USED_REGISTERS \
 { 1, 1, 0, 0, 0, 0, 0, 0, \
-  0, 1, 1, 1, 1, 0, 0, 0, \
+  0, 1, 1, 1, 0, 0, 0, 0, \
   0, 0, 0, 0, 0, 0, 0, 0, \
   0, 0, 0, 0, 0, 0, 0, 0, \
   1, 1}
@@ -163,7 +165,9 @@ enum reg_class
    choose a class which is "minimal", meaning that no smaller class
    also contains the register.  */
 #define REGNO_REG_CLASS(REGNO) \
-  (REGNO == AP_REGNUM || REGNO == CC_REGNUM ? SPECIAL_REGS : GENERAL_REGS)
+  ((REGNO >= FIRST_PSEUDO_REGISTER) ? NO_REGS :	\
+   (REGNO == AP_REGNUM || 			\
+    REGNO == CC_REGNUM ? SPECIAL_REGS : GENERAL_REGS))
 
 #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)               \
 do {                                                    \
@@ -172,6 +176,12 @@ do {                                                    \
     (MODE) = word_mode;                                 \
 } while (0)
 
+/* A macro whose definition is the name of the class to which a valid
+   base register must belong.  A base register is one used in an
+   address which is the register value plus a displacement.  */
+#define BASE_REG_CLASS GENERAL_REGS
+
+#define INDEX_REG_CLASS NO_REGS
 
 /* Assembly definitions.  */
 
@@ -224,19 +234,12 @@ do {                                                    \
 
 /* The register number of the arg pointer register, which is used to
    access the function's argument list.  */
-#define ARG_POINTER_REGNUM 32
+#define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM
 
 /* A C expression that is nonzero if REGNO is the number of a hard
    register in which function arguments are sometimes passed.  */
 #define FUNCTION_ARG_REGNO_P(r) (r >= 3 && r <= 8)
 
-/* A macro whose definition is the name of the class to which a vqalid
-   base register must belong.  A base register is one used in an
-   address which is the register value plus a displacement.  */
-#define BASE_REG_CLASS GENERAL_REGS
-
-#define INDEX_REG_CLASS NO_REGS
-
 #define MAX_REGS_PER_ADDRESS 1
 
 /* The ELIMINABLE_REGS macro specifies a table of register pairs used to
@@ -246,8 +249,7 @@ do {                                                    \
 
 #define ELIMINABLE_REGS					\
 {{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },	\
- { ARG_POINTER_REGNUM,	 STACK_POINTER_REGNUM },	\
- { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM }}
+ { ARG_POINTER_REGNUM,	 STACK_POINTER_REGNUM }}
 
 #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
   do {							\
@@ -257,7 +259,7 @@ do {                                                    \
 #define REGNO_OK_FOR_INDEX_P(REGNO) 0
 #define REGNO_OK_FOR_BASE_P(REGNO) \
   ((REGNO) < FIRST_PSEUDO_REGISTER			\
-   || (reg_renumber[REGNO]) < FIRST_PSEUDO_REGISTER)
+   || ((unsigned int) reg_renumber[REGNO]) < FIRST_PSEUDO_REGISTER)
 
 /* If defined, the maximum amount of space required for outgoing
    arguments will be computed and placed into the variable
@@ -270,7 +272,7 @@ do {                                                    \
    address.  On some machines it may depend on the data type of the
    function.  If 'ARGS_GROW_DOWNWARD', this is the offset to the
    location above the first argument's address.  */
-#define FIRST_PARM_OFFSET(FNDECL) 0
+#define FIRST_PARM_OFFSET(FNDECL) (UNITS_PER_WORD)
 
 /* Stack layout and stack pointer usage.  */
 
@@ -280,7 +282,7 @@ do {                                                    \
 
 /* Offset from the stack pointer register to the first location at which
    outgoing arguments are placed.  */
-#define STACK_POINTER_OFFSET 0
+#define STACK_POINTER_OFFSET (UNITS_PER_WORD)
 
 /* An alias for a machine mode name.  This is the machine mode that
    elements of a jump-table should have.  */
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 7d087b796ad..064ed675c95 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -124,8 +124,8 @@
 ;; 32-bit moves
 
 (define_expand "movsi"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "")
-	(match_operand:SI 1 "general_operand" ""))]
+  [(set (match_operand:SI 0 "" "")
+	(match_operand:SI 1 "" ""))]
   ""
   "
 {
@@ -135,7 +135,7 @@
 
 (define_insn "*movsi_internal"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,r,W,r,r")
-	(match_operand:SI 1 "general_operand" "r,I,J,K,r,W,i"))]
+	(match_operand:SI 1 "general_operand"       "r,I,J,K,r,W,i"))]
   "register_operand (operands[0], SImode) || register_operand (operands[1], SImode)"
   "@
    l.or\t%0, r0, %1
-- 
2.18.0


From 99bf2e83adea5484e742ba56c7a070d3c7cefd44 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Fri, 27 Apr 2018 08:10:03 +0900
Subject: [PATCH 024/108] or1k: Add a few new instructions (still having reload
 issues)

---
 gcc/config/or1k/constraints.md |   2 +-
 gcc/config/or1k/or1k.h         |   9 ++-
 gcc/config/or1k/or1k.md        | 135 ++++++++++++++++++++++++++++-----
 3 files changed, 126 insertions(+), 20 deletions(-)

diff --git a/gcc/config/or1k/constraints.md b/gcc/config/or1k/constraints.md
index 29c310a9893..3a48dcb2976 100644
--- a/gcc/config/or1k/constraints.md
+++ b/gcc/config/or1k/constraints.md
@@ -31,7 +31,7 @@
 
 ;; Immediates
 (define_constraint "I"
-  "The constant zerK"
+  "The constant zero"
   (and (match_code "const_int")
        (match_test "ival == 0")))
 
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index f9d23022272..821ae9e509a 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -165,8 +165,8 @@ enum reg_class
    choose a class which is "minimal", meaning that no smaller class
    also contains the register.  */
 #define REGNO_REG_CLASS(REGNO) \
-  ((REGNO >= FIRST_PSEUDO_REGISTER) ? NO_REGS :	\
-   (REGNO == AP_REGNUM || 			\
+  ((REGNO >= FIRST_PSEUDO_REGISTER || REGNO < 0) ? NO_REGS :	\
+   (REGNO == AP_REGNUM || 					\
     REGNO == CC_REGNUM ? SPECIAL_REGS : GENERAL_REGS))
 
 #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)               \
@@ -288,6 +288,11 @@ do {                                                    \
    elements of a jump-table should have.  */
 #define CASE_VECTOR_MODE SImode
 
+#define STORE_FLAG_VALUE 1
+
+/* Indicates how loads of narrow mode values are loaded into words.  */
+#define LOAD_EXTEND_OP(MODE) (ZERO_EXTEND)
+
 /* Profiling */
 #define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)
 
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 064ed675c95..33b659a1863 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -73,6 +73,21 @@
 ;; Logical operators
 ;; -------------------------------------------------------------------------
 
+(define_code_iterator SHIFT  [ashift ashiftrt lshiftrt rotate])
+(define_code_attr shift_op   [(ashift "ashl") (ashiftrt "ashr")
+                              (lshiftrt "lshr") (rotate "rotl")])
+(define_code_attr shift_asm  [(ashift "sll") (ashiftrt "sra")
+                              (lshiftrt "srl") (rotate "ror")])
+
+(define_insn "<shift_op>si3"
+  [(set (match_operand:SI 0 "register_operand"          "=r,r")
+        (SHIFT:SI (match_operand:SI 1 "register_operand" "r,r")
+                  (match_operand:SI 2 "general_operand"  "r,J")))]
+  ""
+  "@
+   l.<shift_asm>\t%0, %1, %2
+   l.<shift_asm>i\t%0, %1, %2")
+
 ;; -------------------------------------------------------------------------
 ;; Move instructions
 ;; -------------------------------------------------------------------------
@@ -90,8 +105,8 @@
 }")
 
 (define_insn "*movqi_internal"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,W,r")
-	(match_operand:QI 1 "general_operand"       "r,J,r,W"))]
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,mW, r")
+	(match_operand:QI 1 "general_operand"       "r,J,r ,mW"))]
   "register_operand (operands[0], QImode) || register_operand (operands[1], QImode)"
   "@
    l.or\t%0, r0, %1
@@ -105,15 +120,14 @@
   [(set (match_operand:HI 0 "nonimmediate_operand" "")
 	(match_operand:HI 1 "general_operand" ""))]
   ""
-  "
-{
+  {
   if (MEM_P (operands[0]))
     operands[1] = force_reg (HImode, operands[1]);
-}")
+})
 
 (define_insn "*movhi_internal"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,W,r")
-	(match_operand:HI 1 "general_operand"       "r,J,r,W"))]
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,mW, r")
+	(match_operand:HI 1 "general_operand"       "r,J,r ,mW"))]
   "register_operand (operands[0], HImode) || register_operand (operands[1], HImode)"
   "@
    l.or\t%0, r0, %1
@@ -127,25 +141,86 @@
   [(set (match_operand:SI 0 "" "")
 	(match_operand:SI 1 "" ""))]
   ""
-  "
-{
-  if (MEM_P (operands[0]))
+  {
+  if (MEM_P (operands[0]) && !REG_P (operands[1]))
     operands[1] = force_reg (SImode, operands[1]);
-}")
+})
 
 (define_insn "*movsi_internal"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,r,W,r,r")
-	(match_operand:SI 1 "general_operand"       "r,I,J,K,r,W,i"))]
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=mW,r,r, r,r,r,r")
+	(match_operand:SI 1 "general_operand"       "r, r,mW,I,J,K,i"))]
   "register_operand (operands[0], SImode) || register_operand (operands[1], SImode)"
   "@
+   l.sw\t%0, %1
    l.or\t%0, r0, %1
+   l.lwz\t%0, %1
    l.movhi\t%0, %1
    l.ori\t%0, r0, %1
    l.movhi\t%0, %1
-   l.sw\t%0, %1
-   l.lwz\t%0, %1
    l.movhi\t%0, hi(%1)\n\tl.ori\t%0, %0, lo(%1)")
 
+;; -------------------------------------------------------------------------
+;; Sign Extending
+;; -------------------------------------------------------------------------
+
+(define_insn "zero_extendhisi2"
+  [(set (match_operand:SI 0 "register_operand"                    "=r,r")
+        (zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
+  ""
+  "@
+   l.andi\t%0, %1, 0xffff
+   l.lhz\t%0, %1")
+
+(define_insn "zero_extendqisi2"
+  [(set (match_operand:SI 0 "register_operand"                    "=r,r")
+        (zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "r,m")))]
+  ""
+  "@
+   l.andi\t%0, %1, 0xff
+   l.lbz\t%0, %1")
+
+;; Sign extension patterns
+
+(define_insn "extendhisi2"
+  [(set (match_operand:SI 0 "register_operand"                     "=r,r")
+	(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand"  "r,m")))]
+  ""
+  "@
+   #
+   l.lhs\t%0, %1")
+
+(define_insn "extendqisi2"
+  [(set (match_operand:SI 0 "register_operand"                     "=r,r")
+	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand"  "r,m")))]
+  ""
+  "@
+   #
+   l.lbs\t%0, %1")
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(sign_extend:SI (match_operand:HI 1 "register_operand" "")))]
+  ""
+  [(set (match_dup 0)
+	(ashift:SI (match_dup 1)
+		   (const_int 16)))
+   (set (match_dup 0)
+	(ashiftrt:SI (match_dup 1)
+		     (const_int 16)))]
+  "operands[1] = gen_lowpart (SImode, operands[1]);")
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(sign_extend:SI (match_operand:QI 1 "register_operand" "")))]
+  ""
+  [(set (match_dup 0)
+	(ashift:SI (match_dup 1)
+		   (const_int 24)))
+   (set (match_dup 0)
+	(ashiftrt:SI (match_dup 1)
+		     (const_int 24)))]
+  "operands[1] = gen_lowpart (SImode, operands[1]);")
+
 
 ;; -------------------------------------------------------------------------
 ;; Compare instructions
@@ -169,7 +244,7 @@
 			(gt "gts") (gtu "gtu") (ge "ges") (le "les")
 			(geu "geu") (leu "leu") ])
 
-(define_insn "sf<code>_insn"
+(define_insn "*sf<code>_insn"
   [(set (reg:CC CC_REGNUM)
 	(cond (match_operand:SI 0 "register_operand" "r,r")
 	      (match_operand:SI 1 "general_operand" "r,J")))]
@@ -178,11 +253,37 @@
    l.sf<insn>\t%0, %1
    l.sf<insn>i\t%0, %1")
 
+;; -------------------------------------------------------------------------
+;; Conditional Store instructions
+;; -------------------------------------------------------------------------
+
+(define_expand "cstoresi4"
+  [(set (reg:CC CC_REGNUM)
+	(match_operator 1 "comparison_operator"
+	  [(match_operand:SI 2 "register_operand" "")
+	   (match_operand:SI 3 "general_operand" "")]))
+   (set (match_operand:SI 0 "register_operand" "")
+	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
+		      (const_int 1)
+		      (const_int 0)))]
+  ""
+  "")
+
+(define_insn "*cmovsi_insn"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
+		      (match_operand:SI 1 "general_operand" "r,r")
+		      (match_operand:SI 2 "general_operand" "r,I")))]
+  ""
+  "@
+   l.cmov\t%0, %1, %2
+   l.cmov\t%0, %1, r0")
+
 ;; -------------------------------------------------------------------------
 ;; Branch instructions
 ;; -------------------------------------------------------------------------
 
-(define_insn "*cbranchsi4_internal"
+(define_insn "*cbranch_internal"
   [(set (pc)
 	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
 		      (label_ref (match_operand 0 "" ""))
-- 
2.18.0


From 7b83f02664cb49ff5304f881298c2d8ba6b527c4 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 1 May 2018 06:18:28 +0900
Subject: [PATCH 025/108] or1k: Fix cstore, implement a few more logic ops

Starting to run testsuite. Still getting some errors during reload
on unwind.
---
 gcc/config/or1k/or1k.md  | 133 ++++++++++++++++++++++++++-------------
 gcc/config/or1k/or1k.opt |  34 ++++++++++
 2 files changed, 122 insertions(+), 45 deletions(-)
 create mode 100644 gcc/config/or1k/or1k.opt

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 33b659a1863..83e4000c2aa 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -27,7 +27,8 @@
 
 ;; Register numbers
 (define_constants
-  [(LR_REGNUM       9)
+  [(ZERO_REGNUM     0)
+   (LR_REGNUM       9)
    (CC_REGNUM      33)]
 )
 
@@ -57,6 +58,62 @@
   l.add\t%0, %1, %2
   l.addi\t%0, %1, %2")
 
+(define_insn "iorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	  (ior:SI
+	   (match_operand:SI 1 "register_operand" "r,r")
+	   (match_operand:SI 2 "general_operand" "r,J")))]
+  ""
+  "@
+  l.or\t%0, %1, %2
+  l.ori\t%0, %1, %2")
+
+(define_insn "andsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	  (and:SI
+	   (match_operand:SI 1 "register_operand" "r,r")
+	   (match_operand:SI 2 "general_operand" "r,J")))]
+  ""
+  "@
+  l.and\t%0, %1, %2
+  l.andi\t%0, %1, %2")
+
+(define_insn "xorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	  (xor:SI
+	   (match_operand:SI 1 "register_operand" "r,r")
+	   (match_operand:SI 2 "general_operand" "r,J")))]
+  ""
+  "@
+  l.xor\t%0, %1, %2
+  l.xori\t%0, %1, %2")
+
+(define_insn "multsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	  (mult:SI
+	   (match_operand:SI 1 "register_operand" "r,r")
+	   (match_operand:SI 2 "general_operand" "r,J")))]
+  ""
+  "@
+  l.mul\t%0, %1, %2
+  l.muli\t%0, %1, %2")
+
+(define_insn "divsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	  (div:SI
+	   (match_operand:SI 1 "register_operand" "r")
+	   (match_operand:SI 2 "general_operand" "r")))]
+  ""
+  "l.div\t%0, %1, %2")
+
+(define_insn "udivsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	  (udiv:SI
+	   (match_operand:SI 1 "register_operand" "r")
+	   (match_operand:SI 2 "general_operand" "r")))]
+  ""
+  "l.divu\t%0, %1, %2")
+
 (define_insn "subsi3"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	  (minus:SI
@@ -92,17 +149,18 @@
 ;; Move instructions
 ;; -------------------------------------------------------------------------
 
-;; 8-bit moves
+(define_mode_iterator I [QI HI SI])
 
-(define_expand "movqi"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "")
-	(match_operand:QI 1 "general_operand" ""))]
+(define_expand "mov<I:mode>"
+  [(set (match_operand:I 0 "nonimmediate_operand" "")
+	(match_operand:I 1 "general_operand" ""))]
   ""
-  "
-{
-  if (MEM_P (operands[0]))
-    operands[1] = force_reg (QImode, operands[1]);
-}")
+  {
+    if (MEM_P (operands[0]))
+      operands[1] = force_reg (<I:MODE>mode, operands[1]);
+})
+
+;; 8-bit moves
 
 (define_insn "*movqi_internal"
   [(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,mW, r")
@@ -116,15 +174,6 @@
 
 ;; 16-bit moves
 
-(define_expand "movhi"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "")
-	(match_operand:HI 1 "general_operand" ""))]
-  ""
-  {
-  if (MEM_P (operands[0]))
-    operands[1] = force_reg (HImode, operands[1]);
-})
-
 (define_insn "*movhi_internal"
   [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,mW, r")
 	(match_operand:HI 1 "general_operand"       "r,J,r ,mW"))]
@@ -137,15 +186,6 @@
 
 ;; 32-bit moves
 
-(define_expand "movsi"
-  [(set (match_operand:SI 0 "" "")
-	(match_operand:SI 1 "" ""))]
-  ""
-  {
-  if (MEM_P (operands[0]) && !REG_P (operands[1]))
-    operands[1] = force_reg (SImode, operands[1]);
-})
-
 (define_insn "*movsi_internal"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=mW,r,r, r,r,r,r")
 	(match_operand:SI 1 "general_operand"       "r, r,mW,I,J,K,i"))]
@@ -181,6 +221,7 @@
 
 ;; Sign extension patterns
 
+;; We can do memory extensions with a single load
 (define_insn "extendhisi2"
   [(set (match_operand:SI 0 "register_operand"                     "=r,r")
 	(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand"  "r,m")))]
@@ -197,6 +238,7 @@
    #
    l.lbs\t%0, %1")
 
+;; For register extensions we need for revert to arithmetic shifts
 (define_split
   [(set (match_operand:SI 0 "register_operand" "")
 	(sign_extend:SI (match_operand:HI 1 "register_operand" "")))]
@@ -239,15 +281,15 @@
 ;;  We try to iterate all of thse
 ;;
 
-(define_code_iterator cond [ne eq lt ltu gt gtu ge le geu leu])
+(define_code_iterator intcmpcc [ne eq lt ltu gt gtu ge le geu leu])
 (define_code_attr insn [(ne "ne") (eq "eq") (lt "lts") (ltu "ltu")
 			(gt "gts") (gtu "gtu") (ge "ges") (le "les")
 			(geu "geu") (leu "leu") ])
 
-(define_insn "*sf<code>_insn"
+(define_insn "*sf<intcmpcc:code>_insn"
   [(set (reg:CC CC_REGNUM)
-	(cond (match_operand:SI 0 "register_operand" "r,r")
-	      (match_operand:SI 1 "general_operand" "r,J")))]
+	(intcmpcc (match_operand:I 0 "register_operand" "r,r")
+	      (match_operand:I 1 "general_operand" "r,J")))]
   ""
   "@
    l.sf<insn>\t%0, %1
@@ -257,23 +299,24 @@
 ;; Conditional Store instructions
 ;; -------------------------------------------------------------------------
 
-(define_expand "cstoresi4"
-  [(set (reg:CC CC_REGNUM)
+(define_expand "cstore<I:mode>4"
+  [(set (match_operand:I 0 "register_operand" "") (const_int 1))
+   (set (reg:CC CC_REGNUM)
 	(match_operator 1 "comparison_operator"
-	  [(match_operand:SI 2 "register_operand" "")
-	   (match_operand:SI 3 "general_operand" "")]))
-   (set (match_operand:SI 0 "register_operand" "")
-	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
-		      (const_int 1)
-		      (const_int 0)))]
+	  [(match_operand:I 2 "register_operand" "")
+	   (match_operand:I 3 "general_operand" "")]))
+   (set (match_dup 0)
+	(if_then_else:I (ne (reg:CC CC_REGNUM) (const_int 0))
+		      (match_dup 0)
+		      (reg:I ZERO_REGNUM)))]
   ""
   "")
 
-(define_insn "*cmovsi_insn"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
-		      (match_operand:SI 1 "general_operand" "r,r")
-		      (match_operand:SI 2 "general_operand" "r,I")))]
+(define_insn "*cmov<I:mode>_insn"
+  [(set (match_operand:I 0 "register_operand" "=r,r")
+	(if_then_else:I (ne (reg:CC CC_REGNUM) (const_int 0))
+		      (match_operand:I 1 "register_operand" "r,r")
+		      (match_operand:I 2 "general_operand" "r,I")))]
   ""
   "@
    l.cmov\t%0, %1, %2
diff --git a/gcc/config/or1k/or1k.opt b/gcc/config/or1k/or1k.opt
new file mode 100644
index 00000000000..8cf7189b28a
--- /dev/null
+++ b/gcc/config/or1k/or1k.opt
@@ -0,0 +1,34 @@
+; OpenRISC command line options
+
+; Copyright (C) 2010-2018 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+; See the GCC internals manual (options.texi) for a description of
+; this file's format.
+
+; Please try to keep this file in ASCII collating order.
+
+mboard=
+Target RejectNegative Joined
+Configure board specific runtime.
+
+mnewlib
+Target RejectNegative
+no description yet.
+
+
-- 
2.18.0


From 6f9387924538ee9de37ef8aa3c1493713b3dc403 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 1 May 2018 06:35:01 +0900
Subject: [PATCH 026/108] or1k: use proper sign extend instructions

---
 gcc/config/or1k/or1k.md | 34 ++++------------------------------
 1 file changed, 4 insertions(+), 30 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 83e4000c2aa..9ca8d76b4f8 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -208,7 +208,7 @@
         (zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
   ""
   "@
-   l.andi\t%0, %1, 0xffff
+   l.exthz\t%0, %1
    l.lhz\t%0, %1")
 
 (define_insn "zero_extendqisi2"
@@ -216,7 +216,7 @@
         (zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "r,m")))]
   ""
   "@
-   l.andi\t%0, %1, 0xff
+   l.extbz\t%0, %1
    l.lbz\t%0, %1")
 
 ;; Sign extension patterns
@@ -227,7 +227,7 @@
 	(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand"  "r,m")))]
   ""
   "@
-   #
+   l.exths\t%0, %1
    l.lhs\t%0, %1")
 
 (define_insn "extendqisi2"
@@ -235,35 +235,9 @@
 	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand"  "r,m")))]
   ""
   "@
-   #
+   l.extbs\t%0, %1
    l.lbs\t%0, %1")
 
-;; For register extensions we need for revert to arithmetic shifts
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-	(sign_extend:SI (match_operand:HI 1 "register_operand" "")))]
-  ""
-  [(set (match_dup 0)
-	(ashift:SI (match_dup 1)
-		   (const_int 16)))
-   (set (match_dup 0)
-	(ashiftrt:SI (match_dup 1)
-		     (const_int 16)))]
-  "operands[1] = gen_lowpart (SImode, operands[1]);")
-
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-	(sign_extend:SI (match_operand:QI 1 "register_operand" "")))]
-  ""
-  [(set (match_dup 0)
-	(ashift:SI (match_dup 1)
-		   (const_int 24)))
-   (set (match_dup 0)
-	(ashiftrt:SI (match_dup 1)
-		     (const_int 24)))]
-  "operands[1] = gen_lowpart (SImode, operands[1]);")
-
-
 ;; -------------------------------------------------------------------------
 ;; Compare instructions
 ;; -------------------------------------------------------------------------
-- 
2.18.0


From cafc36463b2ca7c694023334db364980d36f233e Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 1 May 2018 06:42:47 +0900
Subject: [PATCH 027/108] or1k: Rearrange the logical/arith ops

---
 gcc/config/or1k/or1k.md | 64 +++++++++++++++++++----------------------
 1 file changed, 30 insertions(+), 34 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 9ca8d76b4f8..2ed0927eb5d 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -58,36 +58,6 @@
   l.add\t%0, %1, %2
   l.addi\t%0, %1, %2")
 
-(define_insn "iorsi3"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	  (ior:SI
-	   (match_operand:SI 1 "register_operand" "r,r")
-	   (match_operand:SI 2 "general_operand" "r,J")))]
-  ""
-  "@
-  l.or\t%0, %1, %2
-  l.ori\t%0, %1, %2")
-
-(define_insn "andsi3"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	  (and:SI
-	   (match_operand:SI 1 "register_operand" "r,r")
-	   (match_operand:SI 2 "general_operand" "r,J")))]
-  ""
-  "@
-  l.and\t%0, %1, %2
-  l.andi\t%0, %1, %2")
-
-(define_insn "xorsi3"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	  (xor:SI
-	   (match_operand:SI 1 "register_operand" "r,r")
-	   (match_operand:SI 2 "general_operand" "r,J")))]
-  ""
-  "@
-  l.xor\t%0, %1, %2
-  l.xori\t%0, %1, %2")
-
 (define_insn "multsi3"
   [(set (match_operand:SI 0 "register_operand" "=r,r")
 	  (mult:SI
@@ -122,10 +92,6 @@
   ""
   "l.sub\t%0, %1, %2")
 
-;; -------------------------------------------------------------------------
-;; Unary arithmetic instructions
-;; -------------------------------------------------------------------------
-
 ;; -------------------------------------------------------------------------
 ;; Logical operators
 ;; -------------------------------------------------------------------------
@@ -145,6 +111,36 @@
    l.<shift_asm>\t%0, %1, %2
    l.<shift_asm>i\t%0, %1, %2")
 
+(define_insn "andsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	  (and:SI
+	   (match_operand:SI 1 "register_operand" "r,r")
+	   (match_operand:SI 2 "general_operand" "r,J")))]
+  ""
+  "@
+  l.and\t%0, %1, %2
+  l.andi\t%0, %1, %2")
+
+(define_insn "xorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	  (xor:SI
+	   (match_operand:SI 1 "register_operand" "r,r")
+	   (match_operand:SI 2 "general_operand" "r,J")))]
+  ""
+  "@
+  l.xor\t%0, %1, %2
+  l.xori\t%0, %1, %2")
+
+(define_insn "iorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	  (ior:SI
+	   (match_operand:SI 1 "register_operand" "r,r")
+	   (match_operand:SI 2 "general_operand" "r,J")))]
+  ""
+  "@
+  l.or\t%0, %1, %2
+  l.ori\t%0, %1, %2")
+
 ;; -------------------------------------------------------------------------
 ;; Move instructions
 ;; -------------------------------------------------------------------------
-- 
2.18.0


From 83b79b28405c0a6b559a3693b241075728e319b0 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 1 May 2018 17:05:41 +0900
Subject: [PATCH 028/108] or1k: some cleanup/optimization for imm moves

---
 gcc/config/or1k/or1k.md | 36 +++++++++++++++++++++++++++++-------
 1 file changed, 29 insertions(+), 7 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 2ed0927eb5d..e319cbdba02 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -154,6 +154,18 @@
   {
     if (MEM_P (operands[0]))
       operands[1] = force_reg (<I:MODE>mode, operands[1]);
+
+    if (CONSTANT_P (operands[1]))
+      {
+	int val = INTVAL (operands[1]);
+
+	if ((val & 0xffff0000) > 0 || val == 0)
+	  emit_insn (gen_movsi_high (operands[0], GEN_INT (val & 0xffff0000)));
+	if ((val & 0xffff) > 0)
+	  emit_insn (gen_movsi_lo_sum (operands[0], operands[0],
+				       GEN_INT (val & 0xffff)));
+	DONE;
+      }
 })
 
 ;; 8-bit moves
@@ -183,17 +195,27 @@
 ;; 32-bit moves
 
 (define_insn "*movsi_internal"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=mW,r,r, r,r,r,r")
-	(match_operand:SI 1 "general_operand"       "r, r,mW,I,J,K,i"))]
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=mW,  r, r")
+	(match_operand:SI 1 "nonimmediate_operand"    "r, r,mW"))]
   "register_operand (operands[0], SImode) || register_operand (operands[1], SImode)"
   "@
    l.sw\t%0, %1
    l.or\t%0, r0, %1
-   l.lwz\t%0, %1
-   l.movhi\t%0, %1
-   l.ori\t%0, r0, %1
-   l.movhi\t%0, %1
-   l.movhi\t%0, hi(%1)\n\tl.ori\t%0, %0, lo(%1)")
+   l.lwz\t%0, %1")
+
+(define_insn "movsi_high"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (high:SI (match_operand:SI 1 "immediate_operand" "K")))]
+  ""
+  "l.movhi\t%0, hi(%1)")
+
+(define_insn "movsi_lo_sum"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (lo_sum:SI (match_operand:SI 1 "register_operand"  "r")
+                   (match_operand:SI 2 "immediate_operand" "J")))]
+  ""
+  "l.addi\t%0, %1, lo(%2)")
+
 
 ;; -------------------------------------------------------------------------
 ;; Sign Extending
-- 
2.18.0


From 0605a47a42463f52f2a85f91cb4a25b866d8b709 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Wed, 2 May 2018 07:46:43 +0900
Subject: [PATCH 029/108] or1k: WOrking on expanding moves (broke some things)

This still alows combines like:

(insn 34 33 35 2 (set (reg/f:SI 79)
        (high:SI (symbol_ref:SI ("__mulsi3") [flags 0x41])))
"../../../gcc/libgcc/libgcc2.c":552 -1
     (nil))
(insn 35 34 36 2 (set (reg/f:SI 79)
        (lo_sum:SI (reg/f:SI 79)
            (symbol_ref:SI ("__mulsi3") [flags 0x41])))
"../../../gcc/libgcc/libgcc2.c":552 -1
     (expr_list:REG_EQUAL (symbol_ref:SI ("__mulsi3") [flags 0x41])
        (nil)))

TO COMBINE TO

(insn 35 33 36 2 (set (reg/f:SI 112)
        (symbol_ref:SI ("__mulsi3") [flags 0x41]))
"../../../gcc/libgcc/libgcc2.c":552 16 {*movsi_internal}
     (expr_list:REG_EQUIV (symbol_ref:SI ("__mulsi3") [flags 0x41])
        (nil)))
---
 gcc/config/or1k/constraints.md | 18 ++++++-
 gcc/config/or1k/or1k.c         |  2 +-
 gcc/config/or1k/or1k.md        | 85 +++++++++++++++++++---------------
 3 files changed, 65 insertions(+), 40 deletions(-)

diff --git a/gcc/config/or1k/constraints.md b/gcc/config/or1k/constraints.md
index 3a48dcb2976..cf1fee93f4b 100644
--- a/gcc/config/or1k/constraints.md
+++ b/gcc/config/or1k/constraints.md
@@ -22,6 +22,14 @@
 ;; Constraints
 ;; -------------------------------------------------------------------------
 
+; We use:
+;  W - register indirect memory
+;  I - constant zero
+;  J - constant unsigned 16-bit
+;  K - constant signed 16-bit shifted left 16-bits (l.movhi)
+;  L - constant signed 26-bit (l.jal)
+;  M - constant signed 16-bit
+
 ;; Memory
 (define_constraint "W"
   "A register indirect memory operand."
@@ -36,9 +44,9 @@
        (match_test "ival == 0")))
 
 (define_constraint "J"
-  "A signed 16-bit immediate in the range -32768 to 32767."
+  "An unsigned 16-bit immediate in the range 0 to 0xffff."
   (and (match_code "const_int")
-       (match_test "IN_RANGE (ival, -32768, 32767)")))
+       (match_test "IN_RANGE (ival, 0, 65535)")))
 
 (define_constraint "K"
   "A shifted signed 16-bit constant suitable for l.movhi."
@@ -50,3 +58,9 @@
   "A signed 26-bit constant suitable for l.jal."
   (and (match_code "const_int")
        (match_test "IN_RANGE (ival, -33554432, 33554431)")))
+
+(define_constraint "M"
+  "A signed 16-bit immediate in the range -32768 to 32767."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, -32768, 32767)")))
+
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index c5aaec75044..7778cd1da18 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -288,7 +288,7 @@ or1k_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,
 {
   if (GET_CODE(x) == PLUS
       && REG_P (XEXP (x, 0))
-      && satisfies_constraint_J (XEXP (x, 1)))
+      && satisfies_constraint_M (XEXP (x, 1)))
     return true;
 
   if (REG_P (x))
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index e319cbdba02..57ecea2207b 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -49,20 +49,20 @@
 ;; -------------------------------------------------------------------------
 
 (define_insn "addsi3"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
+  [(set (match_operand:SI 0 "register_operand"   "=r, r")
 	  (plus:SI
-	   (match_operand:SI 1 "register_operand" "r,r")
-	   (match_operand:SI 2 "general_operand" "r,J")))]
+	   (match_operand:SI 1 "register_operand" "r, r")
+	   (match_operand:SI 2 "general_operand"  "r,MJ")))]
   ""
   "@
   l.add\t%0, %1, %2
   l.addi\t%0, %1, %2")
 
 (define_insn "multsi3"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
+  [(set (match_operand:SI 0 "register_operand"   "=r, r")
 	  (mult:SI
-	   (match_operand:SI 1 "register_operand" "r,r")
-	   (match_operand:SI 2 "general_operand" "r,J")))]
+	   (match_operand:SI 1 "register_operand" "r, r")
+	   (match_operand:SI 2 "general_operand"  "r,MJ")))]
   ""
   "@
   l.mul\t%0, %1, %2
@@ -103,39 +103,39 @@
                               (lshiftrt "srl") (rotate "ror")])
 
 (define_insn "<shift_op>si3"
-  [(set (match_operand:SI 0 "register_operand"          "=r,r")
-        (SHIFT:SI (match_operand:SI 1 "register_operand" "r,r")
-                  (match_operand:SI 2 "general_operand"  "r,J")))]
+  [(set (match_operand:SI 0 "register_operand"          "=r, r")
+        (SHIFT:SI (match_operand:SI 1 "register_operand" "r, r")
+                  (match_operand:SI 2 "general_operand"  "r,MJ")))]
   ""
   "@
    l.<shift_asm>\t%0, %1, %2
    l.<shift_asm>i\t%0, %1, %2")
 
 (define_insn "andsi3"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
+  [(set (match_operand:SI 0 "register_operand"   "=r, r")
 	  (and:SI
-	   (match_operand:SI 1 "register_operand" "r,r")
-	   (match_operand:SI 2 "general_operand" "r,J")))]
+	   (match_operand:SI 1 "register_operand" "r, r")
+	   (match_operand:SI 2 "general_operand"  "r,MJ")))]
   ""
   "@
   l.and\t%0, %1, %2
   l.andi\t%0, %1, %2")
 
 (define_insn "xorsi3"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
+  [(set (match_operand:SI 0 "register_operand"   "=r, r")
 	  (xor:SI
-	   (match_operand:SI 1 "register_operand" "r,r")
-	   (match_operand:SI 2 "general_operand" "r,J")))]
+	   (match_operand:SI 1 "register_operand" "r, r")
+	   (match_operand:SI 2 "general_operand"  "r,MJ")))]
   ""
   "@
   l.xor\t%0, %1, %2
   l.xori\t%0, %1, %2")
 
 (define_insn "iorsi3"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
+  [(set (match_operand:SI 0 "register_operand"   "=r, r")
 	  (ior:SI
-	   (match_operand:SI 1 "register_operand" "r,r")
-	   (match_operand:SI 2 "general_operand" "r,J")))]
+	   (match_operand:SI 1 "register_operand" "r, r")
+	   (match_operand:SI 2 "general_operand"  "r,MJ")))]
   ""
   "@
   l.or\t%0, %1, %2
@@ -155,24 +155,34 @@
     if (MEM_P (operands[0]))
       operands[1] = force_reg (<I:MODE>mode, operands[1]);
 
-    if (CONSTANT_P (operands[1]))
+    if (LABEL_P (operands[1]) || SYMBOL_REF_P (operands[1]))
       {
-	int val = INTVAL (operands[1]);
-
-	if ((val & 0xffff0000) > 0 || val == 0)
-	  emit_insn (gen_movsi_high (operands[0], GEN_INT (val & 0xffff0000)));
-	if ((val & 0xffff) > 0)
-	  emit_insn (gen_movsi_lo_sum (operands[0], operands[0],
-				       GEN_INT (val & 0xffff)));
+	emit_insn (gen_movsi_high (operands[0], operands[1]));
+	emit_insn (gen_movsi_lo_sum (operands[0], operands[0], operands[1]));
 	DONE;
       }
+
+    if (CONSTANT_P (operands[1]))
+      {
+	/* If its not a 16-bit constant expand.  */
+	if (!(satisfies_constraint_J (operands[1])
+	      || satisfies_constraint_M (operands[1])))
+	  {
+	    int val = INTVAL (operands[1]);
+
+	    emit_insn (gen_movsi_high (operands[0], GEN_INT (val & ~0xffff)));
+	    emit_insn (gen_addsi3 (operands[0], operands[0],
+				   GEN_INT (val & 0xffff)));
+	    DONE;
+	  }
+      }
 })
 
 ;; 8-bit moves
 
 (define_insn "*movqi_internal"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,mW, r")
-	(match_operand:QI 1 "general_operand"       "r,J,r ,mW"))]
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=r, r,mW, r")
+	(match_operand:QI 1 "general_operand"       "r,MJ,r ,mW"))]
   "register_operand (operands[0], QImode) || register_operand (operands[1], QImode)"
   "@
    l.or\t%0, r0, %1
@@ -183,8 +193,8 @@
 ;; 16-bit moves
 
 (define_insn "*movhi_internal"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,mW, r")
-	(match_operand:HI 1 "general_operand"       "r,J,r ,mW"))]
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=r, r,mW, r")
+	(match_operand:HI 1 "general_operand"       "r,MJ,r ,mW"))]
   "register_operand (operands[0], HImode) || register_operand (operands[1], HImode)"
   "@
    l.or\t%0, r0, %1
@@ -195,24 +205,25 @@
 ;; 32-bit moves
 
 (define_insn "*movsi_internal"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=mW,  r, r")
-	(match_operand:SI 1 "nonimmediate_operand"    "r, r,mW"))]
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r, r,mW, r")
+	(match_operand:SI 1 "general_operand"       "r,MJ,r ,mW"))]
   "register_operand (operands[0], SImode) || register_operand (operands[1], SImode)"
   "@
-   l.sw\t%0, %1
    l.or\t%0, r0, %1
+   l.ori\t%0, r0, %1
+   l.sw\t%0, %1
    l.lwz\t%0, %1")
 
 (define_insn "movsi_high"
   [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (match_operand:SI 1 "immediate_operand" "K")))]
+        (high:SI (match_operand:SI 1 "general_operand" "i")))]
   ""
   "l.movhi\t%0, hi(%1)")
 
 (define_insn "movsi_lo_sum"
   [(set (match_operand:SI 0 "register_operand" "=r")
         (lo_sum:SI (match_operand:SI 1 "register_operand"  "r")
-                   (match_operand:SI 2 "immediate_operand" "J")))]
+                   (match_operand:SI 2 "general_operand" "i")))]
   ""
   "l.addi\t%0, %1, lo(%2)")
 
@@ -280,8 +291,8 @@
 
 (define_insn "*sf<intcmpcc:code>_insn"
   [(set (reg:CC CC_REGNUM)
-	(intcmpcc (match_operand:I 0 "register_operand" "r,r")
-	      (match_operand:I 1 "general_operand" "r,J")))]
+	(intcmpcc (match_operand:I 0 "register_operand" "r, r")
+	      (match_operand:I 1 "general_operand"      "r,MJ")))]
   ""
   "@
    l.sf<insn>\t%0, %1
-- 
2.18.0


From 8e4c133299bb8406185e680354e037624c62d302 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Wed, 2 May 2018 21:43:38 +0900
Subject: [PATCH 030/108] or1k: move cleanups, fix predicates issue.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Failing on:

during RTL pass: reload
In file included from ../../../gcc/libgcc/unwind-dw2.c:35:
../../../gcc/libgcc/unwind-pe.h: In function
read_encoded_value_with_base:
../../../gcc/libgcc/unwind-pe.h:271:1: internal compiler error: in
lra_constraints, at lra-constraints.c:4703
---
 gcc/config/or1k/or1k.md       | 45 +++++++++++------------------------
 gcc/config/or1k/predicates.md |  6 +++++
 2 files changed, 20 insertions(+), 31 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 57ecea2207b..ddafebe2c68 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -147,6 +147,8 @@
 
 (define_mode_iterator I [QI HI SI])
 
+(define_mode_attr losto [(QI "b") (HI "h") (SI "w")])
+
 (define_expand "mov<I:mode>"
   [(set (match_operand:I 0 "nonimmediate_operand" "")
 	(match_operand:I 1 "general_operand" ""))]
@@ -155,6 +157,7 @@
     if (MEM_P (operands[0]))
       operands[1] = force_reg (<I:MODE>mode, operands[1]);
 
+    /* Load labels as hi/lo sums.  */
     if (LABEL_P (operands[1]) || SYMBOL_REF_P (operands[1]))
       {
 	emit_insn (gen_movsi_high (operands[0], operands[1]));
@@ -162,6 +165,7 @@
 	DONE;
       }
 
+    /* Load constants as hi/lo sums, which can be optimized out if 0.  */
     if (CONSTANT_P (operands[1]))
       {
 	/* If its not a 16-bit constant expand.  */
@@ -178,41 +182,20 @@
       }
 })
 
-;; 8-bit moves
-
-(define_insn "*movqi_internal"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=r, r,mW, r")
-	(match_operand:QI 1 "general_operand"       "r,MJ,r ,mW"))]
-  "register_operand (operands[0], QImode) || register_operand (operands[1], QImode)"
-  "@
-   l.or\t%0, r0, %1
-   l.ori\t%0, r0, %1
-   l.sb\t%0, %1
-   l.lbz\t%0, %1")
-
-;; 16-bit moves
+;; 8-bit, 16-bit and 32-bit moves
 
-(define_insn "*movhi_internal"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=r, r,mW, r")
-	(match_operand:HI 1 "general_operand"       "r,MJ,r ,mW"))]
-  "register_operand (operands[0], HImode) || register_operand (operands[1], HImode)"
+(define_insn "*mov<I:mode>_internal"
+  [(set (match_operand:I 0 "nonimmediate_operand" "=r, r,mW, r")
+	(match_operand:I 1 "or1k_mov_operand"       "r,MJ, r,mW"))]
+  "register_operand (operands[0], <I:MODE>mode)
+   || register_operand (operands[1], <I:MODE>mode)"
   "@
    l.or\t%0, r0, %1
    l.ori\t%0, r0, %1
-   l.sh\t%0, %1
-   l.lhz\t%0, %1")
-
-;; 32-bit moves
+   l.s<I:losto>\t%0, %1
+   l.l<I:losto>z\t%0, %1")
 
-(define_insn "*movsi_internal"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=r, r,mW, r")
-	(match_operand:SI 1 "general_operand"       "r,MJ,r ,mW"))]
-  "register_operand (operands[0], SImode) || register_operand (operands[1], SImode)"
-  "@
-   l.or\t%0, r0, %1
-   l.ori\t%0, r0, %1
-   l.sw\t%0, %1
-   l.lwz\t%0, %1")
+;; Hi/Low moves for constant and symbol loading
 
 (define_insn "movsi_high"
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -292,7 +275,7 @@
 (define_insn "*sf<intcmpcc:code>_insn"
   [(set (reg:CC CC_REGNUM)
 	(intcmpcc (match_operand:I 0 "register_operand" "r, r")
-	      (match_operand:I 1 "general_operand"      "r,MJ")))]
+	             (match_operand:I 1 "general_operand"      "r,MJ")))]
   ""
   "@
    l.sf<insn>\t%0, %1
diff --git a/gcc/config/or1k/predicates.md b/gcc/config/or1k/predicates.md
index fd537bea3e9..fae9d96ccaf 100644
--- a/gcc/config/or1k/predicates.md
+++ b/gcc/config/or1k/predicates.md
@@ -22,4 +22,10 @@
 ;; Predicates
 ;; -------------------------------------------------------------------------
 
+(define_predicate "or1k_mov_operand"
+  (and (match_code "reg,subreg,mem,const,const_int,const_poly_int")
+       (ior (match_operand 0 "register_operand")
+	    (ior (match_operand 0 "memory_operand")
+		 (match_operand 0 "const_int_operand")))))
+
 
-- 
2.18.0


From 41075be0a7da0a2b60a81a5feda994a73d6b42b5 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Thu, 3 May 2018 11:16:51 +0900
Subject: [PATCH 031/108] or1k: some whitespace cleanups

---
 gcc/config/or1k/or1k.md | 23 +++++++++++------------
 1 file changed, 11 insertions(+), 12 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index ddafebe2c68..3ac8ffb17ac 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -98,14 +98,14 @@
 
 (define_code_iterator SHIFT  [ashift ashiftrt lshiftrt rotate])
 (define_code_attr shift_op   [(ashift "ashl") (ashiftrt "ashr")
-                              (lshiftrt "lshr") (rotate "rotl")])
+			      (lshiftrt "lshr") (rotate "rotl")])
 (define_code_attr shift_asm  [(ashift "sll") (ashiftrt "sra")
-                              (lshiftrt "srl") (rotate "ror")])
+			      (lshiftrt "srl") (rotate "ror")])
 
 (define_insn "<shift_op>si3"
   [(set (match_operand:SI 0 "register_operand"          "=r, r")
-        (SHIFT:SI (match_operand:SI 1 "register_operand" "r, r")
-                  (match_operand:SI 2 "general_operand"  "r,MJ")))]
+	(SHIFT:SI (match_operand:SI 1 "register_operand" "r, r")
+		  (match_operand:SI 2 "general_operand"  "r,MJ")))]
   ""
   "@
    l.<shift_asm>\t%0, %1, %2
@@ -186,7 +186,7 @@
 
 (define_insn "*mov<I:mode>_internal"
   [(set (match_operand:I 0 "nonimmediate_operand" "=r, r,mW, r")
-	(match_operand:I 1 "or1k_mov_operand"       "r,MJ, r,mW"))]
+	(match_operand:I 1 "or1k_mov_operand"      "r,MJ, r,mW"))]
   "register_operand (operands[0], <I:MODE>mode)
    || register_operand (operands[1], <I:MODE>mode)"
   "@
@@ -199,14 +199,14 @@
 
 (define_insn "movsi_high"
   [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (match_operand:SI 1 "general_operand" "i")))]
+	(high:SI (match_operand:SI 1 "general_operand" "i")))]
   ""
   "l.movhi\t%0, hi(%1)")
 
 (define_insn "movsi_lo_sum"
   [(set (match_operand:SI 0 "register_operand" "=r")
-        (lo_sum:SI (match_operand:SI 1 "register_operand"  "r")
-                   (match_operand:SI 2 "general_operand" "i")))]
+	(lo_sum:SI (match_operand:SI 1 "register_operand"  "r")
+		   (match_operand:SI 2 "general_operand" "i")))]
   ""
   "l.addi\t%0, %1, lo(%2)")
 
@@ -217,7 +217,7 @@
 
 (define_insn "zero_extendhisi2"
   [(set (match_operand:SI 0 "register_operand"                    "=r,r")
-        (zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
+	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
   ""
   "@
    l.exthz\t%0, %1
@@ -225,7 +225,7 @@
 
 (define_insn "zero_extendqisi2"
   [(set (match_operand:SI 0 "register_operand"                    "=r,r")
-        (zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "r,m")))]
+	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "r,m")))]
   ""
   "@
    l.extbz\t%0, %1
@@ -373,8 +373,7 @@
   [(parallel [(set (match_operand 0 "" "")
 		   (call (match_operand 1 "" "")
 		   (match_operand 2 "" "")))
-	      (clobber (reg:SI LR_REGNUM))
-             ])]
+	      (clobber (reg:SI LR_REGNUM))])]
   ""
   "
 {
-- 
2.18.0


From 4a00a33c45f59abf6144dd8b0e2605eb402f481c Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Thu, 3 May 2018 13:34:09 +0900
Subject: [PATCH 032/108] or1k: fix subregs of memory by adding scheduling
 (also add delay slot)

Recommended by segher in #gcc, it fixed the issue, but now has issue
with SF subregs.
---
 gcc/config/or1k/or1k.md | 55 ++++++++++++++++++++++++++++++++---------
 1 file changed, 44 insertions(+), 11 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 3ac8ffb17ac..fda50a4fa07 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -19,7 +19,7 @@
 ;; <http://www.gnu.org/licenses/>.
 
 ;; -------------------------------------------------------------------------
-;; Moxie specific constraints, predicates and attributes
+;; OpenRISC specific constraints, predicates and attributes
 ;; -------------------------------------------------------------------------
 
 (include "constraints.md")
@@ -32,9 +32,34 @@
    (CC_REGNUM      33)]
 )
 
+;; Instruction scheduler
+
 ; Most instructions are 4 bytes long.
 (define_attr "length" "" (const_int 4))
 
+(define_attr "type"
+  "alu,st,ld,control"
+  (const_string "alu"))
+
+(define_automaton "or1k")
+(define_cpu_unit "cpu" "or1k")
+(define_insn_reservation "alu" 1
+  (eq_attr "type" "alu")
+  "cpu")
+(define_insn_reservation "st" 1
+  (eq_attr "type" "st")
+  "cpu")
+(define_insn_reservation "ld" 3
+  (eq_attr "type" "st")
+  "cpu")
+(define_insn_reservation "control" 1
+  (eq_attr "type" "control")
+  "cpu")
+
+; Define delay slots for any branch
+(define_delay (eq_attr "type" "control")
+  [(eq_attr "type" "!control") (nil) (nil)])
+
 ;; -------------------------------------------------------------------------
 ;; nop instruction
 ;; -------------------------------------------------------------------------
@@ -193,7 +218,8 @@
    l.or\t%0, r0, %1
    l.ori\t%0, r0, %1
    l.s<I:losto>\t%0, %1
-   l.l<I:losto>z\t%0, %1")
+   l.l<I:losto>z\t%0, %1"
+  [(set_attr "type" "alu,alu,ld,st")])
 
 ;; Hi/Low moves for constant and symbol loading
 
@@ -201,14 +227,16 @@
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(high:SI (match_operand:SI 1 "general_operand" "i")))]
   ""
-  "l.movhi\t%0, hi(%1)")
+  "l.movhi\t%0, hi(%1)"
+  [(set_attr "type" "alu")])
 
 (define_insn "movsi_lo_sum"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(lo_sum:SI (match_operand:SI 1 "register_operand"  "r")
 		   (match_operand:SI 2 "general_operand" "i")))]
   ""
-  "l.addi\t%0, %1, lo(%2)")
+  "l.addi\t%0, %1, lo(%2)"
+  [(set_attr "type" "alu")])
 
 
 ;; -------------------------------------------------------------------------
@@ -318,7 +346,8 @@
 		      (label_ref (match_operand 0 "" ""))
 		      (pc)))]
   ""
-  "l.bf\t%0")
+  "l.bf\t%0"
+  [(set_attr "type" "control")])
 
 
 (define_expand "cbranchsi4"
@@ -339,12 +368,14 @@
 (define_insn "jump"
   [(set (pc) (label_ref (match_operand 0 "" "")))]
   ""
-  "l.j\t%0")
+  "l.j\t%0"
+  [(set_attr "type" "control")])
 
 (define_insn "indirect_jump"
   [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
   ""
-  "l.jr\t%0")
+  "l.jr\t%0"
+  [(set_attr "type" "control")])
 
 (define_expand "call"
   [(parallel [(call (match_operand 0 "" "")
@@ -366,7 +397,8 @@
   ""
   "@
    l.jalr\t%0
-   l.jal\t%0")
+   l.jal\t%0"
+  [(set_attr "type" "control")])
 
 ;; Call with a retun value
 (define_expand "call_value"
@@ -390,7 +422,8 @@
   ""
   "@
    l.jalr\t%1
-   l.jal\t%1")
+   l.jal\t%1"
+  [(set_attr "type" "control")])
 
 ;; -------------------------------------------------------------------------
 ;; Prologue & Epilogue
@@ -418,5 +451,5 @@
   [(use (match_operand:SI 0 "register_operand" "r"))
    (return)]
   ""
-  "l.jr\t%0")
-
+  "l.jr\t%0"
+  [(set_attr "type" "control")])
-- 
2.18.0


From d95ccf35697cf40ee0b6ad4cd2d7c87d4bc5ce08 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Thu, 3 May 2018 15:26:12 +0900
Subject: [PATCH 033/108] or1k: implement eh_return to allow unwinders to build

---
 gcc/config/or1k/or1k-protos.h |  2 +-
 gcc/config/or1k/or1k.c        |  8 ++++++++
 gcc/config/or1k/or1k.h        |  2 --
 gcc/config/or1k/or1k.md       | 16 ++++++++++++----
 4 files changed, 21 insertions(+), 7 deletions(-)

diff --git a/gcc/config/or1k/or1k-protos.h b/gcc/config/or1k/or1k-protos.h
index 14963cc791d..3bbef7d720e 100644
--- a/gcc/config/or1k/or1k-protos.h
+++ b/gcc/config/or1k/or1k-protos.h
@@ -21,4 +21,4 @@ extern bool or1k_legitimate_address_p (machine_mode, rtx, bool);
 extern int  or1k_initial_elimination_offset (int, int);
 extern void or1k_expand_prologue (void);
 extern void or1k_expand_epilogue (void);
-
+extern void or1k_expand_eh_return (rtx);
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 7778cd1da18..f8eeb02229e 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -258,6 +258,14 @@ or1k_expand_epilogue (void)
   emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, LR_REGNUM)));
 }
 
+/* TODO, do we need to just set to r9? or should we put it to where r9
+ * is stored on the stack?  */
+void
+or1k_expand_eh_return (rtx eh_addr)
+{
+  emit_move_insn (gen_rtx_REG (Pmode, LR_REGNUM), eh_addr);
+}
+
 int
 or1k_initial_elimination_offset (int from, int to)
 {
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 821ae9e509a..3a17b93dd66 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -230,8 +230,6 @@ do {                                                    \
 #define STACK_POINTER_REGNUM SP_REGNUM
 #define FRAME_POINTER_REGNUM FP_REGNUM
 
-#define HARD_FRAME_POINTER_REGNUM FP_REGNUM
-
 /* The register number of the arg pointer register, which is used to
    access the function's argument list.  */
 #define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index fda50a4fa07..e2ea2d41998 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -172,7 +172,7 @@
 
 (define_mode_iterator I [QI HI SI])
 
-(define_mode_attr losto [(QI "b") (HI "h") (SI "w")])
+(define_mode_attr ldst [(QI "b") (HI "h") (SI "w")])
 
 (define_expand "mov<I:mode>"
   [(set (match_operand:I 0 "nonimmediate_operand" "")
@@ -217,9 +217,9 @@
   "@
    l.or\t%0, r0, %1
    l.ori\t%0, r0, %1
-   l.s<I:losto>\t%0, %1
-   l.l<I:losto>z\t%0, %1"
-  [(set_attr "type" "alu,alu,ld,st")])
+   l.s<I:ldst>\t%0, %1
+   l.l<I:ldst>z\t%0, %1"
+  [(set_attr "type" "alu,alu,st,ld")])
 
 ;; Hi/Low moves for constant and symbol loading
 
@@ -453,3 +453,11 @@
   ""
   "l.jr\t%0"
   [(set_attr "type" "control")])
+
+(define_expand "eh_return"
+  [(use (match_operand 0 "general_operand"))]
+  ""
+{
+  or1k_expand_eh_return (operands[0]);
+  DONE;
+})
-- 
2.18.0


From 2e65650e8edf07add4a29527ef5efc2975f0c23e Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Thu, 3 May 2018 17:31:07 +0900
Subject: [PATCH 034/108] or1k: implement delay slot filling with nop

---
 README.md               | 10 ++++------
 gcc/config/or1k/or1k.c  | 19 +++++++++++++------
 gcc/config/or1k/or1k.h  |  2 ++
 gcc/config/or1k/or1k.md | 16 ++++++++--------
 4 files changed, 27 insertions(+), 20 deletions(-)

diff --git a/README.md b/README.md
index 0c9b6a626e4..1f6e12b089c 100644
--- a/README.md
+++ b/README.md
@@ -17,12 +17,12 @@ These items should be done to get to a point where very basic things compile.
 - branches - DONE
 - tuning
   - ensure varargs are to spec
-  - ensure we can return 64-bit values in r11 and r12
+  - ensure we can return 64-bit values in r11 and r12 - DONE (OOTB)
   - proper support for returning small structs/vectors in regs
   - optional support for frame pointers
-  - delay slot
+  - delay slot - DONE
   - optional support for delay slot
-  - correct predicates and constraints
+  - correct predicates and constraints - OK
 
 ## building
 
@@ -31,12 +31,10 @@ These items should be done to get to a point where very basic things compile.
 ```
 mkdir build
 cd build
-../gcc/configure --target=or1k-elf --disable-shared --enable-stage1-languages=c --prefix=/home/shorne/work/gnu-toolchain/local
+../gcc/configure --target=or1k-elf --disable-shared --enable-languages=c --prefix=/home/shorne/work/gnu-toolchain/local
 make -j5 all-gcc
 make install-gcc
 
-# Currently the entire build will not complete, but gcc will work, you can then
-# test gcc using one of the below tests
 ../local/bin/or1k-elf-gcc -S ../gcc/test2.c -fdump-rtl-all
 
 ```
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index f8eeb02229e..24f04825243 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -432,14 +432,21 @@ or1k_print_operand (FILE *file, rtx x, int code)
 {
   rtx operand = x;
 
-  switch (code)
+  if (PRINT_OPERAND_PUNCT_VALID_P (code))
     {
-    case 0:
-      /* No code, print as usual.  */
-      break;
+      switch (code)
+	{
+	case '#':
+	  /* Conditionally add a nop in unfilled delay slot.  */
+	  if (final_sequence == NULL)
+	    fputs ("\n\t l.nop\n", file);
+	  break;
 
-    default:
-      internal_error ("invalid operand modifier letter: %d", code);
+	default:
+	  output_operand_lossage ("unknown operand letter: '%c'", code);
+	  break;
+	}
+      return;
     }
 
   /* Print an operand as without a modifier letter.  */
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 3a17b93dd66..ff0db326360 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -214,6 +214,8 @@ do {                                                    \
     }							\
   while (0)
 
+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) (code == '#')
+
 /* Calling convention definitions.  */
 #define CUMULATIVE_ARGS int
 #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index e2ea2d41998..7c35596028f 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -346,7 +346,7 @@
 		      (label_ref (match_operand 0 "" ""))
 		      (pc)))]
   ""
-  "l.bf\t%0"
+  "l.bf\t%0%#"
   [(set_attr "type" "control")])
 
 
@@ -368,13 +368,13 @@
 (define_insn "jump"
   [(set (pc) (label_ref (match_operand 0 "" "")))]
   ""
-  "l.j\t%0"
+  "l.j\t%0%#"
   [(set_attr "type" "control")])
 
 (define_insn "indirect_jump"
   [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
   ""
-  "l.jr\t%0"
+  "l.jr\t%0%#"
   [(set_attr "type" "control")])
 
 (define_expand "call"
@@ -396,8 +396,8 @@
    (clobber (reg:SI LR_REGNUM))]
   ""
   "@
-   l.jalr\t%0
-   l.jal\t%0"
+   l.jalr\t%0%#
+   l.jal\t%0%#"
   [(set_attr "type" "control")])
 
 ;; Call with a retun value
@@ -421,8 +421,8 @@
    (clobber (reg:SI LR_REGNUM))]
   ""
   "@
-   l.jalr\t%1
-   l.jal\t%1"
+   l.jalr\t%1%#
+   l.jal\t%1%#"
   [(set_attr "type" "control")])
 
 ;; -------------------------------------------------------------------------
@@ -451,7 +451,7 @@
   [(use (match_operand:SI 0 "register_operand" "r"))
    (return)]
   ""
-  "l.jr\t%0"
+  "l.jr\t%0%#"
   [(set_attr "type" "control")])
 
 (define_expand "eh_return"
-- 
2.18.0


From 9ed81310a4780de2ffd11bbc702e2e55227f3870 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Thu, 3 May 2018 18:36:35 +0900
Subject: [PATCH 035/108] or1k: make hard_fp != fp to fix subreg issue

---
 gcc/config/or1k/or1k.c | 21 +++++++++++++++------
 gcc/config/or1k/or1k.h | 28 ++++++++++++++++------------
 2 files changed, 31 insertions(+), 18 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 24f04825243..1c25f1dd917 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -196,8 +196,8 @@ or1k_expand_prologue (void)
   if (frame_pointer_needed)
     {
       gcc_assert (offset == -8);
-      or1k_save_restore_reg (FP_REGNUM, offset, true);
-      emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);
+      or1k_save_restore_reg (HARD_FRAME_POINTER_REGNUM, offset, true);
+      emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);
       offset += 4;
     }
 
@@ -247,7 +247,7 @@ or1k_expand_epilogue (void)
   if (frame_pointer_needed)
     {
       gcc_assert (offset == -8);
-      or1k_save_restore_reg (FP_REGNUM, offset, false);
+      or1k_save_restore_reg (HARD_FRAME_POINTER_REGNUM, offset, false);
       offset += 4;
     }
 
@@ -259,13 +259,19 @@ or1k_expand_epilogue (void)
 }
 
 /* TODO, do we need to just set to r9? or should we put it to where r9
- * is stored on the stack?  */
+   is stored on the stack?  */
 void
 or1k_expand_eh_return (rtx eh_addr)
 {
   emit_move_insn (gen_rtx_REG (Pmode, LR_REGNUM), eh_addr);
 }
 
+/* We allow the following eliminiations:
+    FP -> HARD_FP or SP
+    AP -> HARD_FP or SP
+
+  FP and AP are the same so.
+ */
 int
 or1k_initial_elimination_offset (int from, int to)
 {
@@ -274,16 +280,19 @@ or1k_initial_elimination_offset (int from, int to)
   /* Set OFFSET to the offset from the stack pointer.  */
   switch (from)
     {
+    case ARG_POINTER_REGNUM:
     case FRAME_POINTER_REGNUM:
-      /* This is the high end of the local variable storage, not the
-	 hard frame pointer.  */
       offset = cfun->machine->total_size;
       break;
 
+
     default:
       gcc_unreachable ();
     }
 
+  if (to == HARD_FRAME_POINTER_REGNUM)
+    offset = 0;
+
   return offset;
 
 }
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index ff0db326360..dda816913f9 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -113,28 +113,28 @@
 
 #define ZERO_REGNUM   0
 #define SP_REGNUM   1
-#define FP_REGNUM   2
 #define LR_REGNUM   9
 #define TLS_REGNUM  10
 #define RV_REGNUM   11
 #define RVH_REGNUM  12
 #define AP_REGNUM   32
 #define CC_REGNUM   33
-#define FIRST_PSEUDO_REGISTER  34
+#define FP_REGNUM   34
+#define FIRST_PSEUDO_REGISTER  35
 
 #define FIXED_REGISTERS   \
 { 1, 1, 0, 0, 0, 0, 0, 0, \
   0, 0, 1, 0, 0, 0, 0, 0, \
   0, 0, 0, 0, 0, 0, 0, 0, \
   0, 0, 0, 0, 0, 0, 0, 0, \
-  1, 1}
+  1, 1, 1}
 
 #define CALL_USED_REGISTERS \
 { 1, 1, 0, 0, 0, 0, 0, 0, \
   0, 1, 1, 1, 0, 0, 0, 0, \
   0, 0, 0, 0, 0, 0, 0, 0, \
   0, 0, 0, 0, 0, 0, 0, 0, \
-  1, 1}
+  1, 1, 1}
 
 enum reg_class
 {
@@ -156,8 +156,8 @@ enum reg_class
 #define REG_CLASS_CONTENTS      \
 { {0x00000000, 0x00000000},	\
   {0xffffffff, 0x00000000},	\
-  {0x00000000, 0x00000003},	\
-  {0xffffffff, 0x00000003}	\
+  {0x00000000, 0x00000007},	\
+  {0xffffffff, 0x00000007}	\
 }
 
 /* A C expression whose value is a register class containing hard
@@ -165,9 +165,10 @@ enum reg_class
    choose a class which is "minimal", meaning that no smaller class
    also contains the register.  */
 #define REGNO_REG_CLASS(REGNO) \
-  ((REGNO >= FIRST_PSEUDO_REGISTER || REGNO < 0) ? NO_REGS :	\
-   (REGNO == AP_REGNUM || 					\
-    REGNO == CC_REGNUM ? SPECIAL_REGS : GENERAL_REGS))
+  ((REGNO >= FIRST_PSEUDO_REGISTER ) ? NO_REGS :		\
+   (REGNO == AP_REGNUM						\
+    || REGNO == CC_REGNUM					\
+    || REGNO == FP_REGNUM ? SPECIAL_REGS : GENERAL_REGS))
 
 #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)               \
 do {                                                    \
@@ -201,7 +202,7 @@ do {                                                    \
   "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",	\
   "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",	\
   "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",	\
-  "?ap",  "?cc" }
+  "?ap",  "?cc",  "?fp" }
 
 /* This is how to output an assembler line
    that says to advance the location counter
@@ -231,10 +232,11 @@ do {                                                    \
 #define FUNCTION_MODE	SImode
 #define STACK_POINTER_REGNUM SP_REGNUM
 #define FRAME_POINTER_REGNUM FP_REGNUM
+#define HARD_FRAME_POINTER_REGNUM 2
 
 /* The register number of the arg pointer register, which is used to
    access the function's argument list.  */
-#define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM
+#define ARG_POINTER_REGNUM AP_REGNUM
 
 /* A C expression that is nonzero if REGNO is the number of a hard
    register in which function arguments are sometimes passed.  */
@@ -249,7 +251,9 @@ do {                                                    \
 
 #define ELIMINABLE_REGS					\
 {{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },	\
- { ARG_POINTER_REGNUM,	 STACK_POINTER_REGNUM }}
+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM },	\
+ { ARG_POINTER_REGNUM,	 STACK_POINTER_REGNUM },	\
+ { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM }}
 
 #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
   do {							\
-- 
2.18.0


From 7e6bced413e9214ee2b94430c436d7f583cbe5ea Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Fri, 4 May 2018 06:52:41 +0900
Subject: [PATCH 036/108] or1k: add basic linux/rtems support

---
 gcc/config.gcc | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/gcc/config.gcc b/gcc/config.gcc
index 3800383690b..9b581206f88 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -2377,11 +2377,22 @@ nvptx-*)
 		tm_file="${tm_file} nvptx/offload.h"
 	fi
 	;;
-or1k*-*-elf)
-	gas=yes
-	gnu_ld=yes
-	tm_file="dbxelf.h elfos.h newlib-stdint.h ${tm_file}"
+or1k*-*-*)
+	tm_file="elfos.h ${tm_file}"
 	tmake_file="${tmake_file} or1k/t-or1k"
+        case ${target} in
+        or1k*-*-linux*)
+                tm_file="${tm_file} gnu-user.h linux.h glibc-stdint.h"
+                ;;
+	or1k*-*-elf*)
+		tm_file="${tm_file} newlib-stdint.h"
+		extra_options="${extra_options}"
+		;;
+	or1k*-*-rtems*)
+		tm_file="${tm_file} newlib-stdint.h rtems.h"
+		tmake_file="${tmake_file} t-rtems"
+		;;
+	esac
 	;;
 pdp11-*-*)
 	tm_file="${tm_file} newlib-stdint.h"
-- 
2.18.0


From 693fa0ec4fcb573a9b0849b55f0669d31833517e Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Sun, 6 May 2018 09:04:20 +0900
Subject: [PATCH 037/108] or1k: add _init, _fini, fix name of mulsi3 and add
 one_complsi2

This now has enough for linking a simple hellow world but I have to do
it manually until I fix up _SPECS definitions.

THis is what I used, probably can remove some duplicates but this was
it..

or1k-elf-ld hello.o \
/home/shorne/work/gnu-toolchain/local/lib/gcc/or1k-elf/9.0.0/crti.o \
/home/shorne/work/gnu-toolchain/local/lib/gcc/or1k-elf/9.0.0/crtbegin.o \
/home/shorne/work/gnu-toolchain/local/lib/gcc/or1k-elf/9.0.0/crtend.o \
/home/shorne/work/gnu-toolchain/local/lib/gcc/or1k-elf/9.0.0/crtn.o  -lc \
-L/home/shorne/work/gnu-toolchain/local/or1k-elf/lib \
/home/shorne/work/gnu-toolchain/local/or1k-elf/lib/crt0.o \
-lboard-or1ksim -lgcc \
-L/home/shorne/work/gnu-toolchain/local/lib/gcc/or1k-elf/9.0.0 -lor1k \
-lc -lgcc
---
 gcc/config/or1k/or1k.h    |  2 +-
 gcc/config/or1k/or1k.md   | 10 +++++++++-
 libgcc/config.host        |  1 +
 libgcc/config/or1k/crti.S | 37 +++++++++++++++++++++++++++++++++++++
 libgcc/config/or1k/crtn.S | 33 +++++++++++++++++++++++++++++++++
 5 files changed, 81 insertions(+), 2 deletions(-)
 create mode 100644 libgcc/config/or1k/crti.S
 create mode 100644 libgcc/config/or1k/crtn.S

diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index dda816913f9..70cda935ee9 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -22,11 +22,11 @@
 #define GCC_OR1K_H
 
 /* Names to predefine in the preprocessor for this target machine.  */
-/* __M32R__ is defined by the existing compiler so we use that.  */
 #define TARGET_CPU_CPP_BUILTINS()		\
   do						\
     {						\
       builtin_define ("__OR1K__");		\
+      builtin_define ("__OR1K_DELAY__");	\
       builtin_define ("__or1k__");		\
       builtin_assert ("cpu=or1k");		\
       builtin_assert ("machine=or1k");		\
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 7c35596028f..c6f5689b78f 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -83,7 +83,7 @@
   l.add\t%0, %1, %2
   l.addi\t%0, %1, %2")
 
-(define_insn "multsi3"
+(define_insn "mulsi3"
   [(set (match_operand:SI 0 "register_operand"   "=r, r")
 	  (mult:SI
 	   (match_operand:SI 1 "register_operand" "r, r")
@@ -166,6 +166,14 @@
   l.or\t%0, %1, %2
   l.ori\t%0, %1, %2")
 
+(define_expand "one_cmplsi2"
+  [(set (match_operand:SI 0 "register_operand" "") (high:SI (const_int -65536)))
+   (set (match_dup 0) (plus:SI (match_dup 0) (const_int 65535)))
+   (set (match_dup 0) (xor:SI (match_dup 0)
+			      (match_operand:SI 1 "register_operand" "")))]
+  ""
+  "")
+
 ;; -------------------------------------------------------------------------
 ;; Move instructions
 ;; -------------------------------------------------------------------------
diff --git a/libgcc/config.host b/libgcc/config.host
index f98c7ae9fb1..5b2fca5ce6b 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -1010,6 +1010,7 @@ nios2-*-*)
 	;;
 or1k-*-*)
 	tmake_file="$tmake_file or1k/t-or1k"
+	extra_parts="$extra_parts crti.o crtn.o"
 	;;
 pdp11-*-*)
 	tmake_file="pdp11/t-pdp11 t-fdpbit"
diff --git a/libgcc/config/or1k/crti.S b/libgcc/config/or1k/crti.S
new file mode 100644
index 00000000000..c1369396bc9
--- /dev/null
+++ b/libgcc/config/or1k/crti.S
@@ -0,0 +1,37 @@
+/* Copyright (C) 2012-2018 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3, or (at your option) any
+later version.
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+	.section .init
+	.align 4
+	.global	_init
+	.type	_init,@function
+_init:
+	l.sw	-4(r1), r9
+	l.addi	r1,r1,-4
+
+	.section .fini
+	.align	4
+	.global	_fini
+	.type	_fini,@function
+_fini:
+	l.sw	-4(r1), r9
+	l.addi	r1,r1,-4
+
diff --git a/libgcc/config/or1k/crtn.S b/libgcc/config/or1k/crtn.S
new file mode 100644
index 00000000000..6f77c83cb53
--- /dev/null
+++ b/libgcc/config/or1k/crtn.S
@@ -0,0 +1,33 @@
+/* Copyright (C) 2012-2018 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3, or (at your option) any
+later version.
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+
+	.section .init
+	l.addi	r1, r1, 4
+	l.lwz	r9, -4(r1)
+	l.jr	r9
+	 l.nop
+
+	.section .fini
+	l.addi	r1, r1, 4
+	l.lwz	r9, -4(r1)
+	l.jr	r9
+	 l.nop
-- 
2.18.0


From 6c983b42dec8d3a57f93fb4ec7ed4c96b318aebc Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Sun, 6 May 2018 23:08:36 +0900
Subject: [PATCH 038/108] or1k: get linker working

---
 gcc/config.gcc           |  4 ++--
 gcc/config/or1k/elf.h    | 37 +++++++++++++++++++++++++++++++++++++
 gcc/config/or1k/elf.opt  | 33 +++++++++++++++++++++++++++++++++
 gcc/config/or1k/or1k.opt |  8 --------
 4 files changed, 72 insertions(+), 10 deletions(-)
 create mode 100644 gcc/config/or1k/elf.h
 create mode 100644 gcc/config/or1k/elf.opt

diff --git a/gcc/config.gcc b/gcc/config.gcc
index 9b581206f88..cc7bbbc6cd6 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -2385,8 +2385,8 @@ or1k*-*-*)
                 tm_file="${tm_file} gnu-user.h linux.h glibc-stdint.h"
                 ;;
 	or1k*-*-elf*)
-		tm_file="${tm_file} newlib-stdint.h"
-		extra_options="${extra_options}"
+		tm_file="${tm_file} newlib-stdint.h or1k/elf.h"
+		extra_options="${extra_options} or1k/elf.opt"
 		;;
 	or1k*-*-rtems*)
 		tm_file="${tm_file} newlib-stdint.h rtems.h"
diff --git a/gcc/config/or1k/elf.h b/gcc/config/or1k/elf.h
new file mode 100644
index 00000000000..0bb1662b179
--- /dev/null
+++ b/gcc/config/or1k/elf.h
@@ -0,0 +1,37 @@
+/* Target Newlib Definitions for OpenRISC.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   Contributed by Stafford Horne.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_OR1K_ELF_H
+#define GCC_OR1K_ELF_H
+
+#undef  LIB_SPEC
+#define LIB_SPEC "--start-group -lc -lor1k "			\
+  "%{mboard=*:-lboard-%*; :-lboard-or1ksim} --end-group"
+
+#undef	LINK_SPEC
+#define	LINK_SPEC "--entry=0x100"
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC "crt0.o%s crtbegin.o%s crti.o%s"
+
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC "crtn.o%s crtend.o%s"
+
+#endif /* GCC_OR1K_ELF_H */
diff --git a/gcc/config/or1k/elf.opt b/gcc/config/or1k/elf.opt
new file mode 100644
index 00000000000..956d395003d
--- /dev/null
+++ b/gcc/config/or1k/elf.opt
@@ -0,0 +1,33 @@
+; OpenRISC command line options for newlib binaries
+
+; Copyright (C) 2010-2018 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+; See the GCC internals manual (options.texi) for a description of
+; this file's format.
+
+; Please try to keep this file in ASCII collating order.
+
+mboard=
+Target RejectNegative Joined
+Configure board specific runtime.
+
+mnewlib
+Target RejectNegative
+For compatibility, it's always newlib for elf now.
+
diff --git a/gcc/config/or1k/or1k.opt b/gcc/config/or1k/or1k.opt
index 8cf7189b28a..930c50a7811 100644
--- a/gcc/config/or1k/or1k.opt
+++ b/gcc/config/or1k/or1k.opt
@@ -23,12 +23,4 @@
 
 ; Please try to keep this file in ASCII collating order.
 
-mboard=
-Target RejectNegative Joined
-Configure board specific runtime.
-
-mnewlib
-Target RejectNegative
-no description yet.
-
 
-- 
2.18.0


From fc7f96b80ac9fe5744d4b18861280539057c8191 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 8 May 2018 11:58:43 +0900
Subject: [PATCH 039/108] or1k: actually use high/lo for symbols

This allows us to preserve the symbols through
the linking phase.  Previously I was convering
these to ints which caused issues with eask symbols
and it was generally a bad idea.
---
 gcc/config/or1k/or1k.md | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index c6f5689b78f..5f68924a625 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -208,7 +208,7 @@
 	    int val = INTVAL (operands[1]);
 
 	    emit_insn (gen_movsi_high (operands[0], GEN_INT (val & ~0xffff)));
-	    emit_insn (gen_addsi3 (operands[0], operands[0],
+	    emit_insn (gen_iorsi3 (operands[0], operands[0],
 				   GEN_INT (val & 0xffff)));
 	    DONE;
 	  }
@@ -243,7 +243,7 @@
 	(lo_sum:SI (match_operand:SI 1 "register_operand"  "r")
 		   (match_operand:SI 2 "general_operand" "i")))]
   ""
-  "l.addi\t%0, %1, lo(%2)"
+  "l.ori\t%0, %1, lo(%2)"
   [(set_attr "type" "alu")])
 
 
-- 
2.18.0


From 74c65b42065702ea9e6ce3613674c0bb8017fd50 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Wed, 9 May 2018 22:44:08 +0900
Subject: [PATCH 040/108] or1k: fix issue with callee/caller saved register

We need to save what we dont.
---
 gcc/config/or1k/or1k.c |  5 +----
 gcc/config/or1k/or1k.h | 21 ++++++++++++---------
 2 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 1c25f1dd917..4e7bdcb2d78 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -82,13 +82,10 @@ or1k_option_override (void)
   init_machine_status = or1k_init_machine_status;
 }
 
-/* OpenRISC callee saved regs are even regs r14-r30.  */
 static bool
 callee_saved_regno_p (int regno)
 {
-  return regno <= 30
-         && regno >= 14
-         && (regno % 2 == 0);
+  return !call_used_regs[regno];
 }
 
 /* Compute the size of the local area and the size to be adjusted by the
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 70cda935ee9..3662d10e3ba 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -122,18 +122,21 @@
 #define FP_REGNUM   34
 #define FIRST_PSEUDO_REGISTER  35
 
-#define FIXED_REGISTERS   \
-{ 1, 1, 0, 0, 0, 0, 0, 0, \
-  0, 0, 1, 0, 0, 0, 0, 0, \
-  0, 0, 0, 0, 0, 0, 0, 0, \
-  0, 0, 0, 0, 0, 0, 0, 0, \
+#define FIXED_REGISTERS \
+{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, \
+  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+  0, 0,				\
   1, 1, 1}
 
+/* Caller saved/temporary registers + args + fixed */
+/*
+  0  1  2  3  4  5  6  7  8  9  */
 #define CALL_USED_REGISTERS \
-{ 1, 1, 0, 0, 0, 0, 0, 0, \
-  0, 1, 1, 1, 0, 0, 0, 0, \
-  0, 0, 0, 0, 0, 0, 0, 0, \
-  0, 0, 0, 0, 0, 0, 0, 0, \
+{ 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, \
+  1, 1, 1, 1, 0, 1, 0, 1, 0, 1, \
+  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, \
+  0, 1,				\
   1, 1, 1}
 
 enum reg_class
-- 
2.18.0


From 99c68b0afdecdf15252dacd20ed7ef23a0d4e436 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Sat, 12 May 2018 21:46:59 +0900
Subject: [PATCH 041/108] or1k: test fixes, fixes issue with relative symbol
 loads

Was having issue with basic malloc/free failing due to usage of
expression symbol + const_int.
---
 gcc/config/or1k/or1k.c        |  4 +++
 gcc/config/or1k/or1k.md       | 47 ++++++++++++++++++++++-------------
 gcc/config/or1k/predicates.md |  2 ++
 3 files changed, 36 insertions(+), 17 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 4e7bdcb2d78..a898f746aa9 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -85,6 +85,10 @@ or1k_option_override (void)
 static bool
 callee_saved_regno_p (int regno)
 {
+  /* If we are already saving the frame pointer don't save it 2 times.  */
+  if (frame_pointer_needed && regno == HARD_FRAME_POINTER_REGNUM)
+    return false;
+
   return !call_used_regs[regno];
 }
 
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 5f68924a625..7ca8f190297 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -166,11 +166,10 @@
   l.or\t%0, %1, %2
   l.ori\t%0, %1, %2")
 
+; One's complement is easy as xori will sign extend 0xffff
 (define_expand "one_cmplsi2"
-  [(set (match_operand:SI 0 "register_operand" "") (high:SI (const_int -65536)))
-   (set (match_dup 0) (plus:SI (match_dup 0) (const_int 65535)))
-   (set (match_dup 0) (xor:SI (match_dup 0)
-			      (match_operand:SI 1 "register_operand" "")))]
+  [(set (match_operand:SI 0 "register_operand" "")
+	(xor:SI (match_operand:SI 1 "register_operand" "") (const_int 65535)))]
   ""
   "")
 
@@ -190,29 +189,43 @@
     if (MEM_P (operands[0]))
       operands[1] = force_reg (<I:MODE>mode, operands[1]);
 
-    /* Load labels as hi/lo sums.  */
     if (LABEL_P (operands[1]) || SYMBOL_REF_P (operands[1]))
       {
+	/* Load labels as hi/lo sums.  */
 	emit_insn (gen_movsi_high (operands[0], operands[1]));
 	emit_insn (gen_movsi_lo_sum (operands[0], operands[0], operands[1]));
 	DONE;
       }
-
-    /* Load constants as hi/lo sums, which can be optimized out if 0.  */
-    if (CONSTANT_P (operands[1]))
+    else if (CONST_INT_P (operands[1]))
+      {
+	/* Load constants as hi/lo sums, which can be optimized out if 0.  */
+	if (!satisfies_constraint_J (operands[1])
+	    && !satisfies_constraint_M (operands[1]))
+	  {
+	    emit_insn (gen_movsi_high (operands[0], operands[1]));
+	    emit_insn (gen_movsi_lo_sum (operands[0], operands[0],
+					 operands[1]));
+	    DONE;
+	  }
+      }
+    else if (CONSTANT_P (operands[1])
+	     && GET_CODE (XEXP (operands[1], 0)) == PLUS)
       {
-	/* If its not a 16-bit constant expand.  */
-	if (!(satisfies_constraint_J (operands[1])
-	      || satisfies_constraint_M (operands[1])))
+	/* Load labels in for form (const (plus (symbol) (const_int))) as
+	   tmp = symbol; op0 = (plus (tmp) (const_int)).  */
+	rtx p0 = XEXP (XEXP (operands[1], 0), 0);
+	rtx p1 = XEXP (XEXP (operands[1], 0), 1);
+
+	if ((GET_CODE (p0) == SYMBOL_REF || GET_CODE (p0) == LABEL_REF)
+	    && GET_CODE(p1) == CONST_INT)
 	  {
-	    int val = INTVAL (operands[1]);
+	    rtx sym_temp = force_reg (SImode, p0);
 
-	    emit_insn (gen_movsi_high (operands[0], GEN_INT (val & ~0xffff)));
-	    emit_insn (gen_iorsi3 (operands[0], operands[0],
-				   GEN_INT (val & 0xffff)));
+	    emit_move_insn (operands[0], gen_rtx_PLUS (SImode, sym_temp, p1));
 	    DONE;
 	  }
       }
+
 })
 
 ;; 8-bit, 16-bit and 32-bit moves
@@ -233,7 +246,7 @@
 
 (define_insn "movsi_high"
   [(set (match_operand:SI 0 "register_operand" "=r")
-	(high:SI (match_operand:SI 1 "general_operand" "i")))]
+	(high:SI (match_operand:SI 1 "or1k_hilo_operand" "i")))]
   ""
   "l.movhi\t%0, hi(%1)"
   [(set_attr "type" "alu")])
@@ -241,7 +254,7 @@
 (define_insn "movsi_lo_sum"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(lo_sum:SI (match_operand:SI 1 "register_operand"  "r")
-		   (match_operand:SI 2 "general_operand" "i")))]
+		   (match_operand:SI 2 "or1k_hilo_operand" "i")))]
   ""
   "l.ori\t%0, %1, lo(%2)"
   [(set_attr "type" "alu")])
diff --git a/gcc/config/or1k/predicates.md b/gcc/config/or1k/predicates.md
index fae9d96ccaf..b4ff92ca20e 100644
--- a/gcc/config/or1k/predicates.md
+++ b/gcc/config/or1k/predicates.md
@@ -28,4 +28,6 @@
 	    (ior (match_operand 0 "memory_operand")
 		 (match_operand 0 "const_int_operand")))))
 
+(define_predicate "or1k_hilo_operand"
+  (match_code "symbol_ref,label_ref,const_int"))
 
-- 
2.18.0


From 868acca3e3185d6eec423d5e2c9f24a1c705ee71 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 15 May 2018 23:19:25 +0900
Subject: [PATCH 042/108] or1k: Fix stack, now hello world works

---
 gcc/config/or1k/or1k.c | 67 +++++++++++++++++++++++-------------------
 1 file changed, 37 insertions(+), 30 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index a898f746aa9..d803fe43564 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -52,18 +52,21 @@
 
 /* Per-function machine data.  */
 struct GTY(()) machine_function
- {
-   /* Number of bytes saved on the stack for callee saved registers.  */
-   int callee_saved_reg_size;
+{
+  /* Number of bytes saved on the stack for callee saved registers.  */
+  int callee_saved_reg_size;
+
+  /* Number of bytes saved on the stack for local variables.  */
+  int local_vars_size;
 
-   /* Number of bytes saved on the stack for local variables.  */
-   int local_vars_size;
+  /* Number of bytes saved on the stack for outgoing/sub-fucntion args.  */
+  int args_size;
 
-   /* The sum of sizes: locals vars, called saved regs, stack pointer
-    * and an optional frame pointer.
-    * Used in expand_prologue () and expand_epilogue().  */
-   int total_size;
- };
+  /* The sum of sizes: locals vars, called saved regs, stack pointer
+   * and an optional frame pointer.
+   * Used in expand_prologue () and expand_epilogue().  */
+  int total_size;
+};
 
 /* Zero initialization is OK for all current fields.  */
 
@@ -99,13 +102,13 @@ callee_saved_regno_p (int regno)
  *
  *  ---- previous frame --------
  *  current func arg[n]
- *  current func arg[0]   <-- r2 [FP]
+ *  current func arg[0]   <-- r2 [HFP]
  *  ---- current stack frame ---  ^  ---\
  *  return address      r9        |     |
  *  old frame pointer   r2       (+)    |-- machine->total_size
  *  callee saved regs             |     | > machine->callee_saved_reg_size
- *  local variables               |  ---/ > machine->local_vars_size
- *  sub function args     <-- r1 [SP]
+ *  local variables               |  ---/ > machine->local_vars_size       <-FP
+ *  sub function args     <-- r1 [SP]                                      <-AP
  *  ----------------------------  |
  *                               (-)
  *         (future)               |
@@ -114,23 +117,21 @@ callee_saved_regno_p (int regno)
  * All of these contents are optional.
  *
  * */
+
+#define OR1K_STACK_ALIGN(LOC)						\
+  (((LOC) + ((STACK_BOUNDARY / BITS_PER_UNIT) - 1))			\
+   & ~((STACK_BOUNDARY / BITS_PER_UNIT) - 1))
+
 static void
 or1k_compute_frame_layout (void)
 {
   /* For aligning the local variables.  */
   int stack_alignment = STACK_BOUNDARY / BITS_PER_UNIT;
-  int padding_locals;
+  int padding;
   int regno;
 
-  /* Padding needed for each element of the frame.  */
-  cfun->machine->local_vars_size = get_frame_size ();
-
-  /* Align to the stack alignment.  */
-  padding_locals = cfun->machine->local_vars_size % stack_alignment;
-  if (padding_locals)
-    padding_locals = stack_alignment - padding_locals;
-
-  cfun->machine->local_vars_size += padding_locals;
+  cfun->machine->local_vars_size = OR1K_STACK_ALIGN (get_frame_size ());
+  cfun->machine->args_size = OR1K_STACK_ALIGN (crtl->outgoing_args_size);
 
   /* Save callee-saved registers.  */
   cfun->machine->callee_saved_reg_size = 0;
@@ -141,7 +142,8 @@ or1k_compute_frame_layout (void)
 
   cfun->machine->total_size =
     + cfun->machine->local_vars_size
-    + cfun->machine->callee_saved_reg_size;
+    + cfun->machine->callee_saved_reg_size
+    + cfun->machine->args_size;
 
   if (frame_pointer_needed)
     cfun->machine->total_size += 4;
@@ -179,8 +181,9 @@ or1k_expand_prologue (void)
   if (flag_stack_usage_info)
     current_function_static_stack_size = cfun->machine->total_size;
 
-  /* Reserve space for local vars.  */
-  offset += cfun->machine->local_vars_size;
+  /* Reserve space for local vars and outgoing args.  */
+  offset += cfun->machine->local_vars_size
+	 + cfun->machine->args_size;
 
   /* Save callee-saved registers.  */
   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
@@ -231,8 +234,9 @@ or1k_expand_epilogue (void)
 			   stack_pointer_rtx,
 			   GEN_INT (-1 * offset)));
 
-  /* Reverse space for local vars.  */
-  offset += cfun->machine->local_vars_size;
+  /* Reverse space for local vars and args.  */
+  offset += cfun->machine->local_vars_size
+	 + cfun->machine->args_size;
 
   /* Restore callee-saved registers.  */
   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
@@ -282,8 +286,11 @@ or1k_initial_elimination_offset (int from, int to)
   switch (from)
     {
     case ARG_POINTER_REGNUM:
+      offset = 0;
+      break;
+
     case FRAME_POINTER_REGNUM:
-      offset = cfun->machine->total_size;
+      offset = cfun->machine->args_size;
       break;
 
 
@@ -292,7 +299,7 @@ or1k_initial_elimination_offset (int from, int to)
     }
 
   if (to == HARD_FRAME_POINTER_REGNUM)
-    offset = 0;
+    offset -= cfun->machine->total_size;
 
   return offset;
 
-- 
2.18.0


From 4dbba9ffb826539fd49b25702891bd8864361f85 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Thu, 17 May 2018 00:25:51 +0900
Subject: [PATCH 043/108] or1k: Fix some basic stack issues

Was set to 7 arg regs instead of the spec'd 6.
Mixed up arg pointer can outgoing args (stack pointer)
Dont need stack/param offset for openrisc.  Fixed up comments and
elimination offset to match.
---
 gcc/config/or1k/or1k.c | 13 +++++++------
 gcc/config/or1k/or1k.h | 16 ++++++----------
 2 files changed, 13 insertions(+), 16 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index d803fe43564..679c428736c 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -102,13 +102,13 @@ callee_saved_regno_p (int regno)
  *
  *  ---- previous frame --------
  *  current func arg[n]
- *  current func arg[0]   <-- r2 [HFP]
+ *  current func arg[0]   <-- r2 [HFP,AP]
  *  ---- current stack frame ---  ^  ---\
  *  return address      r9        |     |
  *  old frame pointer   r2       (+)    |-- machine->total_size
  *  callee saved regs             |     | > machine->callee_saved_reg_size
  *  local variables               |  ---/ > machine->local_vars_size       <-FP
- *  sub function args     <-- r1 [SP]                                      <-AP
+ *  sub function args     <-- r1 [SP]
  *  ----------------------------  |
  *                               (-)
  *         (future)               |
@@ -275,7 +275,7 @@ or1k_expand_eh_return (rtx eh_addr)
     FP -> HARD_FP or SP
     AP -> HARD_FP or SP
 
-  FP and AP are the same so.
+  HFP and AP are the same which is handled below.
  */
 int
 or1k_initial_elimination_offset (int from, int to)
@@ -285,15 +285,16 @@ or1k_initial_elimination_offset (int from, int to)
   /* Set OFFSET to the offset from the stack pointer.  */
   switch (from)
     {
+    /* Incoming args are all the way up at the previous frame.  */
     case ARG_POINTER_REGNUM:
-      offset = 0;
+      offset = cfun->machine->total_size;
       break;
 
+    /* Local args, are just past the ougoing args if any.  */
     case FRAME_POINTER_REGNUM:
       offset = cfun->machine->args_size;
       break;
 
-
     default:
       gcc_unreachable ();
     }
@@ -362,7 +363,7 @@ or1k_function_arg (cumulative_args_t cum_v, machine_mode mode,
 {
   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
 
-  if (*cum <= 6)
+  if (*cum < 6)
     return gen_rtx_REG (mode, *cum + 3);
   else
     return NULL_RTX;
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 3662d10e3ba..ef2330d86ce 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -275,22 +275,18 @@ do {                                                    \
    should increase the stack frame size by this amount.  */
 #define ACCUMULATE_OUTGOING_ARGS 0
 
-/* Offset from the argument pointer register to the first argument's
-   address.  On some machines it may depend on the data type of the
-   function.  If 'ARGS_GROW_DOWNWARD', this is the offset to the
-   location above the first argument's address.  */
-#define FIRST_PARM_OFFSET(FNDECL) (UNITS_PER_WORD)
-
 /* Stack layout and stack pointer usage.  */
 
+/* This plus ARG_POINTER_REGNUM points to the first word of incoming args.  */
+#define FIRST_PARM_OFFSET(FNDECL) (0)
+
+/* This plus STACK_POINTER_REGNUM points to the first work of outgoing args.  */
+#define STACK_POINTER_OFFSET (0)
+
 /* Define this macro if pushing a word onto the stack moves the stack
    pointer to a smaller address.  */
 #define STACK_GROWS_DOWNWARD 1
 
-/* Offset from the stack pointer register to the first location at which
-   outgoing arguments are placed.  */
-#define STACK_POINTER_OFFSET (UNITS_PER_WORD)
-
 /* An alias for a machine mode name.  This is the machine mode that
    elements of a jump-table should have.  */
 #define CASE_VECTOR_MODE SImode
-- 
2.18.0


From 8c1d9848e65ece62c0b279ec2bfd2f40af8714c5 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Fri, 18 May 2018 11:19:29 -0700
Subject: [PATCH 044/108] or1k: Tighten constraints and predicates

Use correct constraints for arithmetic; use predicates that
more closely match those constraints.

Add '%rN' to allow r0 to be used for const0_rtx; use this
in subsi3 (for negate) and cmov (for cset).

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c        | 75 ++++++++++++++-------------
 gcc/config/or1k/or1k.md       | 95 +++++++++++++++++++----------------
 gcc/config/or1k/predicates.md | 22 ++++++++
 3 files changed, 114 insertions(+), 78 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 679c428736c..6b48a56957c 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -450,50 +450,57 @@ or1k_print_operand (FILE *file, rtx x, int code)
 {
   rtx operand = x;
 
-  if (PRINT_OPERAND_PUNCT_VALID_P (code))
+  switch (code)
     {
-      switch (code)
+    case '#':
+      /* Conditionally add a nop in unfilled delay slot.  */
+      if (final_sequence == NULL)
+	fputs ("\n\t l.nop\n", file);
+      break;
+
+    case 'r':
+      if (REG_P (x))
+        fprintf (file, "%s", reg_names[REGNO (operand)]);
+      else if (x == CONST0_RTX (GET_MODE (x)))
+        fprintf (file, "r0");
+      else
+	output_operand_lossage ("invalid %%r value");
+      break;
+
+    case 0:
+      /* Print an operand as without a modifier letter.  */
+      switch (GET_CODE (operand))
 	{
-	case '#':
-	  /* Conditionally add a nop in unfilled delay slot.  */
-	  if (final_sequence == NULL)
-	    fputs ("\n\t l.nop\n", file);
+	case REG:
+	  if (REGNO (operand) > 31)
+	    internal_error ("internal error: bad register: %d",
+			    REGNO (operand));
+	  fprintf (file, "%s", reg_names[REGNO (operand)]);
+	  break;
+
+	case MEM:
+	  output_address (GET_MODE (XEXP (operand, 0)), XEXP (operand, 0));
+	  break;
+
+	case CODE_LABEL:
+	case LABEL_REF:
+	  output_asm_label (operand);
 	  break;
 
 	default:
-	  output_operand_lossage ("unknown operand letter: '%c'", code);
+	  /* No need to handle all strange variants, let output_addr_const
+	     do it for us.  */
+	  if (CONSTANT_P (operand))
+	    output_addr_const (file, operand);
+	  else
+	    internal_error ("unexpected operand: %d", GET_CODE (operand));
 	  break;
 	}
-      return;
-    }
-
-  /* Print an operand as without a modifier letter.  */
-  switch (GET_CODE (operand))
-    {
-    case REG:
-      if (REGNO (operand) > 31)
-	internal_error ("internal error: bad register: %d", REGNO (operand));
-      fprintf (file, "%s", reg_names[REGNO (operand)]);
-      return;
-
-    case MEM:
-      output_address (GET_MODE (XEXP (operand, 0)), XEXP (operand, 0));
-      return;
-
-    case CODE_LABEL:
-    case LABEL_REF:
-      output_asm_label (operand);
       break;
 
     default:
-      /* No need to handle all strange variants, let output_addr_const
-	 do it for us.  */
-      if (CONSTANT_P (operand))
-	{
-	  output_addr_const (file, operand);
-	  return;
-	}
-      internal_error ("unexpected operand: %d", GET_CODE (operand));
+      output_operand_lossage ("unknown operand letter: '%c'", code);
+      break;
     }
 }
 
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 7ca8f190297..ed0cce0b8ca 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -74,20 +74,20 @@
 ;; -------------------------------------------------------------------------
 
 (define_insn "addsi3"
-  [(set (match_operand:SI 0 "register_operand"   "=r, r")
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
 	  (plus:SI
-	   (match_operand:SI 1 "register_operand" "r, r")
-	   (match_operand:SI 2 "general_operand"  "r,MJ")))]
+	   (match_operand:SI 1 "register_operand"   "%r,r")
+	   (match_operand:SI 2 "reg_or_s16_operand" " r,M")))]
   ""
   "@
   l.add\t%0, %1, %2
   l.addi\t%0, %1, %2")
 
 (define_insn "mulsi3"
-  [(set (match_operand:SI 0 "register_operand"   "=r, r")
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
 	  (mult:SI
-	   (match_operand:SI 1 "register_operand" "r, r")
-	   (match_operand:SI 2 "general_operand"  "r,MJ")))]
+	   (match_operand:SI 1 "register_operand"   "%r,r")
+	   (match_operand:SI 2 "reg_or_s16_operand" " r,M")))]
   ""
   "@
   l.mul\t%0, %1, %2
@@ -97,7 +97,7 @@
   [(set (match_operand:SI 0 "register_operand" "=r")
 	  (div:SI
 	   (match_operand:SI 1 "register_operand" "r")
-	   (match_operand:SI 2 "general_operand" "r")))]
+	   (match_operand:SI 2 "register_operand" "r")))]
   ""
   "l.div\t%0, %1, %2")
 
@@ -105,17 +105,17 @@
   [(set (match_operand:SI 0 "register_operand" "=r")
 	  (udiv:SI
 	   (match_operand:SI 1 "register_operand" "r")
-	   (match_operand:SI 2 "general_operand" "r")))]
+	   (match_operand:SI 2 "register_operand" "r")))]
   ""
   "l.divu\t%0, %1, %2")
 
 (define_insn "subsi3"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	  (minus:SI
-	   (match_operand:SI 1 "register_operand" "r")
+	   (match_operand:SI 1 "reg_or_0_operand" "rI")
 	   (match_operand:SI 2 "register_operand" "r")))]
   ""
-  "l.sub\t%0, %1, %2")
+  "l.sub\t%0, %r1, %2")
 
 ;; -------------------------------------------------------------------------
 ;; Logical operators
@@ -128,48 +128,47 @@
 			      (lshiftrt "srl") (rotate "ror")])
 
 (define_insn "<shift_op>si3"
-  [(set (match_operand:SI 0 "register_operand"          "=r, r")
-	(SHIFT:SI (match_operand:SI 1 "register_operand" "r, r")
-		  (match_operand:SI 2 "general_operand"  "r,MJ")))]
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(SHIFT:SI (match_operand:SI 1 "register_operand"  "r,r")
+		  (match_operand:SI 2 "reg_or_u6_operand" "r,n")))]
   ""
   "@
    l.<shift_asm>\t%0, %1, %2
    l.<shift_asm>i\t%0, %1, %2")
 
 (define_insn "andsi3"
-  [(set (match_operand:SI 0 "register_operand"   "=r, r")
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
 	  (and:SI
-	   (match_operand:SI 1 "register_operand" "r, r")
-	   (match_operand:SI 2 "general_operand"  "r,MJ")))]
+	   (match_operand:SI 1 "register_operand"   "%r,r")
+	   (match_operand:SI 2 "reg_or_u16_operand" " r,J")))]
   ""
   "@
   l.and\t%0, %1, %2
   l.andi\t%0, %1, %2")
 
 (define_insn "xorsi3"
-  [(set (match_operand:SI 0 "register_operand"   "=r, r")
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
 	  (xor:SI
-	   (match_operand:SI 1 "register_operand" "r, r")
-	   (match_operand:SI 2 "general_operand"  "r,MJ")))]
+	   (match_operand:SI 1 "register_operand"   "%r,r")
+	   (match_operand:SI 2 "reg_or_s16_operand" " r,M")))]
   ""
   "@
   l.xor\t%0, %1, %2
   l.xori\t%0, %1, %2")
 
 (define_insn "iorsi3"
-  [(set (match_operand:SI 0 "register_operand"   "=r, r")
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
 	  (ior:SI
-	   (match_operand:SI 1 "register_operand" "r, r")
-	   (match_operand:SI 2 "general_operand"  "r,MJ")))]
+	   (match_operand:SI 1 "register_operand"   "%r,r")
+	   (match_operand:SI 2 "reg_or_u16_operand" " r,J")))]
   ""
   "@
   l.or\t%0, %1, %2
   l.ori\t%0, %1, %2")
 
-; One's complement is easy as xori will sign extend 0xffff
 (define_expand "one_cmplsi2"
   [(set (match_operand:SI 0 "register_operand" "")
-	(xor:SI (match_operand:SI 1 "register_operand" "") (const_int 65535)))]
+	(xor:SI (match_operand:SI 1 "register_operand" "") (const_int -1)))]
   ""
   "")
 
@@ -199,12 +198,20 @@
     else if (CONST_INT_P (operands[1]))
       {
 	/* Load constants as hi/lo sums, which can be optimized out if 0.  */
-	if (!satisfies_constraint_J (operands[1])
+	if (<MODE>mode == SImode
+            && !satisfies_constraint_J (operands[1])
+	    && !satisfies_constraint_K (operands[1])
 	    && !satisfies_constraint_M (operands[1]))
 	  {
-	    emit_insn (gen_movsi_high (operands[0], operands[1]));
-	    emit_insn (gen_movsi_lo_sum (operands[0], operands[0],
-					 operands[1]));
+            HOST_WIDE_INT i = INTVAL (operands[1]);
+            HOST_WIDE_INT lo = i & 0xffff;
+            HOST_WIDE_INT hi = i ^ lo;
+            rtx subtarget = operands[0];
+
+            if (!cse_not_expected && can_create_pseudo_p ())
+              subtarget = gen_reg_rtx (SImode);
+            emit_move_insn (subtarget, GEN_INT (hi));
+	    emit_insn (gen_iorsi3 (operands[0], subtarget, GEN_INT (lo)));
 	    DONE;
 	  }
       }
@@ -231,16 +238,18 @@
 ;; 8-bit, 16-bit and 32-bit moves
 
 (define_insn "*mov<I:mode>_internal"
-  [(set (match_operand:I 0 "nonimmediate_operand" "=r, r,mW, r")
-	(match_operand:I 1 "or1k_mov_operand"      "r,MJ, r,mW"))]
+  [(set (match_operand:I 0 "nonimmediate_operand" "=r,r,r,r,m,r")
+	(match_operand:I 1 "or1k_mov_operand"      "r,K,J,M,rI,m"))]
   "register_operand (operands[0], <I:MODE>mode)
-   || register_operand (operands[1], <I:MODE>mode)"
+   || reg_or_0_operand (operands[1], <I:MODE>mode)"
   "@
-   l.or\t%0, r0, %1
+   l.or\t%0, %1, %1
+   l.movhi\t%0, hi(%1)
    l.ori\t%0, r0, %1
-   l.s<I:ldst>\t%0, %1
+   l.xori\t%0, r0, %1
+   l.s<I:ldst>\t%0, %r1
    l.l<I:ldst>z\t%0, %1"
-  [(set_attr "type" "alu,alu,st,ld")])
+  [(set_attr "type" "alu,alu,alu,alu,st,ld")])
 
 ;; Hi/Low moves for constant and symbol loading
 
@@ -323,8 +332,8 @@
 
 (define_insn "*sf<intcmpcc:code>_insn"
   [(set (reg:CC CC_REGNUM)
-	(intcmpcc (match_operand:I 0 "register_operand" "r, r")
-	             (match_operand:I 1 "general_operand"      "r,MJ")))]
+	(intcmpcc (match_operand:I 0 "register_operand"   "r,r")
+	          (match_operand:I 1 "reg_or_s16_operand" "r,M")))]
   ""
   "@
    l.sf<insn>\t%0, %1
@@ -339,7 +348,7 @@
    (set (reg:CC CC_REGNUM)
 	(match_operator 1 "comparison_operator"
 	  [(match_operand:I 2 "register_operand" "")
-	   (match_operand:I 3 "general_operand" "")]))
+	   (match_operand:I 3 "reg_or_s16_operand" "")]))
    (set (match_dup 0)
 	(if_then_else:I (ne (reg:CC CC_REGNUM) (const_int 0))
 		      (match_dup 0)
@@ -348,14 +357,12 @@
   "")
 
 (define_insn "*cmov<I:mode>_insn"
-  [(set (match_operand:I 0 "register_operand" "=r,r")
+  [(set (match_operand:I 0 "register_operand" "=r")
 	(if_then_else:I (ne (reg:CC CC_REGNUM) (const_int 0))
-		      (match_operand:I 1 "register_operand" "r,r")
-		      (match_operand:I 2 "general_operand" "r,I")))]
+		      (match_operand:I 1 "reg_or_0_operand" "rI")
+		      (match_operand:I 2 "reg_or_0_operand" "rI")))]
   ""
-  "@
-   l.cmov\t%0, %1, %2
-   l.cmov\t%0, %1, r0")
+  "l.cmov\t%0, %r1, %r2")
 
 ;; -------------------------------------------------------------------------
 ;; Branch instructions
@@ -375,7 +382,7 @@
   [(set (reg:CC CC_REGNUM)
 	(match_operator 0 "comparison_operator"
 	  [(match_operand:SI 1 "register_operand" "")
-	   (match_operand:SI 2 "general_operand" "")]))
+	   (match_operand:SI 2 "reg_or_s16_operand" "")]))
    (set (pc)
 	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
 		      (label_ref (match_operand 3 "" ""))
diff --git a/gcc/config/or1k/predicates.md b/gcc/config/or1k/predicates.md
index b4ff92ca20e..3a73fdaee72 100644
--- a/gcc/config/or1k/predicates.md
+++ b/gcc/config/or1k/predicates.md
@@ -31,3 +31,25 @@
 (define_predicate "or1k_hilo_operand"
   (match_code "symbol_ref,label_ref,const_int"))
 
+(define_predicate "const0_operand"
+  (and (match_code "const_int,const_wide_int,const_double,const_vector")
+       (match_test "op == CONST0_RTX (mode)")))
+
+(define_predicate "reg_or_0_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "const0_operand")))
+
+(define_predicate "reg_or_u6_operand"
+  (if_then_else (match_code "const_int")
+    (match_test "INTVAL (op) >= 0 && INTVAL (op) <= 0x3f")
+    (match_operand 0 "register_operand")))
+
+(define_predicate "reg_or_u16_operand"
+  (if_then_else (match_code "const_int")
+    (match_test "INTVAL (op) >= 0 && INTVAL (op) <= 0xffff")
+    (match_operand 0 "register_operand")))
+
+(define_predicate "reg_or_s16_operand"
+  (if_then_else (match_code "const_int")
+    (match_test "INTVAL (op) >= -32768 && INTVAL (op) <= 32767")
+    (match_operand 0 "register_operand")))
-- 
2.18.0


From dfd1168670602282aa9d0206830e2c5043fa66a8 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Fri, 18 May 2018 12:32:53 -0700
Subject: [PATCH 045/108] or1k: Fix some symbol splitting

E.g. gcc.c-torture/compile/20000314-1.c.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.md | 109 ++++++++++++++++++++++------------------
 1 file changed, 60 insertions(+), 49 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index ed0cce0b8ca..0aeadc210d1 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -184,55 +184,66 @@
   [(set (match_operand:I 0 "nonimmediate_operand" "")
 	(match_operand:I 1 "general_operand" ""))]
   ""
-  {
-    if (MEM_P (operands[0]))
-      operands[1] = force_reg (<I:MODE>mode, operands[1]);
-
-    if (LABEL_P (operands[1]) || SYMBOL_REF_P (operands[1]))
-      {
-	/* Load labels as hi/lo sums.  */
-	emit_insn (gen_movsi_high (operands[0], operands[1]));
-	emit_insn (gen_movsi_lo_sum (operands[0], operands[0], operands[1]));
-	DONE;
-      }
-    else if (CONST_INT_P (operands[1]))
-      {
-	/* Load constants as hi/lo sums, which can be optimized out if 0.  */
-	if (<MODE>mode == SImode
-            && !satisfies_constraint_J (operands[1])
-	    && !satisfies_constraint_K (operands[1])
-	    && !satisfies_constraint_M (operands[1]))
-	  {
-            HOST_WIDE_INT i = INTVAL (operands[1]);
-            HOST_WIDE_INT lo = i & 0xffff;
-            HOST_WIDE_INT hi = i ^ lo;
-            rtx subtarget = operands[0];
-
-            if (!cse_not_expected && can_create_pseudo_p ())
-              subtarget = gen_reg_rtx (SImode);
-            emit_move_insn (subtarget, GEN_INT (hi));
-	    emit_insn (gen_iorsi3 (operands[0], subtarget, GEN_INT (lo)));
-	    DONE;
-	  }
-      }
-    else if (CONSTANT_P (operands[1])
-	     && GET_CODE (XEXP (operands[1], 0)) == PLUS)
-      {
-	/* Load labels in for form (const (plus (symbol) (const_int))) as
-	   tmp = symbol; op0 = (plus (tmp) (const_int)).  */
-	rtx p0 = XEXP (XEXP (operands[1], 0), 0);
-	rtx p1 = XEXP (XEXP (operands[1], 0), 1);
-
-	if ((GET_CODE (p0) == SYMBOL_REF || GET_CODE (p0) == LABEL_REF)
-	    && GET_CODE(p1) == CONST_INT)
-	  {
-	    rtx sym_temp = force_reg (SImode, p0);
-
-	    emit_move_insn (operands[0], gen_rtx_PLUS (SImode, sym_temp, p1));
-	    DONE;
-	  }
-      }
-
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx subtarget = op0;
+  rtx offset = NULL;
+
+  if (MEM_P (op0) && !const0_operand(op1, <MODE>mode))
+    operands[1] = op1 = force_reg (<MODE>mode, op1);
+
+  switch (GET_CODE (op1))
+    {
+    case CONST_INT:
+      /* Constants smaller than SImode can be loaded directly.
+         Otherwise, check to see if it requires splitting.  */
+      if (<MODE>mode == SImode
+	  && !satisfies_constraint_J (op1)
+	  && !satisfies_constraint_K (op1)
+	  && !satisfies_constraint_M (op1))
+	{
+          HOST_WIDE_INT i = INTVAL (op1);
+          HOST_WIDE_INT lo = i & 0xffff;
+          HOST_WIDE_INT hi = i ^ lo;
+
+          if (!cse_not_expected && can_create_pseudo_p ())
+            subtarget = gen_reg_rtx (SImode);
+          emit_move_insn (subtarget, GEN_INT (hi));
+	  emit_insn (gen_iorsi3 (op0, subtarget, GEN_INT (lo)));
+	  DONE;
+	}
+      break;
+
+    case CONST:
+      if (GET_CODE (XEXP (op1, 0)) == PLUS
+          && CONST_INT_P (XEXP (XEXP (op1, 0), 1)))
+	{
+	  offset = XEXP (XEXP (op1, 0), 1);
+          op1 = XEXP (XEXP (op1, 0), 0);
+
+          if (!cse_not_expected && can_create_pseudo_p ())
+	    subtarget = gen_reg_rtx (Pmode);
+        }
+      /* fallthru */
+
+    case SYMBOL_REF:
+    case LABEL_REF:
+      emit_insn (gen_movsi_high (subtarget, op1));
+      emit_insn (gen_movsi_lo_sum (subtarget, subtarget, op1));
+
+      if (offset != NULL)
+	{
+	  subtarget = expand_simple_binop (Pmode, PLUS, subtarget, offset,
+                                           op0, 1, OPTAB_DIRECT);
+          if (subtarget != op0)
+	    emit_move_insn(op0, subtarget);
+	}
+      DONE;
+
+    default:
+      break;
+    }
 })
 
 ;; 8-bit, 16-bit and 32-bit moves
-- 
2.18.0


From 8333ef1b98c57fd496b2ea5b0dbd28a7b05ab547 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Fri, 18 May 2018 14:40:01 -0700
Subject: [PATCH 046/108] or1k: Fix large stack frames

E.g. gcc.c-torture/compile/20020604-1.c

In addition, fix epilogue debug info.  Move emit_jump_insn from
or1k_expand_epilogue into the epilogue generator; we'll need to
do that anyway when we add sibcall_epilogue.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c  | 211 +++++++++++++++++++++++++++++-----------
 gcc/config/or1k/or1k.h  |   3 +-
 gcc/config/or1k/or1k.md |   4 +-
 3 files changed, 156 insertions(+), 62 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 6b48a56957c..635a7ea4af6 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -153,114 +153,207 @@ or1k_compute_frame_layout (void)
 }
 
 static void
-or1k_save_restore_reg (int regno, int offset, bool save_p)
+or1k_save_reg (int regno, HOST_WIDE_INT offset)
 {
-  rtx reg;
-  rtx mem;
+  rtx reg = gen_rtx_REG (Pmode, regno);
+  rtx mem = gen_frame_mem (SImode, plus_constant (Pmode, stack_pointer_rtx,
+						  offset));
+  rtx insn = emit_move_insn (mem, reg);
+  RTX_FRAME_RELATED_P (insn) = 1;
+}
 
-  reg = gen_rtx_REG (Pmode, regno);
-  mem = gen_rtx_MEM (SImode, gen_rtx_PLUS (Pmode, stack_pointer_rtx,
-                                           GEN_INT (offset)));
-  if (save_p)
-    {
-      rtx insn = emit_move_insn (mem, reg);
-      RTX_FRAME_RELATED_P (insn) = 1;
-    }
-  else
-    emit_move_insn (reg, mem);
+static rtx
+or1k_restore_reg (int regno, HOST_WIDE_INT offset, rtx cfa_restores)
+{
+  rtx reg = gen_rtx_REG (Pmode, regno);
+  rtx mem = gen_frame_mem (SImode, plus_constant (Pmode, stack_pointer_rtx,
+						  offset));
+  emit_move_insn (reg, mem);
+  return alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);
 }
 
 void
 or1k_expand_prologue (void)
 {
-  int offset;
+  HOST_WIDE_INT sp_offset = -cfun->machine->total_size;
+  HOST_WIDE_INT reg_offset, this_offset;
   int regno;
-
-  offset = -1 * cfun->machine->total_size;
+  rtx insn;
 
   if (flag_stack_usage_info)
-    current_function_static_stack_size = cfun->machine->total_size;
+    current_function_static_stack_size = -sp_offset;
 
-  /* Reserve space for local vars and outgoing args.  */
-  offset += cfun->machine->local_vars_size
-	 + cfun->machine->args_size;
+  /* Early exit for frameless functions.  */
+  if (sp_offset == 0)
+    return;
+
+  /* Adjust the stack pointer.  For large stack offsets we will
+     do this in multiple parts, before and after saving registers.  */
+  reg_offset = (sp_offset + cfun->machine->local_vars_size
+		+ cfun->machine->args_size);
+  this_offset = MAX (sp_offset, -32764);
+  reg_offset -= this_offset;
+  sp_offset -= this_offset;
+
+  insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
+				GEN_INT (this_offset)));
+  RTX_FRAME_RELATED_P (insn) = 1;
 
   /* Save callee-saved registers.  */
   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
     {
       if (df_regs_ever_live_p (regno) && callee_saved_regno_p (regno))
 	{
-	  or1k_save_restore_reg (regno, offset, true);
-
-	  offset += 4;
+	  or1k_save_reg (regno, reg_offset);
+	  reg_offset += 4;
 	}
     }
 
   /* Save and update frame pointer.  */
   if (frame_pointer_needed)
     {
-      gcc_assert (offset == -8);
-      or1k_save_restore_reg (HARD_FRAME_POINTER_REGNUM, offset, true);
-      emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);
-      offset += 4;
+      gcc_assert (reg_offset + this_offset == -8);
+      or1k_save_reg (HARD_FRAME_POINTER_REGNUM, reg_offset);
+      insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx,
+				    stack_pointer_rtx,
+				    GEN_INT (-this_offset)));
+      RTX_FRAME_RELATED_P (insn) = 1;
+      reg_offset += 4;
     }
 
   /* Save the link register.  */
-  gcc_assert (offset == -4);
-  or1k_save_restore_reg (LR_REGNUM, offset, true);
+  gcc_assert (reg_offset + this_offset == -4);
+  or1k_save_reg (LR_REGNUM, reg_offset);
 
-  /* Finally, adjust the stack pointer.  */
-  offset = -1 * cfun->machine->total_size;
-  if (offset != 0)
+  /* Allocate the rest of the stack frame, if any.  */
+  if (sp_offset != 0)
     {
-      rtx insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
-					stack_pointer_rtx,
-				    	GEN_INT (offset)));
-      RTX_FRAME_RELATED_P (insn) = 1;
+      if (sp_offset < 2 * -32768)
+	{
+          /* For very large offsets, we need a temporary register.  */
+	  rtx tmp = gen_rtx_REG (Pmode, PRO_EPI_TMP_REGNUM);
+	  emit_move_insn (tmp, GEN_INT (sp_offset));
+	  insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
+					stack_pointer_rtx, tmp));
+	  if (!frame_pointer_needed)
+	    {
+	      RTX_FRAME_RELATED_P (insn) = 1;
+	      add_reg_note (insn, REG_CFA_ADJUST_CFA,
+			    gen_rtx_SET (stack_pointer_rtx,
+					 plus_constant (Pmode,
+							stack_pointer_rtx,
+							sp_offset)));
+	    }
+	}
+      else
+	{
+	  /* Otherwise, emit one or two sequential subtracts.  */
+	  do
+	    {
+	      this_offset = MAX (sp_offset, -32768);
+	      sp_offset -= this_offset;
+
+	      insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
+					    stack_pointer_rtx,
+					    GEN_INT (this_offset)));
+	      if (!frame_pointer_needed)
+		RTX_FRAME_RELATED_P (insn) = 1;
+	    }
+	  while (sp_offset != 0);
+	}
     }
 }
 
 void
 or1k_expand_epilogue (void)
 {
+  HOST_WIDE_INT reg_offset, sp_offset;
+  rtx insn, cfa_restores = NULL;
   int regno;
-  int offset;
 
-  /* First, restore the stack pointer.  */
-  offset = -1 * cfun->machine->total_size;
+  sp_offset = cfun->machine->total_size;
+  if (sp_offset == 0)
+    return;
 
-  if (offset != 0)
-    emit_insn (gen_addsi3 (stack_pointer_rtx,
-			   stack_pointer_rtx,
-			   GEN_INT (-1 * offset)));
+  reg_offset = cfun->machine->local_vars_size + cfun->machine->args_size;
 
-  /* Reverse space for local vars and args.  */
-  offset += cfun->machine->local_vars_size
-	 + cfun->machine->args_size;
-
-  /* Restore callee-saved registers.  */
-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+  if (sp_offset >= 32768 || cfun->calls_alloca)
     {
-      if (df_regs_ever_live_p (regno) && callee_saved_regno_p (regno))
+      /* The saved registers are out of range of the stack pointer.
+	 We need to partially deallocate the stack frame now.  */
+      if (frame_pointer_needed)
+	{
+	  /* Reset the stack pointer to the bottom of the saved regs.  */
+	  sp_offset -= reg_offset;
+	  reg_offset = 0;
+	  insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
+					hard_frame_pointer_rtx,
+					GEN_INT (-sp_offset)));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	  add_reg_note (insn, REG_CFA_DEF_CFA,
+			plus_constant (Pmode, stack_pointer_rtx, sp_offset));
+	}
+      else if (sp_offset >= 3 * 32768)
 	{
-	  or1k_save_restore_reg (regno, offset, false);
-	  offset += 4;
+	  /* For very large offsets, we need a temporary register.  */
+	  rtx tmp = gen_rtx_REG (Pmode, PRO_EPI_TMP_REGNUM);
+	  emit_move_insn (tmp, GEN_INT (reg_offset));
+	  insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
+					stack_pointer_rtx, tmp));
+	  sp_offset -= reg_offset;
+	  reg_offset = 0;
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	  add_reg_note (insn, REG_CFA_DEF_CFA,
+			plus_constant (Pmode, stack_pointer_rtx, sp_offset));
+	}
+      else
+	{
+	  /* Otherwise, emit one or two sequential additions.  */
+	  do
+	    {
+	      HOST_WIDE_INT this_offset = MIN (reg_offset, 32764);
+	      reg_offset -= this_offset;
+	      sp_offset -= this_offset;
+
+	      insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
+					    stack_pointer_rtx,
+					    GEN_INT (this_offset)));
+	      RTX_FRAME_RELATED_P (insn) = 1;
+	      add_reg_note (insn, REG_CFA_DEF_CFA,
+			    plus_constant (Pmode, stack_pointer_rtx,
+					   sp_offset));
+	    }
+	  while (sp_offset >= 32768);
 	}
     }
 
+  /* Restore callee-saved registers.  */
+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    if (df_regs_ever_live_p (regno) && callee_saved_regno_p (regno))
+      {
+	cfa_restores = or1k_restore_reg (regno, reg_offset, cfa_restores);
+	reg_offset += 4;
+      }
+
   /* Restore frame pointer.  */
   if (frame_pointer_needed)
     {
-      gcc_assert (offset == -8);
-      or1k_save_restore_reg (HARD_FRAME_POINTER_REGNUM, offset, false);
-      offset += 4;
+      gcc_assert (reg_offset == sp_offset - 8);
+      cfa_restores = or1k_restore_reg (HARD_FRAME_POINTER_REGNUM,
+				       reg_offset, cfa_restores);
+      reg_offset += 4;
     }
 
   /* Restore link register.  */
-  gcc_assert (offset == -4);
-  or1k_save_restore_reg (LR_REGNUM, offset, false);
-
-  emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, LR_REGNUM)));
+  gcc_assert (reg_offset == sp_offset - 4);
+  cfa_restores = or1k_restore_reg (LR_REGNUM, reg_offset, cfa_restores);
+
+  /* Restore stack pointer.  */
+  insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
+				GEN_INT (sp_offset)));
+  RTX_FRAME_RELATED_P (insn) = 1;
+  REG_NOTES (insn) = cfa_restores;
+  add_reg_note (insn, REG_CFA_DEF_CFA, stack_pointer_rtx);
 }
 
 /* TODO, do we need to just set to r9? or should we put it to where r9
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index ef2330d86ce..06d3f8826a5 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -91,7 +91,7 @@
    r10   thread local storage
    r11   function return value
    r12   function return value high (upper 64-bit)
-   r13   temporary
+   r13   temporary (used in prologue and epilogue)
    r14   callee saved
    r15   temporary
    r16   callee saved
@@ -117,6 +117,7 @@
 #define TLS_REGNUM  10
 #define RV_REGNUM   11
 #define RVH_REGNUM  12
+#define PRO_EPI_TMP_REGNUM 13
 #define AP_REGNUM   32
 #define CC_REGNUM   33
 #define FP_REGNUM   34
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 0aeadc210d1..da789d56d06 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -480,11 +480,11 @@
 (define_expand "epilogue"
   [(return)]
   ""
-  "
 {
   or1k_expand_epilogue ();
+  emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, LR_REGNUM)));
   DONE;
-}")
+})
 
 (define_insn "return_internal"
   [(use (match_operand:SI 0 "register_operand" "r"))
-- 
2.18.0


From f8f0798d1922a58c8418694376de2787f6b01dcb Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Fri, 18 May 2018 15:35:56 -0700
Subject: [PATCH 047/108] or1k: Preserve old calling convention wrt
 pass-by-reference

E.g. gcc.c-torture/compile/20050622-1.c

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 635a7ea4af6..aada3919d98 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -416,6 +416,15 @@ or1k_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,
   return false;
 }
 
+/* Worker function for TARGET_PASS_BY_REFERENCE.  */
+
+static bool
+or1k_pass_by_reference (cumulative_args_t, machine_mode,
+			const_tree type, bool)
+{
+  return type && (AGGREGATE_TYPE_P (type) || int_size_in_bytes (type) > 8);
+}
+
 /* Worker function for TARGET_FUNCTION_VALUE.  */
 
 static rtx
@@ -619,10 +628,8 @@ or1k_print_operand (FILE *file, rtx x, int code)
 #define TARGET_FUNCTION_ARG_ADVANCE or1k_function_arg_advance
 #undef TARGET_RETURN_IN_MEMORY
 #define TARGET_RETURN_IN_MEMORY	or1k_return_in_memory
-#undef TARGET_MUST_PASS_IN_STACK
-#define	TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size
 #undef TARGET_PASS_BY_REFERENCE
-#define	TARGET_PASS_BY_REFERENCE hook_pass_by_reference_must_pass_in_stack
+#define	TARGET_PASS_BY_REFERENCE or1k_pass_by_reference
 
 /* Assembly generation.  */
 #undef  TARGET_PRINT_OPERAND
-- 
2.18.0


From 63adea5d4867cdf2286a8f51111a72b4ce42b254 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Fri, 18 May 2018 16:25:52 -0700
Subject: [PATCH 048/108] or1k: Implement nested functions

E.g. gcc.c-torture/compile/20010226-1.c

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c | 59 ++++++++++++++++++++++++++++++++++++++++++
 gcc/config/or1k/or1k.h |  7 ++---
 2 files changed, 63 insertions(+), 3 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index aada3919d98..ecd167324ae 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -40,6 +40,7 @@
 #include "calls.h"
 #include "expr.h"
 #include "builtins.h"
+#include "optabs.h"
 
 /* These 4 are needed to allow using satisfies_constraint_J.  */
 #include "insn-config.h"
@@ -606,6 +607,62 @@ or1k_print_operand (FILE *file, rtx x, int code)
     }
 }
 
+/* Worker function for TARGET_TRAMPOLINE_INIT.  */
+
+static void
+or1k_trampoline_init (rtx m_tramp, tree fndecl, rtx chain)
+{
+  const unsigned movhi_r13 = (0x06u << 26) | (13 << 21);
+  const unsigned movhi_r11 = (0x06u << 26) | (11 << 21);
+  const unsigned ori_r13_r13 = (0x21 << 26) | (13 << 21) | (13 << 16);
+  const unsigned ori_r11_r11 = (0x21 << 26) | (11 << 21) | (11 << 16);
+  const unsigned jr_r13 = (0x11 << 26) | (13 << 11);
+  rtx tramp[5], fnaddr, f_hi, f_lo, c_hi, c_lo;
+
+  fnaddr = force_operand (XEXP (DECL_RTL (fndecl), 0), NULL);
+  f_hi = expand_binop (SImode, lshr_optab, fnaddr, GEN_INT (16),
+		       NULL, true, OPTAB_DIRECT);
+  f_lo = expand_binop (SImode, and_optab, fnaddr, GEN_INT (0xffff),
+		       NULL, true, OPTAB_DIRECT);
+
+  chain = force_operand (chain, NULL);
+  c_hi = expand_binop (SImode, lshr_optab, chain, GEN_INT (16),
+		       NULL, true, OPTAB_DIRECT);
+  c_lo = expand_binop (SImode, and_optab, chain, GEN_INT (0xffff),
+		       NULL, true, OPTAB_DIRECT);
+
+  /* We want to generate
+   *
+   *	l.movhi r13,hi(nested_func)
+   *	l.movhi r11,hi(static_chain)
+   *	l.ori	r13,r13,lo(nested_func)
+   *	l.jr	r13
+   *	 l.ori	r11,r11,lo(static_chain)
+   */
+  tramp[0] = expand_binop (SImode, ior_optab, f_hi,
+			   gen_int_mode (movhi_r13, SImode),
+			   f_hi, true, OPTAB_DIRECT);
+  tramp[1] = expand_binop (SImode, ior_optab, c_hi,
+			   gen_int_mode (movhi_r11, SImode),
+			   c_hi, true, OPTAB_DIRECT);
+  tramp[2] = expand_binop (SImode, ior_optab, f_lo,
+			   gen_int_mode (ori_r13_r13, SImode),
+			   f_lo, true, OPTAB_DIRECT);
+  tramp[4] = expand_binop (SImode, ior_optab, c_lo,
+			   gen_int_mode (ori_r11_r11, SImode),
+			   c_lo, true, OPTAB_DIRECT);
+  tramp[3] = gen_int_mode (jr_r13, SImode);
+
+  for (int i = 0; i < 5; ++i)
+    {
+      rtx mem = adjust_address (m_tramp, SImode, i * 4);
+      emit_move_insn (mem, tramp[i]);
+    }
+
+  /* Flushing the trampoline from the instruction cache needs
+     to be done here. */
+}
+
 #undef TARGET_OPTION_OVERRIDE
 #define TARGET_OPTION_OVERRIDE or1k_option_override
 
@@ -630,6 +687,8 @@ or1k_print_operand (FILE *file, rtx x, int code)
 #define TARGET_RETURN_IN_MEMORY	or1k_return_in_memory
 #undef TARGET_PASS_BY_REFERENCE
 #define	TARGET_PASS_BY_REFERENCE or1k_pass_by_reference
+#undef TARGET_TRAMPOLINE_INIT
+#define TARGET_TRAMPOLINE_INIT or1k_trampoline_init
 
 /* Assembly generation.  */
 #undef  TARGET_PRINT_OPERAND
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 06d3f8826a5..33a208fc3bd 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -89,7 +89,7 @@
    r8    arg 5
    r9    function call return link address
    r10   thread local storage
-   r11   function return value
+   r11   function return value & static chain
    r12   function return value high (upper 64-bit)
    r13   temporary (used in prologue and epilogue)
    r14   callee saved
@@ -228,8 +228,8 @@ do {                                                    \
 
 
 /* Trampolines, for nested functions */
-#define TRAMPOLINE_SIZE 12
-#define TRAMPOLINE_ALIGNMENT (abort (), 0)
+#define TRAMPOLINE_SIZE      20
+#define TRAMPOLINE_ALIGNMENT 32
 
 /* Pointer mode */
 #define Pmode	SImode
@@ -237,6 +237,7 @@ do {                                                    \
 #define STACK_POINTER_REGNUM SP_REGNUM
 #define FRAME_POINTER_REGNUM FP_REGNUM
 #define HARD_FRAME_POINTER_REGNUM 2
+#define STATIC_CHAIN_REGNUM RV_REGNUM
 
 /* The register number of the arg pointer register, which is used to
    access the function's argument list.  */
-- 
2.18.0


From cfcb04331343073971625cf3a734622c1a9f4d6a Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Fri, 18 May 2018 17:35:40 -0700
Subject: [PATCH 049/108] or1k: Preserve old calling convention wrt varargs

E.g. gcc.c-torture/execute/20000519-1.c

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c | 36 ++++++++++++++++++++++++++----------
 1 file changed, 26 insertions(+), 10 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index ecd167324ae..68aac6eb4b8 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -420,10 +420,19 @@ or1k_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,
 /* Worker function for TARGET_PASS_BY_REFERENCE.  */
 
 static bool
-or1k_pass_by_reference (cumulative_args_t, machine_mode,
+or1k_pass_by_reference (cumulative_args_t, machine_mode mode,
 			const_tree type, bool)
 {
-  return type && (AGGREGATE_TYPE_P (type) || int_size_in_bytes (type) > 8);
+  HOST_WIDE_INT size;
+  if (type)
+    {
+      if (AGGREGATE_TYPE_P (type))
+	return true;
+      size = int_size_in_bytes (type);
+    }
+  else
+    size = GET_MODE_SIZE (mode);
+  return size < 0 || size > 8;
 }
 
 /* Worker function for TARGET_FUNCTION_VALUE.  */
@@ -462,31 +471,38 @@ or1k_function_value_regno_p (const unsigned int regno)
 static rtx
 or1k_function_arg (cumulative_args_t cum_v, machine_mode mode,
 		   const_tree type ATTRIBUTE_UNUSED,
-		   bool named ATTRIBUTE_UNUSED)
+		   bool named)
 {
+  /* VOIDmode is passed as a special flag for "last argument".  */
+  if (mode == VOIDmode)
+    return NULL_RTX;
+
   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+  int nreg = CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);
 
-  if (*cum < 6)
+  /* Note that all large arguments are passed by reference.  */
+  gcc_assert (nreg <= 2);
+  if (named && *cum + nreg <= 6)
     return gen_rtx_REG (mode, *cum + 3);
   else
     return NULL_RTX;
 }
 
-#define OR1K_FUNCTION_ARG_SIZE(MODE, TYPE)	\
-  ((MODE) != BLKmode ? GET_MODE_SIZE (MODE)	\
-   : (unsigned) int_size_in_bytes (TYPE))
-
 /* Worker function for TARGET_FUNCTION_ARG_ADVANCE.  Update the cumulative
    args to advnaced past the next function argument.  This is not needed
    for arguments passed on the stack.  */
 
 static void
 or1k_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,
-			   const_tree type, bool named ATTRIBUTE_UNUSED)
+			   const_tree type ATTRIBUTE_UNUSED, bool named)
 {
   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+  int nreg = CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);
 
-  *cum += ((3 + OR1K_FUNCTION_ARG_SIZE (mode, type)) / 4);
+  /* Note that all large arguments are passed by reference.  */
+  gcc_assert (nreg <= 2);
+  if (named)
+    *cum += nreg;
 }
 
 /* worker function for TARGET_RETURN_IN_MEMORY.  What type of args get returned
-- 
2.18.0


From 5521a516f2e80d47115c63e45675aeab4e03bbee Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Fri, 18 May 2018 17:46:48 -0700
Subject: [PATCH 050/108] or1k: Enable soft-float in libgcc

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 libgcc/config.host               |  2 +-
 libgcc/config/or1k/sfp-machine.h | 54 ++++++++++++++++++++++++++++++++
 2 files changed, 55 insertions(+), 1 deletion(-)
 create mode 100644 libgcc/config/or1k/sfp-machine.h

diff --git a/libgcc/config.host b/libgcc/config.host
index 5b2fca5ce6b..7822a9b1ed5 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -1009,7 +1009,7 @@ nios2-*-*)
 	extra_parts="$extra_parts crti.o crtn.o"
 	;;
 or1k-*-*)
-	tmake_file="$tmake_file or1k/t-or1k"
+	tmake_file="$tmake_file or1k/t-or1k t-softfp-sfdf t-softfp-excl t-softfp"
 	extra_parts="$extra_parts crti.o crtn.o"
 	;;
 pdp11-*-*)
diff --git a/libgcc/config/or1k/sfp-machine.h b/libgcc/config/or1k/sfp-machine.h
new file mode 100644
index 00000000000..5da9e84990d
--- /dev/null
+++ b/libgcc/config/or1k/sfp-machine.h
@@ -0,0 +1,54 @@
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)				\
+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_loop(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+#define _FP_QNANNEGATEDP 0
+
+/* Someone please check this.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)		\
+	&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))	\
+      {								\
+	R##_s = Y##_s;						\
+	_FP_FRAC_COPY_##wc(R,Y);				\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+	_FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define	__LITTLE_ENDIAN	1234
+#define	__BIG_ENDIAN	4321
+
+#define __BYTE_ORDER __BIG_ENDIAN
+
+#define _FP_TININESS_AFTER_ROUNDING 0
+
+/* Define ALIASNAME as a strong alias for NAME.  */
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# define _strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
-- 
2.18.0


From a9fbc96796cf8a508d0b726ef5349bbf28806602 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Fri, 18 May 2018 19:23:14 -0700
Subject: [PATCH 051/108] or1k: Support __builtin_{return,frame}_address

E.g. gcc.c-torture/execute/20010122-1.c.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k-protos.h |  3 +++
 gcc/config/or1k/or1k.c        | 38 +++++++++++++++++++++++++++++++++++
 gcc/config/or1k/or1k.h        |  9 +++++++++
 3 files changed, 50 insertions(+)

diff --git a/gcc/config/or1k/or1k-protos.h b/gcc/config/or1k/or1k-protos.h
index 3bbef7d720e..cd23ab5bc8e 100644
--- a/gcc/config/or1k/or1k-protos.h
+++ b/gcc/config/or1k/or1k-protos.h
@@ -22,3 +22,6 @@ extern int  or1k_initial_elimination_offset (int, int);
 extern void or1k_expand_prologue (void);
 extern void or1k_expand_epilogue (void);
 extern void or1k_expand_eh_return (rtx);
+extern rtx  or1k_initial_frame_addr (void);
+extern rtx  or1k_dynamic_chain_addr (rtx);
+extern rtx  or1k_return_addr (int, rtx);
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 68aac6eb4b8..92f15941a46 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -357,6 +357,42 @@ or1k_expand_epilogue (void)
   add_reg_note (insn, REG_CFA_DEF_CFA, stack_pointer_rtx);
 }
 
+/* Worker for INITIAL_FRAME_ADDRESS_RTX.  */
+
+rtx
+or1k_initial_frame_addr ()
+{
+  /* Use this to force a stack frame for the current function.  */
+  crtl->accesses_prior_frames = 1;
+  return arg_pointer_rtx;
+}
+
+/* Worker for DYNAMIC_CHAIN_ADDRESS.  */
+
+rtx
+or1k_dynamic_chain_addr (rtx frame)
+{
+  return plus_constant (Pmode, frame, -2 * UNITS_PER_WORD);
+}
+
+/* Worker for RETURN_ADDR_RTX.  */
+
+rtx
+or1k_return_addr (int, rtx frame)
+{
+  return gen_frame_mem (Pmode, plus_constant (Pmode, frame, -UNITS_PER_WORD));
+}
+
+/* Worker for TARGET_FRAME_POINTER_REQUIRED.  */
+
+static bool
+or1k_frame_pointer_required ()
+{
+  /* ??? While IRA checks accesses_prior_frames, reload does not.
+     We do want the frame pointer for this case.  */
+  return (crtl->accesses_prior_frames || crtl->profile);
+}
+
 /* TODO, do we need to just set to r9? or should we put it to where r9
    is stored on the stack?  */
 void
@@ -705,6 +741,8 @@ or1k_trampoline_init (rtx m_tramp, tree fndecl, rtx chain)
 #define	TARGET_PASS_BY_REFERENCE or1k_pass_by_reference
 #undef TARGET_TRAMPOLINE_INIT
 #define TARGET_TRAMPOLINE_INIT or1k_trampoline_init
+#undef TARGET_FRAME_POINTER_REQUIRED
+#define TARGET_FRAME_POINTER_REQUIRED or1k_frame_pointer_required
 
 /* Assembly generation.  */
 #undef  TARGET_PRINT_OPERAND
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 33a208fc3bd..cc5ca1609f9 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -298,6 +298,15 @@ do {                                                    \
 /* Indicates how loads of narrow mode values are loaded into words.  */
 #define LOAD_EXTEND_OP(MODE) (ZERO_EXTEND)
 
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
+   the stack pointer does not matter.  */
+#define EXIT_IGNORE_STACK 1
+
+/* Macros related to the access of the stack frame chain.  */
+#define INITIAL_FRAME_ADDRESS_RTX  or1k_initial_frame_addr ()
+#define DYNAMIC_CHAIN_ADDRESS      or1k_dynamic_chain_addr
+#define RETURN_ADDR_RTX            or1k_return_addr
+
 /* Profiling */
 #define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)
 
-- 
2.18.0


From f3574b96bc1ad62a0f0057641bb1c304811cd86d Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Fri, 18 May 2018 21:21:51 -0700
Subject: [PATCH 052/108] or1k: Fix rotate insn

The ror insn rotates right, not left.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.md | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index da789d56d06..b346d027e16 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -121,11 +121,11 @@
 ;; Logical operators
 ;; -------------------------------------------------------------------------
 
-(define_code_iterator SHIFT  [ashift ashiftrt lshiftrt rotate])
+(define_code_iterator SHIFT  [ashift ashiftrt lshiftrt rotatert])
 (define_code_attr shift_op   [(ashift "ashl") (ashiftrt "ashr")
-			      (lshiftrt "lshr") (rotate "rotl")])
+			      (lshiftrt "lshr") (rotatert "rotr")])
 (define_code_attr shift_asm  [(ashift "sll") (ashiftrt "sra")
-			      (lshiftrt "srl") (rotate "ror")])
+			      (lshiftrt "srl") (rotatert "ror")])
 
 (define_insn "<shift_op>si3"
   [(set (match_operand:SI 0 "register_operand" "=r,r")
-- 
2.18.0


From 628749a9ca53905f2099eeac116bff9037c262dd Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Fri, 18 May 2018 22:32:47 -0700
Subject: [PATCH 053/108] or1k: Accumulate outgoing args

We don't have "real" push insns; much better to allocate
all of the outgoing stack space within the prologue.

E.g. gcc.c-torture/compile/pr82052.c

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index cc5ca1609f9..7b2fe7fd22d 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -275,7 +275,7 @@ do {                                                    \
    'crtl->outgoing_args_size'.  No space will be pushed
    onto the stack for each call; instead, the function prologue
    should increase the stack frame size by this amount.  */
-#define ACCUMULATE_OUTGOING_ARGS 0
+#define ACCUMULATE_OUTGOING_ARGS 1
 
 /* Stack layout and stack pointer usage.  */
 
-- 
2.18.0


From eee99270b51687bf93205ea28f7d3ec3ab6fd603 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Fri, 18 May 2018 22:49:54 -0700
Subject: [PATCH 054/108] fixup! or1k: Implement nested functions

---
 gcc/config/or1k/or1k.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 92f15941a46..7fa35d25735 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -666,8 +666,8 @@ or1k_trampoline_init (rtx m_tramp, tree fndecl, rtx chain)
 {
   const unsigned movhi_r13 = (0x06u << 26) | (13 << 21);
   const unsigned movhi_r11 = (0x06u << 26) | (11 << 21);
-  const unsigned ori_r13_r13 = (0x21 << 26) | (13 << 21) | (13 << 16);
-  const unsigned ori_r11_r11 = (0x21 << 26) | (11 << 21) | (11 << 16);
+  const unsigned ori_r13_r13 = (0x2a << 26) | (13 << 21) | (13 << 16);
+  const unsigned ori_r11_r11 = (0x2a << 26) | (11 << 21) | (11 << 16);
   const unsigned jr_r13 = (0x11 << 26) | (13 << 11);
   rtx tramp[5], fnaddr, f_hi, f_lo, c_hi, c_lo;
 
-- 
2.18.0


From 82156647fc2aa6b4bb45c357530bd4465fcac74d Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 19 May 2018 00:21:05 -0700
Subject: [PATCH 055/108] or1k: Add conditional move patterns

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.md | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index b346d027e16..8bdb69de3cf 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -367,6 +367,27 @@
   ""
   "")
 
+(define_expand "mov<I:mode>cc"
+  [(set (match_operand:I 0 "register_operand" "")
+	(if_then_else:I (match_operand 1 "comparison_operator" "")
+	  (match_operand:I 2 "reg_or_0_operand" "")
+	  (match_operand:I 3 "reg_or_0_operand" "")))]
+  ""
+{
+  emit_insn (gen_mov<mode>cc_internal (operands[0], operands[1],
+				       operands[2], operands[3]));
+  DONE;
+})
+
+(define_expand "mov<I:mode>cc_internal"
+  [(set (reg:CC CC_REGNUM) (match_operand 1 "comparison_operator" ""))
+   (set (match_operand:I 0 "register_operand" "")
+	(if_then_else:I (ne (reg:CC CC_REGNUM) (const_int 0))
+	  (match_operand:I 2 "reg_or_0_operand" "")
+	  (match_operand:I 3 "reg_or_0_operand" "")))]
+  ""
+  "")
+
 (define_insn "*cmov<I:mode>_insn"
   [(set (match_operand:I 0 "register_operand" "=r")
 	(if_then_else:I (ne (reg:CC CC_REGNUM) (const_int 0))
-- 
2.18.0


From 0d84128fab5d2684fdd3ebc88d31a513feb26b9c Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 19 May 2018 12:47:24 -0700
Subject: [PATCH 056/108] or1k: Disable gcc.c-torture/execute/20101011-1.c

OpenRISC division by zero does not trap.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/testsuite/gcc.c-torture/execute/20101011-1.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/gcc/testsuite/gcc.c-torture/execute/20101011-1.c b/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
index dda49a59852..bc272fab005 100644
--- a/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
+++ b/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
@@ -93,6 +93,8 @@ __aeabi_idiv0 (int return_value)
 #elif defined (__nvptx__)
 /* There isn't even a signal function.  */
 # define DO_TEST 0
+#elif defined (__or1k__)
+  /* On OpenRISC division by zero does not trap.  */
 #else
 # define DO_TEST 1
 #endif
-- 
2.18.0


From 31f3264786ec852e32b03016226104e44523403b Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 19 May 2018 19:24:50 -0700
Subject: [PATCH 057/108] or1k: Port testsuite/gcc.dg/nop.h

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/testsuite/gcc.dg/nop.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/gcc/testsuite/gcc.dg/nop.h b/gcc/testsuite/gcc.dg/nop.h
index a0c19a34414..23491a603f5 100644
--- a/gcc/testsuite/gcc.dg/nop.h
+++ b/gcc/testsuite/gcc.dg/nop.h
@@ -2,6 +2,8 @@
 #define NOP "nop 0"
 #elif defined (__MMIX__)
 #define NOP "swym 0"
+#elif defined (__or1k__)
+#define NOP "l.nop"
 #else
 #define NOP "nop"
 #endif
-- 
2.18.0


From 4598d2eb20cc76ee4b33740b74e0f032ac05a3a3 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 19 May 2018 19:28:26 -0700
Subject: [PATCH 058/108] or1k: Port testsuite/gcc.dg/20020312-2.c

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/testsuite/gcc.dg/20020312-2.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/gcc/testsuite/gcc.dg/20020312-2.c b/gcc/testsuite/gcc.dg/20020312-2.c
index f5929e0b057..8d23c103ad0 100644
--- a/gcc/testsuite/gcc.dg/20020312-2.c
+++ b/gcc/testsuite/gcc.dg/20020312-2.c
@@ -111,6 +111,8 @@ extern void abort (void);
 /* No pic register.  */
 #elif defined (__nvptx__)
 /* No pic register.  */
+#elif defined (__or1k__)
+/* No pic register.  */
 #else
 # error "Modify the test for your target."
 #endif
-- 
2.18.0


From a2461fcf4158ad755032b2032b5302002fb13999 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 19 May 2018 12:41:17 -0700
Subject: [PATCH 059/108] or1k: Add movdi pattern

Works around a generic expansion bug.
E.g. gcc.c-torture/execute/20030222-1.c.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.md | 42 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 42 insertions(+)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 8bdb69de3cf..e7de34bbe8e 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -279,6 +279,48 @@
   "l.ori\t%0, %1, lo(%2)"
   [(set_attr "type" "alu")])
 
+;; 64-bit moves
+;; ??? The clobber that emit_move_multi_word emits is arguably incorrect.
+;; Consider gcc.c-torture/execute/20030222-1.c, where a reg-reg DImode
+;; move gets register allocated to a no-op move.  At which point the
+;; we actively clobber the input.
+
+(define_expand "movdi"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "")
+	(match_operand:DI 1 "general_operand" ""))]
+  ""
+{
+  if (MEM_P (operands[0]) && !const0_operand(operands[1], DImode))
+    operands[1] = force_reg (DImode, operands[1]);
+})
+
+(define_insn_and_split "*movdi"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=r,r,o,r")
+	(match_operand:DI 1 "general_operand"      " r,o,rI,n"))]
+  "register_operand (operands[0], DImode)
+   || reg_or_0_operand (operands[1], DImode)"
+  "#"
+  ""
+  [(const_int 0)]
+{
+  rtx l0 = operand_subword (operands[0], 0, 0, DImode);
+  rtx l1 = operand_subword (operands[1], 0, 0, DImode);
+  rtx h0 = operand_subword (operands[0], 1, 0, DImode);
+  rtx h1 = operand_subword (operands[1], 1, 0, DImode);
+
+  if (reload_completed && reg_overlap_mentioned_p (l0, h1))
+    {
+      gcc_assert (!reg_overlap_mentioned_p (h0, l1));
+      emit_move_insn (h0, h1);
+      emit_move_insn (l0, l1);
+    }
+  else
+    {
+      emit_move_insn (l0, l1);
+      emit_move_insn (h0, h1);
+    }
+  DONE;
+})
 
 ;; -------------------------------------------------------------------------
 ;; Sign Extending
-- 
2.18.0


From 67699d5a2a67a462c358dc8d2550c3ffd28896d3 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 19 May 2018 13:17:12 -0700
Subject: [PATCH 060/108] or1k: Unmacroize comparisons

The cpu only supports SImode comparisons.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.md | 23 ++++++++++++-----------
 1 file changed, 12 insertions(+), 11 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index e7de34bbe8e..e1442cd0630 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -383,10 +383,10 @@
 			(gt "gts") (gtu "gtu") (ge "ges") (le "les")
 			(geu "geu") (leu "leu") ])
 
-(define_insn "*sf<intcmpcc:code>_insn"
+(define_insn "*sf_insn"
   [(set (reg:CC CC_REGNUM)
-	(intcmpcc (match_operand:I 0 "register_operand"   "r,r")
-	          (match_operand:I 1 "reg_or_s16_operand" "r,M")))]
+	(intcmpcc (match_operand:SI 0 "register_operand"   "r,r")
+	          (match_operand:SI 1 "reg_or_s16_operand" "r,M")))]
   ""
   "@
    l.sf<insn>\t%0, %1
@@ -396,16 +396,17 @@
 ;; Conditional Store instructions
 ;; -------------------------------------------------------------------------
 
-(define_expand "cstore<I:mode>4"
-  [(set (match_operand:I 0 "register_operand" "") (const_int 1))
-   (set (reg:CC CC_REGNUM)
+(define_expand "cstoresi4"
+  [(set (reg:CC CC_REGNUM)
 	(match_operator 1 "comparison_operator"
-	  [(match_operand:I 2 "register_operand" "")
-	   (match_operand:I 3 "reg_or_s16_operand" "")]))
+	  [(match_operand:SI 2 "register_operand" "")
+	   (match_operand:SI 3 "reg_or_s16_operand" "")]))
+   (set (match_operand:SI 0 "register_operand" "")
+	(const_int 1))
    (set (match_dup 0)
-	(if_then_else:I (ne (reg:CC CC_REGNUM) (const_int 0))
-		      (match_dup 0)
-		      (reg:I ZERO_REGNUM)))]
+	(if_then_else:SI (ne (reg:CC CC_REGNUM) (const_int 0))
+	  (match_dup 0)
+	  (const_int 0)))]
   ""
   "")
 
-- 
2.18.0


From 76b7bfa99d123ea740e478a770cef126588144bb Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 19 May 2018 13:18:02 -0700
Subject: [PATCH 061/108] or1k: Add l.bnf

The reverse condition branch will be used when the compiler can't
reverse the sense of the compare, e.g. when using the immediate
forms of the compare insns.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.md | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index e1442cd0630..e5cdb806790 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -443,7 +443,7 @@
 ;; Branch instructions
 ;; -------------------------------------------------------------------------
 
-(define_insn "*cbranch_internal"
+(define_insn "*cbranch_positive"
   [(set (pc)
 	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
 		      (label_ref (match_operand 0 "" ""))
@@ -452,6 +452,14 @@
   "l.bf\t%0%#"
   [(set_attr "type" "control")])
 
+(define_insn "*cbranch_negative"
+  [(set (pc)
+	(if_then_else (eq (reg:CC CC_REGNUM) (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "l.bnf\t%0%#"
+  [(set_attr "type" "control")])
 
 (define_expand "cbranchsi4"
   [(set (reg:CC CC_REGNUM)
-- 
2.18.0


From 2050b6cba4637fdacb41ac8ed3aee7dcc525387a Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 19 May 2018 14:09:30 -0700
Subject: [PATCH 062/108] or1k: Tidy saved register selection

Do not unconditionally save LR.  Instead, force it saved only if
we are using a frame pointer.  Thus -fomit-frame-pointer with a
leaf function has a chance of not creating a stack frame.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c | 137 ++++++++++++++++++++++-------------------
 1 file changed, 75 insertions(+), 62 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 7fa35d25735..4aae9e24c0d 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -55,18 +55,18 @@
 struct GTY(()) machine_function
 {
   /* Number of bytes saved on the stack for callee saved registers.  */
-  int callee_saved_reg_size;
+  HOST_WIDE_INT callee_saved_reg_size;
 
   /* Number of bytes saved on the stack for local variables.  */
-  int local_vars_size;
+  HOST_WIDE_INT local_vars_size;
 
   /* Number of bytes saved on the stack for outgoing/sub-fucntion args.  */
-  int args_size;
+  HOST_WIDE_INT args_size;
 
   /* The sum of sizes: locals vars, called saved regs, stack pointer
    * and an optional frame pointer.
    * Used in expand_prologue () and expand_epilogue().  */
-  int total_size;
+  HOST_WIDE_INT total_size;
 };
 
 /* Zero initialization is OK for all current fields.  */
@@ -86,14 +86,31 @@ or1k_option_override (void)
   init_machine_status = or1k_init_machine_status;
 }
 
+/* Return true if REGNO must be saved for the current function.  */
+
 static bool
 callee_saved_regno_p (int regno)
 {
-  /* If we are already saving the frame pointer don't save it 2 times.  */
-  if (frame_pointer_needed && regno == HARD_FRAME_POINTER_REGNUM)
-    return false;
+  /* Check call-saved registers.  */
+  if (!call_used_regs[regno] && df_regs_ever_live_p (regno))
+    return true;
+
+  switch (regno)
+    {
+    case HARD_FRAME_POINTER_REGNUM:
+      return frame_pointer_needed;
 
-  return !call_used_regs[regno];
+    case LR_REGNUM:
+      /* Always save LR if we are saving HFP, producing a walkable
+	 stack chain with -fno-omit-frame-pointer.  */
+      return (frame_pointer_needed
+	      || !crtl->is_leaf
+	      || crtl->uses_pic_offset_table
+	      || df_regs_ever_live_p (regno));
+
+    default:
+      return false;
+    }
 }
 
 /* Compute the size of the local area and the size to be adjusted by the
@@ -116,41 +133,28 @@ callee_saved_regno_p (int regno)
  *                                V
  *
  * All of these contents are optional.
- *
- * */
-
-#define OR1K_STACK_ALIGN(LOC)						\
-  (((LOC) + ((STACK_BOUNDARY / BITS_PER_UNIT) - 1))			\
-   & ~((STACK_BOUNDARY / BITS_PER_UNIT) - 1))
+ */
 
 static void
 or1k_compute_frame_layout (void)
 {
-  /* For aligning the local variables.  */
-  int stack_alignment = STACK_BOUNDARY / BITS_PER_UNIT;
-  int padding;
-  int regno;
+  HOST_WIDE_INT local_vars_size, args_size, save_reg_size;
 
-  cfun->machine->local_vars_size = OR1K_STACK_ALIGN (get_frame_size ());
-  cfun->machine->args_size = OR1K_STACK_ALIGN (crtl->outgoing_args_size);
+  local_vars_size = get_frame_size ();
+  local_vars_size = ROUND_UP (local_vars_size, UNITS_PER_WORD);
 
-  /* Save callee-saved registers.  */
-  cfun->machine->callee_saved_reg_size = 0;
+  args_size = crtl->outgoing_args_size;
+  args_size = ROUND_UP (args_size, UNITS_PER_WORD);
 
-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
-    if (df_regs_ever_live_p (regno) && callee_saved_regno_p (regno))
-      cfun->machine->callee_saved_reg_size += 4;
+  save_reg_size = 0;
+  for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    if (callee_saved_regno_p (regno))
+      save_reg_size += UNITS_PER_WORD;
 
-  cfun->machine->total_size =
-    + cfun->machine->local_vars_size
-    + cfun->machine->callee_saved_reg_size
-    + cfun->machine->args_size;
-
-  if (frame_pointer_needed)
-    cfun->machine->total_size += 4;
-
-  /* Add space for the stack pointer.  */
-  cfun->machine->total_size += 4;
+  cfun->machine->local_vars_size = local_vars_size;
+  cfun->machine->args_size = args_size;
+  cfun->machine->callee_saved_reg_size = save_reg_size;
+  cfun->machine->total_size = save_reg_size + local_vars_size + args_size;
 }
 
 static void
@@ -178,7 +182,6 @@ or1k_expand_prologue (void)
 {
   HOST_WIDE_INT sp_offset = -cfun->machine->total_size;
   HOST_WIDE_INT reg_offset, this_offset;
-  int regno;
   rtx insn;
 
   if (flag_stack_usage_info)
@@ -201,30 +204,36 @@ or1k_expand_prologue (void)
   RTX_FRAME_RELATED_P (insn) = 1;
 
   /* Save callee-saved registers.  */
-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
-    {
-      if (df_regs_ever_live_p (regno) && callee_saved_regno_p (regno))
-	{
-	  or1k_save_reg (regno, reg_offset);
-	  reg_offset += 4;
-	}
-    }
+  for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    if (regno != HARD_FRAME_POINTER_REGNUM
+        && regno != LR_REGNUM
+        && callee_saved_regno_p (regno))
+      {
+	or1k_save_reg (regno, reg_offset);
+	reg_offset += UNITS_PER_WORD;
+      }
 
   /* Save and update frame pointer.  */
-  if (frame_pointer_needed)
+  if (callee_saved_regno_p (HARD_FRAME_POINTER_REGNUM))
     {
-      gcc_assert (reg_offset + this_offset == -8);
       or1k_save_reg (HARD_FRAME_POINTER_REGNUM, reg_offset);
-      insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx,
-				    stack_pointer_rtx,
-				    GEN_INT (-this_offset)));
-      RTX_FRAME_RELATED_P (insn) = 1;
-      reg_offset += 4;
+      if (frame_pointer_needed)
+	{
+	  insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx,
+					stack_pointer_rtx,
+					GEN_INT (-this_offset)));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	}
+      reg_offset += UNITS_PER_WORD;
     }
 
   /* Save the link register.  */
-  gcc_assert (reg_offset + this_offset == -4);
-  or1k_save_reg (LR_REGNUM, reg_offset);
+  if (callee_saved_regno_p (LR_REGNUM))
+    {
+      or1k_save_reg (LR_REGNUM, reg_offset);
+      reg_offset += UNITS_PER_WORD;
+    }
+  gcc_assert (reg_offset + this_offset == 0);
 
   /* Allocate the rest of the stack frame, if any.  */
   if (sp_offset != 0)
@@ -270,7 +279,6 @@ or1k_expand_epilogue (void)
 {
   HOST_WIDE_INT reg_offset, sp_offset;
   rtx insn, cfa_restores = NULL;
-  int regno;
 
   sp_offset = cfun->machine->total_size;
   if (sp_offset == 0)
@@ -329,25 +337,30 @@ or1k_expand_epilogue (void)
     }
 
   /* Restore callee-saved registers.  */
-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
-    if (df_regs_ever_live_p (regno) && callee_saved_regno_p (regno))
+  for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    if (regno != HARD_FRAME_POINTER_REGNUM
+        && regno != LR_REGNUM
+        && callee_saved_regno_p (regno))
       {
 	cfa_restores = or1k_restore_reg (regno, reg_offset, cfa_restores);
-	reg_offset += 4;
+	reg_offset += UNITS_PER_WORD;
       }
 
   /* Restore frame pointer.  */
-  if (frame_pointer_needed)
+  if (callee_saved_regno_p (HARD_FRAME_POINTER_REGNUM))
     {
-      gcc_assert (reg_offset == sp_offset - 8);
       cfa_restores = or1k_restore_reg (HARD_FRAME_POINTER_REGNUM,
 				       reg_offset, cfa_restores);
-      reg_offset += 4;
+      reg_offset += UNITS_PER_WORD;
     }
 
   /* Restore link register.  */
-  gcc_assert (reg_offset == sp_offset - 4);
-  cfa_restores = or1k_restore_reg (LR_REGNUM, reg_offset, cfa_restores);
+  if (callee_saved_regno_p (LR_REGNUM))
+    {
+      cfa_restores = or1k_restore_reg (LR_REGNUM, reg_offset, cfa_restores);
+      reg_offset += UNITS_PER_WORD;
+    }
+  gcc_assert (reg_offset == sp_offset);
 
   /* Restore stack pointer.  */
   insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
-- 
2.18.0


From 7bdccbbfa29d74d92ac26faf262b1ad0992f0a4a Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 19 May 2018 14:17:30 -0700
Subject: [PATCH 063/108] or1k: Fix formatting in md file

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.md | 10 ++++------
 1 file changed, 4 insertions(+), 6 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index e5cdb806790..355993b2445 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -494,12 +494,11 @@
 	      (clobber (reg:SI LR_REGNUM))
 	     ])]
   ""
-  "
 {
   rtx addr = XEXP (operands[0], 0);
   if (!CONSTANT_ADDRESS_P (addr))
     XEXP (operands[0], 0) = force_reg (Pmode, addr);
-}")
+})
 
 (define_insn "*call"
   [(call (mem:SI (match_operand:SI 0 "general_operand" "r,i"))
@@ -518,12 +517,11 @@
 		   (match_operand 2 "" "")))
 	      (clobber (reg:SI LR_REGNUM))])]
   ""
-  "
 {
   rtx addr = XEXP (operands[1], 0);
   if (!CONSTANT_ADDRESS_P (addr))
     XEXP (operands[1], 0) = force_reg (Pmode, addr);
-}")
+})
 
 (define_insn "*call_value"
   [(set (match_operand 0 "register_operand" "=r,r")
@@ -539,14 +537,14 @@
 ;; -------------------------------------------------------------------------
 ;; Prologue & Epilogue
 ;; -------------------------------------------------------------------------
+
 (define_expand "prologue"
   [(const_int 1)]
   ""
-  "
 {
   or1k_expand_prologue ();
   DONE;
-}")
+})
 
 ;; Expand epilogue as RTL
 (define_expand "epilogue"
-- 
2.18.0


From 1316ec7993521ac05a10c14e4cf6224f74210f2a Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 19 May 2018 14:57:14 -0700
Subject: [PATCH 064/108] or1k: Tidy hard register definitions

Do all of the defining via define_constant.  Add HFP_REGNUM.
Rename FP_REGNUM to SFP_REGNUM; rename PRO_EPI_TMP_REGNUM to
PE_TMP_REGNUM.  Remove unused ZERO_REGNUM, RVH_REGNUM.
Renumber SFP_REGNUM and CC_REGNUM to put the latter last.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c  |  4 ++--
 gcc/config/or1k/or1k.h  | 27 +++++++++++----------------
 gcc/config/or1k/or1k.md | 10 ++++++++--
 3 files changed, 21 insertions(+), 20 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 4aae9e24c0d..6a3daa18316 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -241,7 +241,7 @@ or1k_expand_prologue (void)
       if (sp_offset < 2 * -32768)
 	{
           /* For very large offsets, we need a temporary register.  */
-	  rtx tmp = gen_rtx_REG (Pmode, PRO_EPI_TMP_REGNUM);
+	  rtx tmp = gen_rtx_REG (Pmode, PE_TMP_REGNUM);
 	  emit_move_insn (tmp, GEN_INT (sp_offset));
 	  insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
 					stack_pointer_rtx, tmp));
@@ -305,7 +305,7 @@ or1k_expand_epilogue (void)
       else if (sp_offset >= 3 * 32768)
 	{
 	  /* For very large offsets, we need a temporary register.  */
-	  rtx tmp = gen_rtx_REG (Pmode, PRO_EPI_TMP_REGNUM);
+	  rtx tmp = gen_rtx_REG (Pmode, PE_TMP_REGNUM);
 	  emit_move_insn (tmp, GEN_INT (reg_offset));
 	  insn = emit_insn (gen_addsi3 (stack_pointer_rtx,
 					stack_pointer_rtx, tmp));
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 7b2fe7fd22d..37a8902010e 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -109,18 +109,13 @@
    r28   callee saved
    r29   temporary
    r30   callee saved
-   r31   temporary  */
-
-#define ZERO_REGNUM   0
-#define SP_REGNUM   1
-#define LR_REGNUM   9
-#define TLS_REGNUM  10
-#define RV_REGNUM   11
-#define RVH_REGNUM  12
-#define PRO_EPI_TMP_REGNUM 13
-#define AP_REGNUM   32
-#define CC_REGNUM   33
-#define FP_REGNUM   34
+   r31   temporary
+
+   r32   soft argument pointer
+   r33   soft frame pointer
+   r34   flag (bit) register
+ */
+
 #define FIRST_PSEUDO_REGISTER  35
 
 #define FIXED_REGISTERS \
@@ -172,7 +167,7 @@ enum reg_class
   ((REGNO >= FIRST_PSEUDO_REGISTER ) ? NO_REGS :		\
    (REGNO == AP_REGNUM						\
     || REGNO == CC_REGNUM					\
-    || REGNO == FP_REGNUM ? SPECIAL_REGS : GENERAL_REGS))
+    || REGNO == SFP_REGNUM ? SPECIAL_REGS : GENERAL_REGS))
 
 #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)               \
 do {                                                    \
@@ -206,7 +201,7 @@ do {                                                    \
   "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",	\
   "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",	\
   "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",	\
-  "?ap",  "?cc",  "?fp" }
+  "?ap",  "?fp",  "?cc" }
 
 /* This is how to output an assembler line
    that says to advance the location counter
@@ -235,8 +230,8 @@ do {                                                    \
 #define Pmode	SImode
 #define FUNCTION_MODE	SImode
 #define STACK_POINTER_REGNUM SP_REGNUM
-#define FRAME_POINTER_REGNUM FP_REGNUM
-#define HARD_FRAME_POINTER_REGNUM 2
+#define FRAME_POINTER_REGNUM SFP_REGNUM
+#define HARD_FRAME_POINTER_REGNUM HFP_REGNUM
 #define STATIC_CHAIN_REGNUM RV_REGNUM
 
 /* The register number of the arg pointer register, which is used to
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 355993b2445..033a075f691 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -27,9 +27,15 @@
 
 ;; Register numbers
 (define_constants
-  [(ZERO_REGNUM     0)
+  [(SP_REGNUM       1)
+   (HFP_REGNUM      2)
    (LR_REGNUM       9)
-   (CC_REGNUM      33)]
+   (TLS_REGNUM     10)
+   (RV_REGNUM      11)
+   (PE_TMP_REGNUM  13)
+   (AP_REGNUM      32)
+   (SFP_REGNUM     33)
+   (CC_REGNUM      34)]
 )
 
 ;; Instruction scheduler
-- 
2.18.0


From bb1a53635cf42cb271058f18249c2b2a6c4401ad Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 19 May 2018 17:14:43 -0700
Subject: [PATCH 065/108] or1k: Reorg comparisons

CC_REGNUM and CCmode do not accurately describe the SR[F] bit.
Rename to SR_F_REGNUM; use BImode; drop SPECIAL_REGS for FLAG_REGS.
Prevent any mode other than BImode from being used with SR[F].

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k-protos.h |  1 +
 gcc/config/or1k/or1k.c        | 48 +++++++++++++++++++++
 gcc/config/or1k/or1k.h        | 19 ++++-----
 gcc/config/or1k/or1k.md       | 78 +++++++++++++++++------------------
 4 files changed, 96 insertions(+), 50 deletions(-)

diff --git a/gcc/config/or1k/or1k-protos.h b/gcc/config/or1k/or1k-protos.h
index cd23ab5bc8e..ba1c388579d 100644
--- a/gcc/config/or1k/or1k-protos.h
+++ b/gcc/config/or1k/or1k-protos.h
@@ -25,3 +25,4 @@ extern void or1k_expand_eh_return (rtx);
 extern rtx  or1k_initial_frame_addr (void);
 extern rtx  or1k_dynamic_chain_addr (rtx);
 extern rtx  or1k_return_addr (int, rtx);
+extern void or1k_expand_compare (rtx *);
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 6a3daa18316..8d6467f1d3e 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -728,6 +728,54 @@ or1k_trampoline_init (rtx m_tramp, tree fndecl, rtx chain)
      to be done here. */
 }
 
+/* Worker for TARGET_HARD_REGNO_MODE_OK.  */
+
+static bool
+or1k_hard_regno_mode_ok (unsigned int regno, machine_mode mode)
+{
+  /* For OpenRISC, GENERAL_REGS can hold anything, while
+     FLAG_REGS are really single bits within SP[SR].  */
+  if (REGNO_REG_CLASS (regno) == FLAG_REGS)
+    return mode == BImode;
+  return true;
+}
+
+#undef TARGET_HARD_REGNO_MODE_OK
+#define TARGET_HARD_REGNO_MODE_OK or1k_hard_regno_mode_ok
+
+/* Worker for TARGET_CAN_CHANGE_MODE_CLASS.  */
+
+static bool
+or1k_can_change_mode_class (machine_mode from, machine_mode to,
+			    reg_class_t rclass)
+{
+  if (rclass == FLAG_REGS)
+    return from == to;
+  return true;
+}
+
+#undef TARGET_CAN_CHANGE_MODE_CLASS
+#define TARGET_CAN_CHANGE_MODE_CLASS or1k_can_change_mode_class
+
+/* Expand a comparison in operands[0] .. operands[2], where
+   [0] is the operator and [1],[2] are the operands.  Split out
+   the compare into SR[F] and return a new operation in operands[0].  */
+
+void
+or1k_expand_compare (rtx *operands)
+{
+  rtx sr_f = gen_rtx_REG (BImode, SR_F_REGNUM);
+
+  /* Emit the given comparison into the Flag bit.  */
+  PUT_MODE (operands[0], BImode);
+  emit_insn (gen_rtx_SET (sr_f, operands[0]));
+
+  /* Adjust the operands for use in the caller.  */
+  operands[0] = gen_rtx_NE (VOIDmode, sr_f, const0_rtx);
+  operands[1] = sr_f;
+  operands[2] = const0_rtx;
+}
+
 #undef TARGET_OPTION_OVERRIDE
 #define TARGET_OPTION_OVERRIDE or1k_option_override
 
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 37a8902010e..79ae31505ab 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -113,7 +113,7 @@
 
    r32   soft argument pointer
    r33   soft frame pointer
-   r34   flag (bit) register
+   r34   SR[F] (bit) register
  */
 
 #define FIRST_PSEUDO_REGISTER  35
@@ -139,23 +139,23 @@ enum reg_class
 {
   NO_REGS,
   GENERAL_REGS,
-  SPECIAL_REGS,
+  FLAG_REGS,
   ALL_REGS,
   LIM_REG_CLASSES
 };
 
 #define N_REG_CLASSES (int) LIM_REG_CLASSES
 
-#define REG_CLASS_NAMES { \
+#define REG_CLASS_NAMES {	\
   "NO_REGS", 			\
   "GENERAL_REGS",		\
-  "SPECIAL_REGS",		\
+  "FLAG_REGS",			\
   "ALL_REGS" }
 
 #define REG_CLASS_CONTENTS      \
 { {0x00000000, 0x00000000},	\
-  {0xffffffff, 0x00000000},	\
-  {0x00000000, 0x00000007},	\
+  {0xffffffff, 0x00000003},	\
+  {0x00000000, 0x00000004},	\
   {0xffffffff, 0x00000007}	\
 }
 
@@ -164,10 +164,7 @@ enum reg_class
    choose a class which is "minimal", meaning that no smaller class
    also contains the register.  */
 #define REGNO_REG_CLASS(REGNO) \
-  ((REGNO >= FIRST_PSEUDO_REGISTER ) ? NO_REGS :		\
-   (REGNO == AP_REGNUM						\
-    || REGNO == CC_REGNUM					\
-    || REGNO == SFP_REGNUM ? SPECIAL_REGS : GENERAL_REGS))
+  ((REGNO) >= SR_F_REGNUM ? FLAG_REGS : GENERAL_REGS)
 
 #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)               \
 do {                                                    \
@@ -201,7 +198,7 @@ do {                                                    \
   "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",	\
   "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",	\
   "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",	\
-  "?ap",  "?fp",  "?cc" }
+  "?ap",  "?fp",  "?sr_f" }
 
 /* This is how to output an assembler line
    that says to advance the location counter
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 033a075f691..adf0d9cd796 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -35,7 +35,7 @@
    (PE_TMP_REGNUM  13)
    (AP_REGNUM      32)
    (SFP_REGNUM     33)
-   (CC_REGNUM      34)]
+   (SR_F_REGNUM    34)]
 )
 
 ;; Instruction scheduler
@@ -390,31 +390,31 @@
 			(geu "geu") (leu "leu") ])
 
 (define_insn "*sf_insn"
-  [(set (reg:CC CC_REGNUM)
-	(intcmpcc (match_operand:SI 0 "register_operand"   "r,r")
-	          (match_operand:SI 1 "reg_or_s16_operand" "r,M")))]
+  [(set (reg:BI SR_F_REGNUM)
+	(intcmpcc:BI (match_operand:SI 0 "reg_or_0_operand"   "rI,rI")
+		     (match_operand:SI 1 "reg_or_s16_operand" "r,M")))]
   ""
   "@
-   l.sf<insn>\t%0, %1
-   l.sf<insn>i\t%0, %1")
+   l.sf<insn>\t%r0, %1
+   l.sf<insn>i\t%r0, %1")
 
 ;; -------------------------------------------------------------------------
 ;; Conditional Store instructions
 ;; -------------------------------------------------------------------------
 
 (define_expand "cstoresi4"
-  [(set (reg:CC CC_REGNUM)
-	(match_operator 1 "comparison_operator"
-	  [(match_operand:SI 2 "register_operand" "")
-	   (match_operand:SI 3 "reg_or_s16_operand" "")]))
-   (set (match_operand:SI 0 "register_operand" "")
-	(const_int 1))
-   (set (match_dup 0)
-	(if_then_else:SI (ne (reg:CC CC_REGNUM) (const_int 0))
+  [(set (match_operand:SI 0 "register_operand" "")
+	(if_then_else:SI
+	  (match_operator 1 "comparison_operator"
+	    [(match_operand:SI 2 "reg_or_0_operand" "")
+	     (match_operand:SI 3 "reg_or_s16_operand" "")])
 	  (match_dup 0)
 	  (const_int 0)))]
   ""
-  "")
+{
+  or1k_expand_compare (operands + 1);
+  emit_move_insn (operands[0], const1_rtx);
+})
 
 (define_expand "mov<I:mode>cc"
   [(set (match_operand:I 0 "register_operand" "")
@@ -423,27 +423,26 @@
 	  (match_operand:I 3 "reg_or_0_operand" "")))]
   ""
 {
-  emit_insn (gen_mov<mode>cc_internal (operands[0], operands[1],
-				       operands[2], operands[3]));
-  DONE;
+  rtx xops[3] = { operands[1], XEXP (operands[1], 0), XEXP (operands[1], 1) };
+  or1k_expand_compare (xops);
+  operands[1] = xops[0];
 })
 
-(define_expand "mov<I:mode>cc_internal"
-  [(set (reg:CC CC_REGNUM) (match_operand 1 "comparison_operator" ""))
-   (set (match_operand:I 0 "register_operand" "")
-	(if_then_else:I (ne (reg:CC CC_REGNUM) (const_int 0))
-	  (match_operand:I 2 "reg_or_0_operand" "")
-	  (match_operand:I 3 "reg_or_0_operand" "")))]
+(define_insn "*cmov<I:mode>_positive"
+  [(set (match_operand:I 0 "register_operand" "=r")
+	(if_then_else:I (ne (reg:BI SR_F_REGNUM) (const_int 0))
+		      (match_operand:I 1 "reg_or_0_operand" "rI")
+		      (match_operand:I 2 "reg_or_0_operand" "rI")))]
   ""
-  "")
+  "l.cmov\t%0, %r1, %r2")
 
-(define_insn "*cmov<I:mode>_insn"
+(define_insn "*cmov<I:mode>_negative"
   [(set (match_operand:I 0 "register_operand" "=r")
-	(if_then_else:I (ne (reg:CC CC_REGNUM) (const_int 0))
+	(if_then_else:I (eq (reg:BI SR_F_REGNUM) (const_int 0))
 		      (match_operand:I 1 "reg_or_0_operand" "rI")
 		      (match_operand:I 2 "reg_or_0_operand" "rI")))]
   ""
-  "l.cmov\t%0, %r1, %r2")
+  "l.cmov\t%0, %r2, %r1")
 
 ;; -------------------------------------------------------------------------
 ;; Branch instructions
@@ -451,7 +450,7 @@
 
 (define_insn "*cbranch_positive"
   [(set (pc)
-	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
+	(if_then_else (ne (reg:BI SR_F_REGNUM) (const_int 0))
 		      (label_ref (match_operand 0 "" ""))
 		      (pc)))]
   ""
@@ -460,7 +459,7 @@
 
 (define_insn "*cbranch_negative"
   [(set (pc)
-	(if_then_else (eq (reg:CC CC_REGNUM) (const_int 0))
+	(if_then_else (eq (reg:BI SR_F_REGNUM) (const_int 0))
 		      (label_ref (match_operand 0 "" ""))
 		      (pc)))]
   ""
@@ -468,16 +467,17 @@
   [(set_attr "type" "control")])
 
 (define_expand "cbranchsi4"
-  [(set (reg:CC CC_REGNUM)
-	(match_operator 0 "comparison_operator"
-	  [(match_operand:SI 1 "register_operand" "")
-	   (match_operand:SI 2 "reg_or_s16_operand" "")]))
-   (set (pc)
-	(if_then_else (ne (reg:CC CC_REGNUM) (const_int 0))
-		      (label_ref (match_operand 3 "" ""))
-		      (pc)))]
+  [(set (pc)
+	(if_then_else
+	  (match_operator 0 "comparison_operator"
+	    [(match_operand:SI 1 "reg_or_0_operand" "")
+	     (match_operand:SI 2 "reg_or_s16_operand" "")])
+	  (label_ref (match_operand 3 "" ""))
+	  (pc)))]
   ""
-  "")
+{
+  or1k_expand_compare (operands);
+})
 
 ;; -------------------------------------------------------------------------
 ;; Call and Jump instructions
-- 
2.18.0


From f24bf6124103616e1c2c47387b5f7a20db08afd6 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 19 May 2018 22:18:32 -0700
Subject: [PATCH 066/108] or1k: Remap registers to fix the ABI

The ABI is horrible, in that it has no two call-saved registers that
are adjacent.  Which means that RA cannot save DImode or DFmode values
in registers across calls.

Fix this by making GCC's notion of register numbers different from the
hardware and debug notion of register numbers.

In addition, add REG_ALLOC_ORDER.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.h | 81 +++++++++++++++++++++++++++++-------------
 1 file changed, 57 insertions(+), 24 deletions(-)

diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 79ae31505ab..4efdaf343b9 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -94,8 +94,8 @@
    r13   temporary (used in prologue and epilogue)
    r14   callee saved
    r15   temporary
-   r16   callee saved
-   r17   position independent code base pointer
+   r16   callee saved & pic base register
+   r17   temporary
    r18   callee saved
    r19   temporary
    r20   callee saved
@@ -114,26 +114,66 @@
    r32   soft argument pointer
    r33   soft frame pointer
    r34   SR[F] (bit) register
- */
+
+   This ABI has no adjacent call-saved register, which means that
+   DImode/DFmode pseudos cannot be call-saved and will always be
+   spilled across calls.  To solve this without changing the ABI,
+   remap the compiler internal register numbers to place the even
+   call-saved registers r16-r30 in 24-31, and the odd call-clobbered
+   registers r17-r31 in 16-23.  */
 
 #define FIRST_PSEUDO_REGISTER  35
 
-#define FIXED_REGISTERS \
-{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, \
-  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
-  0, 0,				\
-  1, 1, 1}
+#define HW_TO_GCC_REGNO(X)		\
+  ((X) < 16 || (X) > 31 ? (X)		\
+   : (X) & 1 ? ((X) - 16) / 2 + 16	\
+   : ((X) - 16) / 2 + 24)
+
+#define GCC_TO_HW_REGNO(X)		\
+  ((X) < 16 || (X) > 31 ? (X)		\
+   : (X) < 24 ? ((X) - 16) * 2 + 16	\
+   : ((X) - 24) * 2 + 16)
+
+#define DBX_REGISTER_NUMBER(X)  GCC_TO_HW_REGNO(X)
+
+#define REGISTER_NAMES { \
+  "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",   \
+  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",  \
+  "r17",  "r19",  "r21",  "r23",  "r25",  "r27",  "r29",  "r31",  \
+  "r16",  "r18",  "r20",  "r22",  "r24",  "r26",  "r28",  "r30",  \
+  "?ap",  "?fp",  "?sr_f" }
+
+#define FIXED_REGISTERS		\
+{ 1, 1, 0, 0, 0, 0, 0, 0,	\
+  0, 0, 1, 0, 0, 0, 0, 0,	\
+  0, 0, 0, 0, 0, 0, 0, 0,	\
+  0, 0, 0, 0, 0, 0, 0, 0,	\
+  1, 1, 1 }
 
 /* Caller saved/temporary registers + args + fixed */
-/*
-  0  1  2  3  4  5  6  7  8  9  */
-#define CALL_USED_REGISTERS \
-{ 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, \
-  1, 1, 1, 1, 0, 1, 0, 1, 0, 1, \
-  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, \
-  0, 1,				\
-  1, 1, 1}
+#define CALL_USED_REGISTERS	\
+{ 1, 1, 0, 1, 1, 1, 1, 1,	\
+  1, 1, 1, 1, 1, 1, 0, 1,	\
+  1, 1, 1, 1, 1, 1, 1, 1,	\
+  0, 0, 0, 0, 0, 0, 0, 0,	\
+  1, 1, 1 }
+
+/* List the order in which to allocate registers.  Each register must
+   be listed once, even those in FIXED_REGISTERS.  */
+
+#define REG_ALLOC_ORDER { \
+  16, 17, 18, 19, 20, 21, 22, 23,	/* r17-r31 (odd), non-saved */	\
+  13, 15,				/* non-saved */			\
+  12, 11,				/* non-saved return values */	\
+  8, 7, 6, 5, 4, 3,			/* non-saved argument regs */	\
+  14, 24, 25, 26, 27, 28, 29, 30, 31,	/* r14,r16-r31 (even), saved */	\
+  2,					/* saved hard frame pointer */	\
+  9,					/* saved return address */	\
+  0,					/* fixed zero reg */		\
+  1,					/* fixed stack pointer */	\
+  10,					/* fixed thread pointer */	\
+  32, 33, 34,				/* fixed ap, fp, sr[f], */	\
+}
 
 enum reg_class
 {
@@ -193,13 +233,6 @@ do {                                                    \
 #define BSS_SECTION_ASM_OP "\t.section\t.bss"
 #define SBSS_SECTION_ASM_OP "\t.section\t.sbss"
 
-#define REGISTER_NAMES {						\
-  "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",		\
-  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",	\
-  "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",	\
-  "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",	\
-  "?ap",  "?fp",  "?sr_f" }
-
 /* This is how to output an assembler line
    that says to advance the location counter
    to a multiple of 2**LOG bytes.  */
-- 
2.18.0


From a5e80734e083d92cacc1b80ee12488b3a8c97589 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 20 May 2018 13:08:32 -0700
Subject: [PATCH 067/108] or1k: Add sibcall patterns

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/constraints.md |   4 +
 gcc/config/or1k/or1k-protos.h  |   1 +
 gcc/config/or1k/or1k.c         |  65 +++++++++++++++
 gcc/config/or1k/or1k.h         |  23 ++++--
 gcc/config/or1k/or1k.md        | 141 ++++++++++++++++++++++-----------
 gcc/config/or1k/predicates.md  |   4 +
 6 files changed, 184 insertions(+), 54 deletions(-)

diff --git a/gcc/config/or1k/constraints.md b/gcc/config/or1k/constraints.md
index cf1fee93f4b..a1ba650fae8 100644
--- a/gcc/config/or1k/constraints.md
+++ b/gcc/config/or1k/constraints.md
@@ -23,6 +23,7 @@
 ;; -------------------------------------------------------------------------
 
 ; We use:
+;  c - sibcall registers
 ;  W - register indirect memory
 ;  I - constant zero
 ;  J - constant unsigned 16-bit
@@ -30,6 +31,9 @@
 ;  L - constant signed 26-bit (l.jal)
 ;  M - constant signed 16-bit
 
+(define_register_constraint "c" "SIBCALL_REGS"
+  "Registers which can hold a sibling call address")
+
 ;; Memory
 (define_constraint "W"
   "A register indirect memory operand."
diff --git a/gcc/config/or1k/or1k-protos.h b/gcc/config/or1k/or1k-protos.h
index ba1c388579d..cb33b80f150 100644
--- a/gcc/config/or1k/or1k-protos.h
+++ b/gcc/config/or1k/or1k-protos.h
@@ -26,3 +26,4 @@ extern rtx  or1k_initial_frame_addr (void);
 extern rtx  or1k_dynamic_chain_addr (rtx);
 extern rtx  or1k_return_addr (int, rtx);
 extern void or1k_expand_compare (rtx *);
+extern void or1k_expand_call (rtx, rtx, rtx, bool);
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 8d6467f1d3e..357172cecc0 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -41,6 +41,7 @@
 #include "expr.h"
 #include "builtins.h"
 #include "optabs.h"
+#include "explow.h"
 
 /* These 4 are needed to allow using satisfies_constraint_J.  */
 #include "insn-config.h"
@@ -776,6 +777,70 @@ or1k_expand_compare (rtx *operands)
   operands[2] = const0_rtx;
 }
 
+void
+or1k_expand_call (rtx retval, rtx fnaddr, rtx callarg1, bool sibcall)
+{
+  rtx call, use = NULL;
+
+#if 0
+  /* Calls via the PLT require the PIC register.  */
+  if (flag_pic
+      && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF
+      && !SYMBOL_REF_LOCAL_P (XEXP (fnaddr, 0)))
+    {
+      crtl->uses_pic_offset_table = 1;
+      use_reg (&use, pic_offset_table_rtx);
+    }
+#endif
+
+  if (!call_insn_operand (XEXP (fnaddr, 0), Pmode))
+    {
+      fnaddr = copy_to_mode_reg (Pmode, XEXP (fnaddr, 0));
+      fnaddr = gen_rtx_MEM (SImode, fnaddr);
+    }
+
+  call = gen_rtx_CALL (VOIDmode, fnaddr, callarg1);
+  if (retval)
+    call = gen_rtx_SET (retval, call);
+
+  /* Normal calls clobber LR.  This is required in order to
+     prevent e.g. a prologue store of LR being placed into
+     the delay slot of the call, after it has been updated.  */
+  if (!sibcall)
+    {
+      rtx clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, LR_REGNUM));
+      call = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, call, clob));
+    }
+  call = emit_call_insn (call);
+
+  CALL_INSN_FUNCTION_USAGE (call) = use;
+}
+
+/* Worker for TARGET_FUNCTION_OK_FOR_SIBCALL.  */
+
+static bool
+or1k_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,
+			      tree exp ATTRIBUTE_UNUSED)
+{
+#if 0
+  /* We can sibcall to any function if not PIC.  */
+  if (!flag_pic)
+    return true;
+
+  /* We can sibcall any indirect function.  */
+  if (decl == NULL)
+    return true;
+
+  /* If the call may go through the PLT, we need r16 live.  */
+  if (!targetm.binds_local_p (decl))
+    return false;
+#endif
+  return true;
+}
+
+#undef TARGET_FUNCTION_OK_FOR_SIBCALL
+#define TARGET_FUNCTION_OK_FOR_SIBCALL or1k_function_ok_for_sibcall
+
 #undef TARGET_OPTION_OVERRIDE
 #define TARGET_OPTION_OVERRIDE or1k_option_override
 
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 4efdaf343b9..78d876b57c9 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -178,6 +178,7 @@
 enum reg_class
 {
   NO_REGS,
+  SIBCALL_REGS,
   GENERAL_REGS,
   FLAG_REGS,
   ALL_REGS,
@@ -188,15 +189,22 @@ enum reg_class
 
 #define REG_CLASS_NAMES {	\
   "NO_REGS", 			\
+  "SIBCALL_REGS",		\
   "GENERAL_REGS",		\
   "FLAG_REGS",			\
   "ALL_REGS" }
 
+/* The SIBCALL_REGS must be call-clobbered, and not used as a temporary
+   in the epilogue.  This excludes R9 (LR), R11 (STATIC_CHAIN), and
+   R13 (PE_TMP_REGNUM).  */
+#define SIBCALL_REGS_MASK  0x00ff95f8u
+
 #define REG_CLASS_CONTENTS      \
-{ {0x00000000, 0x00000000},	\
-  {0xffffffff, 0x00000003},	\
-  {0x00000000, 0x00000004},	\
-  {0xffffffff, 0x00000007}	\
+{ { 0x00000000, 0x00000000 },	\
+  { SIBCALL_REGS_MASK,   0 },	\
+  { 0xffffffff, 0x00000003 },	\
+  { 0x00000000, 0x00000004 },	\
+  { 0xffffffff, 0x00000007 }	\
 }
 
 /* A C expression whose value is a register class containing hard
@@ -204,7 +212,9 @@ enum reg_class
    choose a class which is "minimal", meaning that no smaller class
    also contains the register.  */
 #define REGNO_REG_CLASS(REGNO) \
-  ((REGNO) >= SR_F_REGNUM ? FLAG_REGS : GENERAL_REGS)
+  ((REGNO) >= SR_F_REGNUM ? FLAG_REGS \
+   : (REGNO) < 32 && ((SIBCALL_REGS_MASK >> (REGNO)) & 1) ? SIBCALL_REGS \
+   : GENERAL_REGS)
 
 #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)               \
 do {                                                    \
@@ -292,8 +302,7 @@ do {                                                    \
 
 #define REGNO_OK_FOR_INDEX_P(REGNO) 0
 #define REGNO_OK_FOR_BASE_P(REGNO) \
-  ((REGNO) < FIRST_PSEUDO_REGISTER			\
-   || ((unsigned int) reg_renumber[REGNO]) < FIRST_PSEUDO_REGISTER)
+  ((REGNO) <= SFP_REGNUM || (unsigned int) reg_renumber[REGNO] < SFP_REGNUM)
 
 /* If defined, the maximum amount of space required for outgoing
    arguments will be computed and placed into the variable
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index adf0d9cd796..7d734db1963 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -480,8 +480,9 @@
 })
 
 ;; -------------------------------------------------------------------------
-;; Call and Jump instructions
+;; Jump instructions
 ;; -------------------------------------------------------------------------
+
 (define_insn "jump"
   [(set (pc) (label_ref (match_operand 0 "" "")))]
   ""
@@ -494,52 +495,6 @@
   "l.jr\t%0%#"
   [(set_attr "type" "control")])
 
-(define_expand "call"
-  [(parallel [(call (match_operand 0 "" "")
-		    (match_operand 1 "" ""))
-	      (clobber (reg:SI LR_REGNUM))
-	     ])]
-  ""
-{
-  rtx addr = XEXP (operands[0], 0);
-  if (!CONSTANT_ADDRESS_P (addr))
-    XEXP (operands[0], 0) = force_reg (Pmode, addr);
-})
-
-(define_insn "*call"
-  [(call (mem:SI (match_operand:SI 0 "general_operand" "r,i"))
-	 (match_operand 1 "" ""))
-   (clobber (reg:SI LR_REGNUM))]
-  ""
-  "@
-   l.jalr\t%0%#
-   l.jal\t%0%#"
-  [(set_attr "type" "control")])
-
-;; Call with a retun value
-(define_expand "call_value"
-  [(parallel [(set (match_operand 0 "" "")
-		   (call (match_operand 1 "" "")
-		   (match_operand 2 "" "")))
-	      (clobber (reg:SI LR_REGNUM))])]
-  ""
-{
-  rtx addr = XEXP (operands[1], 0);
-  if (!CONSTANT_ADDRESS_P (addr))
-    XEXP (operands[1], 0) = force_reg (Pmode, addr);
-})
-
-(define_insn "*call_value"
-  [(set (match_operand 0 "register_operand" "=r,r")
-	(call (mem:SI (match_operand:SI 1 "general_operand" "r,i"))
-	      (match_operand 2 "" "")))
-   (clobber (reg:SI LR_REGNUM))]
-  ""
-  "@
-   l.jalr\t%1%#
-   l.jal\t%1%#"
-  [(set_attr "type" "control")])
-
 ;; -------------------------------------------------------------------------
 ;; Prologue & Epilogue
 ;; -------------------------------------------------------------------------
@@ -562,6 +517,19 @@
   DONE;
 })
 
+(define_expand "sibcall_epilogue"
+  [(return)]
+  ""
+{
+  or1k_expand_epilogue ();
+  /* Placing a USE of LR here, rather than as a REG_USE on the
+     sibcall itself, means that LR is not unnecessarily live
+     within the function itself, which would force creation of
+     a stack frame.  */
+  emit_insn (gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, LR_REGNUM)));
+  DONE;
+})
+
 (define_insn "return_internal"
   [(use (match_operand:SI 0 "register_operand" "r"))
    (return)]
@@ -576,3 +544,82 @@
   or1k_expand_eh_return (operands[0]);
   DONE;
 })
+
+;; -------------------------------------------------------------------------
+;; Call Instructions
+;; -------------------------------------------------------------------------
+
+;; Leave these to last, as the modeless operand for call_value
+;; interferes with normal patterns.
+
+(define_expand "call"
+  [(call (match_operand 0) (match_operand 1))]
+  ""
+{
+  or1k_expand_call (NULL, operands[0], operands[1], false);
+  DONE;
+})
+
+(define_expand "sibcall"
+  [(call (match_operand 0) (match_operand 1))]
+  ""
+{
+  or1k_expand_call (NULL, operands[0], operands[1], true);
+  DONE;
+})
+
+(define_expand "call_value"
+  [(set (match_operand 0) (call (match_operand 1) (match_operand 2)))]
+  ""
+{
+  or1k_expand_call (operands[0], operands[1], operands[2], false);
+  DONE;
+})
+
+(define_expand "sibcall_value"
+  [(set (match_operand 0) (call (match_operand 1) (match_operand 2)))]
+  ""
+{
+  or1k_expand_call (operands[0], operands[1], operands[2], true);
+  DONE;
+})
+
+(define_insn "*call"
+  [(call (mem:SI (match_operand:SI 0 "call_insn_operand" "r,s"))
+	 (match_operand 1))
+   (clobber (reg:SI LR_REGNUM))]
+  "!SIBLING_CALL_P (insn)"
+  "@
+   l.jalr\t%0%#
+   l.jal\t%0%#"
+  [(set_attr "type" "control")])
+
+(define_insn "*sibcall"
+  [(call (mem:SI (match_operand:SI 0 "call_insn_operand" "c,s"))
+	 (match_operand 1))]
+  "SIBLING_CALL_P (insn)"
+  "@
+   l.jr\t%0%#
+   l.j\t%0%#"
+  [(set_attr "type" "control")])
+
+(define_insn "*call_value"
+  [(set (match_operand 0)
+	(call (mem:SI (match_operand:SI 1 "call_insn_operand" "r,s"))
+	      (match_operand 2)))
+   (clobber (reg:SI LR_REGNUM))]
+  "!SIBLING_CALL_P (insn)"
+  "@
+   l.jalr\t%1%#
+   l.jal\t%1%#"
+  [(set_attr "type" "control")])
+
+(define_insn "*sibcall_value"
+  [(set (match_operand 0)
+	(call (mem:SI (match_operand:SI 1 "call_insn_operand" "c,s"))
+	      (match_operand 2)))]
+  "SIBLING_CALL_P (insn)"
+  "@
+   l.jr\t%1%#
+   l.j\t%1%#"
+  [(set_attr "type" "control")])
diff --git a/gcc/config/or1k/predicates.md b/gcc/config/or1k/predicates.md
index 3a73fdaee72..1de2e850062 100644
--- a/gcc/config/or1k/predicates.md
+++ b/gcc/config/or1k/predicates.md
@@ -53,3 +53,7 @@
   (if_then_else (match_code "const_int")
     (match_test "INTVAL (op) >= -32768 && INTVAL (op) <= 32767")
     (match_operand 0 "register_operand")))
+
+(define_predicate "call_insn_operand"
+  (ior (match_code "symbol_ref")
+       (match_operand 0 "register_operand")))
-- 
2.18.0


From 54f345d605647c694b8f0e853f43384c1c75b9e8 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 20 May 2018 15:30:43 -0700
Subject: [PATCH 068/108] or1k: Add simple_return

This enables shrink-wrapping in the generic code.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.md | 15 +++++++++++----
 1 file changed, 11 insertions(+), 4 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 7d734db1963..8738fb00073 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -513,7 +513,7 @@
   ""
 {
   or1k_expand_epilogue ();
-  emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, LR_REGNUM)));
+  emit_jump_insn (gen_simple_return ());
   DONE;
 })
 
@@ -530,9 +530,16 @@
   DONE;
 })
 
-(define_insn "return_internal"
-  [(use (match_operand:SI 0 "register_operand" "r"))
-   (return)]
+(define_expand "simple_return"
+  [(parallel [(simple_return) (use (match_dup 0))])]
+  ""
+{
+  operands[0] = gen_rtx_REG (Pmode, LR_REGNUM);
+})
+
+(define_insn "*simple_return"
+  [(simple_return)
+   (use (match_operand:SI 0 "register_operand" "r"))]
   ""
   "l.jr\t%0%#"
   [(set_attr "type" "control")])
-- 
2.18.0


From a9a1b8b20e8cd2f3e1af1edaf7b0d46afdd168d5 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 20 May 2018 16:03:00 -0700
Subject: [PATCH 069/108] or1k: Disable some __builtin_apply tests

As with several other targets, the ABI does not support them.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/testsuite/gcc.dg/builtin-apply2.c                     | 2 +-
 gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/gcc/testsuite/gcc.dg/builtin-apply2.c b/gcc/testsuite/gcc.dg/builtin-apply2.c
index 3768caa5d5a..dd521973cae 100644
--- a/gcc/testsuite/gcc.dg/builtin-apply2.c
+++ b/gcc/testsuite/gcc.dg/builtin-apply2.c
@@ -1,7 +1,7 @@
 /* { dg-do run } */
 /* { dg-require-effective-target untyped_assembly } */
 /* { dg-skip-if "Variadic funcs have all args on stack. Normal funcs have args in registers." { "avr-*-* nds32*-*-*" } } */
-/* { dg-skip-if "Variadic funcs use different argument passing from normal funcs." { "riscv*-*-*" } } */
+/* { dg-skip-if "Variadic funcs use different argument passing from normal funcs." { "riscv*-*-* or1k*-*-*" } } */
 /* { dg-skip-if "Variadic funcs use Base AAPCS.  Normal funcs use VFP variant." { arm*-*-* && arm_hf_eabi } } */
 
 /* PR target/12503 */
diff --git a/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c b/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c
index d033010dc7c..3f8d350ba8f 100644
--- a/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c
+++ b/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c
@@ -9,7 +9,7 @@
 /* arm_hf_eabi: Variadic funcs use Base AAPCS.  Normal funcs use VFP variant.
    avr: Variadic funcs don't pass arguments in registers, while normal funcs
         do.  */
-/* { dg-skip-if "Variadic funcs use different argument passing from normal funcs" { arm_hf_eabi || { avr-*-* riscv*-*-* } } } */
+/* { dg-skip-if "Variadic funcs use different argument passing from normal funcs" { arm_hf_eabi || { avr-*-* riscv*-*-* or1k*-*-* } } } */
 /* { dg-skip-if "Variadic funcs have all args on stack. Normal funcs have args in registers." { nds32*-*-* } } */
 /* { dg-require-effective-target untyped_assembly } */
    
-- 
2.18.0


From 1002804a4aadc379e6686cbf61b2f4b7dd245ddb Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 20 May 2018 20:23:12 -0700
Subject: [PATCH 070/108] or1k: Rename zero constraint to O

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/constraints.md | 12 +++++-------
 gcc/config/or1k/or1k.md        | 16 ++++++++--------
 2 files changed, 13 insertions(+), 15 deletions(-)

diff --git a/gcc/config/or1k/constraints.md b/gcc/config/or1k/constraints.md
index a1ba650fae8..d6002b71497 100644
--- a/gcc/config/or1k/constraints.md
+++ b/gcc/config/or1k/constraints.md
@@ -24,12 +24,11 @@
 
 ; We use:
 ;  c - sibcall registers
-;  W - register indirect memory
-;  I - constant zero
 ;  J - constant unsigned 16-bit
 ;  K - constant signed 16-bit shifted left 16-bits (l.movhi)
 ;  L - constant signed 26-bit (l.jal)
 ;  M - constant signed 16-bit
+;  O - constant zero
 
 (define_register_constraint "c" "SIBCALL_REGS"
   "Registers which can hold a sibling call address")
@@ -42,11 +41,6 @@
 					       XEXP (op, 0), false)")))
 
 ;; Immediates
-(define_constraint "I"
-  "The constant zero"
-  (and (match_code "const_int")
-       (match_test "ival == 0")))
-
 (define_constraint "J"
   "An unsigned 16-bit immediate in the range 0 to 0xffff."
   (and (match_code "const_int")
@@ -68,3 +62,7 @@
   (and (match_code "const_int")
        (match_test "IN_RANGE (ival, -32768, 32767)")))
 
+(define_constraint "O"
+  "The constant zero"
+  (and (match_code "const_int")
+       (match_test "ival == 0")))
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 8738fb00073..ad6f386f3a5 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -118,7 +118,7 @@
 (define_insn "subsi3"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	  (minus:SI
-	   (match_operand:SI 1 "reg_or_0_operand" "rI")
+	   (match_operand:SI 1 "reg_or_0_operand" "rO")
 	   (match_operand:SI 2 "register_operand" "r")))]
   ""
   "l.sub\t%0, %r1, %2")
@@ -256,7 +256,7 @@
 
 (define_insn "*mov<I:mode>_internal"
   [(set (match_operand:I 0 "nonimmediate_operand" "=r,r,r,r,m,r")
-	(match_operand:I 1 "or1k_mov_operand"      "r,K,J,M,rI,m"))]
+	(match_operand:I 1 "or1k_mov_operand"      "r,K,J,M,rO,m"))]
   "register_operand (operands[0], <I:MODE>mode)
    || reg_or_0_operand (operands[1], <I:MODE>mode)"
   "@
@@ -302,7 +302,7 @@
 
 (define_insn_and_split "*movdi"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=r,r,o,r")
-	(match_operand:DI 1 "general_operand"      " r,o,rI,n"))]
+	(match_operand:DI 1 "general_operand"      " r,o,rO,n"))]
   "register_operand (operands[0], DImode)
    || reg_or_0_operand (operands[1], DImode)"
   "#"
@@ -391,7 +391,7 @@
 
 (define_insn "*sf_insn"
   [(set (reg:BI SR_F_REGNUM)
-	(intcmpcc:BI (match_operand:SI 0 "reg_or_0_operand"   "rI,rI")
+	(intcmpcc:BI (match_operand:SI 0 "reg_or_0_operand"   "rO,rO")
 		     (match_operand:SI 1 "reg_or_s16_operand" "r,M")))]
   ""
   "@
@@ -431,16 +431,16 @@
 (define_insn "*cmov<I:mode>_positive"
   [(set (match_operand:I 0 "register_operand" "=r")
 	(if_then_else:I (ne (reg:BI SR_F_REGNUM) (const_int 0))
-		      (match_operand:I 1 "reg_or_0_operand" "rI")
-		      (match_operand:I 2 "reg_or_0_operand" "rI")))]
+		      (match_operand:I 1 "reg_or_0_operand" "rO")
+		      (match_operand:I 2 "reg_or_0_operand" "rO")))]
   ""
   "l.cmov\t%0, %r1, %r2")
 
 (define_insn "*cmov<I:mode>_negative"
   [(set (match_operand:I 0 "register_operand" "=r")
 	(if_then_else:I (eq (reg:BI SR_F_REGNUM) (const_int 0))
-		      (match_operand:I 1 "reg_or_0_operand" "rI")
-		      (match_operand:I 2 "reg_or_0_operand" "rI")))]
+		      (match_operand:I 1 "reg_or_0_operand" "rO")
+		      (match_operand:I 2 "reg_or_0_operand" "rO")))]
   ""
   "l.cmov\t%0, %r2, %r1")
 
-- 
2.18.0


From 4f9ea289bdc088cd7f12f77ed14a3b59b869988f Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 20 May 2018 20:31:05 -0700
Subject: [PATCH 071/108] or1k: Rename s16 constraint to I

In addition to matching the old compiler,
this matches the ISA document.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/constraints.md | 12 ++++++------
 gcc/config/or1k/or1k.c         |  2 +-
 gcc/config/or1k/or1k.md        | 14 +++++++-------
 3 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/gcc/config/or1k/constraints.md b/gcc/config/or1k/constraints.md
index d6002b71497..0d3a7649f1b 100644
--- a/gcc/config/or1k/constraints.md
+++ b/gcc/config/or1k/constraints.md
@@ -24,10 +24,10 @@
 
 ; We use:
 ;  c - sibcall registers
+;  I - constant signed 16-bit
 ;  J - constant unsigned 16-bit
 ;  K - constant signed 16-bit shifted left 16-bits (l.movhi)
 ;  L - constant signed 26-bit (l.jal)
-;  M - constant signed 16-bit
 ;  O - constant zero
 
 (define_register_constraint "c" "SIBCALL_REGS"
@@ -41,6 +41,11 @@
 					       XEXP (op, 0), false)")))
 
 ;; Immediates
+(define_constraint "I"
+  "A signed 16-bit immediate in the range -32768 to 32767."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, -32768, 32767)")))
+
 (define_constraint "J"
   "An unsigned 16-bit immediate in the range 0 to 0xffff."
   (and (match_code "const_int")
@@ -57,11 +62,6 @@
   (and (match_code "const_int")
        (match_test "IN_RANGE (ival, -33554432, 33554431)")))
 
-(define_constraint "M"
-  "A signed 16-bit immediate in the range -32768 to 32767."
-  (and (match_code "const_int")
-       (match_test "IN_RANGE (ival, -32768, 32767)")))
-
 (define_constraint "O"
   "The constant zero"
   (and (match_code "const_int")
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 357172cecc0..8d27e97d10c 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -458,7 +458,7 @@ or1k_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,
 {
   if (GET_CODE(x) == PLUS
       && REG_P (XEXP (x, 0))
-      && satisfies_constraint_M (XEXP (x, 1)))
+      && satisfies_constraint_I (XEXP (x, 1)))
     return true;
 
   if (REG_P (x))
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index ad6f386f3a5..705eeb1d115 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -83,7 +83,7 @@
   [(set (match_operand:SI 0 "register_operand" "=r,r")
 	  (plus:SI
 	   (match_operand:SI 1 "register_operand"   "%r,r")
-	   (match_operand:SI 2 "reg_or_s16_operand" " r,M")))]
+	   (match_operand:SI 2 "reg_or_s16_operand" " r,I")))]
   ""
   "@
   l.add\t%0, %1, %2
@@ -93,7 +93,7 @@
   [(set (match_operand:SI 0 "register_operand" "=r,r")
 	  (mult:SI
 	   (match_operand:SI 1 "register_operand"   "%r,r")
-	   (match_operand:SI 2 "reg_or_s16_operand" " r,M")))]
+	   (match_operand:SI 2 "reg_or_s16_operand" " r,I")))]
   ""
   "@
   l.mul\t%0, %1, %2
@@ -156,7 +156,7 @@
   [(set (match_operand:SI 0 "register_operand" "=r,r")
 	  (xor:SI
 	   (match_operand:SI 1 "register_operand"   "%r,r")
-	   (match_operand:SI 2 "reg_or_s16_operand" " r,M")))]
+	   (match_operand:SI 2 "reg_or_s16_operand" " r,I")))]
   ""
   "@
   l.xor\t%0, %1, %2
@@ -205,9 +205,9 @@
       /* Constants smaller than SImode can be loaded directly.
          Otherwise, check to see if it requires splitting.  */
       if (<MODE>mode == SImode
+	  && !satisfies_constraint_I (op1)
 	  && !satisfies_constraint_J (op1)
-	  && !satisfies_constraint_K (op1)
-	  && !satisfies_constraint_M (op1))
+	  && !satisfies_constraint_K (op1))
 	{
           HOST_WIDE_INT i = INTVAL (op1);
           HOST_WIDE_INT lo = i & 0xffff;
@@ -256,7 +256,7 @@
 
 (define_insn "*mov<I:mode>_internal"
   [(set (match_operand:I 0 "nonimmediate_operand" "=r,r,r,r,m,r")
-	(match_operand:I 1 "or1k_mov_operand"      "r,K,J,M,rO,m"))]
+	(match_operand:I 1 "or1k_mov_operand"      "r,K,J,I,rO,m"))]
   "register_operand (operands[0], <I:MODE>mode)
    || reg_or_0_operand (operands[1], <I:MODE>mode)"
   "@
@@ -392,7 +392,7 @@
 (define_insn "*sf_insn"
   [(set (reg:BI SR_F_REGNUM)
 	(intcmpcc:BI (match_operand:SI 0 "reg_or_0_operand"   "rO,rO")
-		     (match_operand:SI 1 "reg_or_s16_operand" "r,M")))]
+		     (match_operand:SI 1 "reg_or_s16_operand" "r,I")))]
   ""
   "@
    l.sf<insn>\t%r0, %1
-- 
2.18.0


From f4b08081aa27e7ec9eae709ed54edd3632f76fc2 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 20 May 2018 20:33:39 -0700
Subject: [PATCH 072/108] or1k: Remove unused L constraint

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/constraints.md | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/gcc/config/or1k/constraints.md b/gcc/config/or1k/constraints.md
index 0d3a7649f1b..adf77ec9535 100644
--- a/gcc/config/or1k/constraints.md
+++ b/gcc/config/or1k/constraints.md
@@ -27,7 +27,6 @@
 ;  I - constant signed 16-bit
 ;  J - constant unsigned 16-bit
 ;  K - constant signed 16-bit shifted left 16-bits (l.movhi)
-;  L - constant signed 26-bit (l.jal)
 ;  O - constant zero
 
 (define_register_constraint "c" "SIBCALL_REGS"
@@ -57,11 +56,6 @@
        (match_test "(ival & 0xffff) == 0
                     && (ival >> 31 == -1 || ival >> 31 == 0)")))
 
-(define_constraint "L"
-  "A signed 26-bit constant suitable for l.jal."
-  (and (match_code "const_int")
-       (match_test "IN_RANGE (ival, -33554432, 33554431)")))
-
 (define_constraint "O"
   "The constant zero"
   (and (match_code "const_int")
-- 
2.18.0


From b96a2710853ac7401f5a032bca9575a6b7a0a358 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 20 May 2018 20:36:02 -0700
Subject: [PATCH 073/108] or1k: Rename movhi constraint to M

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/constraints.md | 4 ++--
 gcc/config/or1k/or1k.md        | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/gcc/config/or1k/constraints.md b/gcc/config/or1k/constraints.md
index adf77ec9535..a1af88e407f 100644
--- a/gcc/config/or1k/constraints.md
+++ b/gcc/config/or1k/constraints.md
@@ -26,7 +26,7 @@
 ;  c - sibcall registers
 ;  I - constant signed 16-bit
 ;  J - constant unsigned 16-bit
-;  K - constant signed 16-bit shifted left 16-bits (l.movhi)
+;  M - constant signed 16-bit shifted left 16-bits (l.movhi)
 ;  O - constant zero
 
 (define_register_constraint "c" "SIBCALL_REGS"
@@ -50,7 +50,7 @@
   (and (match_code "const_int")
        (match_test "IN_RANGE (ival, 0, 65535)")))
 
-(define_constraint "K"
+(define_constraint "M"
   "A shifted signed 16-bit constant suitable for l.movhi."
   (and (match_code "const_int")
        (match_test "(ival & 0xffff) == 0
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 705eeb1d115..cf36350d999 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -207,7 +207,7 @@
       if (<MODE>mode == SImode
 	  && !satisfies_constraint_I (op1)
 	  && !satisfies_constraint_J (op1)
-	  && !satisfies_constraint_K (op1))
+	  && !satisfies_constraint_M (op1))
 	{
           HOST_WIDE_INT i = INTVAL (op1);
           HOST_WIDE_INT lo = i & 0xffff;
@@ -256,7 +256,7 @@
 
 (define_insn "*mov<I:mode>_internal"
   [(set (match_operand:I 0 "nonimmediate_operand" "=r,r,r,r,m,r")
-	(match_operand:I 1 "or1k_mov_operand"      "r,K,J,I,rO,m"))]
+	(match_operand:I 1 "or1k_mov_operand"      "r,M,J,I,rO,m"))]
   "register_operand (operands[0], <I:MODE>mode)
    || reg_or_0_operand (operands[1], <I:MODE>mode)"
   "@
-- 
2.18.0


From 4a61e16fc82e49cc4f9e1c34bad6e9ec8deebabb Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 20 May 2018 20:40:33 -0700
Subject: [PATCH 074/108] or1k: Rename u16 constraint to K

In addition to matching the old compiler,
this matches the ISA document.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/constraints.md | 4 ++--
 gcc/config/or1k/or1k.md        | 8 ++++----
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/gcc/config/or1k/constraints.md b/gcc/config/or1k/constraints.md
index a1af88e407f..3b6dc7211f3 100644
--- a/gcc/config/or1k/constraints.md
+++ b/gcc/config/or1k/constraints.md
@@ -25,7 +25,7 @@
 ; We use:
 ;  c - sibcall registers
 ;  I - constant signed 16-bit
-;  J - constant unsigned 16-bit
+;  K - constant unsigned 16-bit
 ;  M - constant signed 16-bit shifted left 16-bits (l.movhi)
 ;  O - constant zero
 
@@ -45,7 +45,7 @@
   (and (match_code "const_int")
        (match_test "IN_RANGE (ival, -32768, 32767)")))
 
-(define_constraint "J"
+(define_constraint "K"
   "An unsigned 16-bit immediate in the range 0 to 0xffff."
   (and (match_code "const_int")
        (match_test "IN_RANGE (ival, 0, 65535)")))
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index cf36350d999..67740b1d34c 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -146,7 +146,7 @@
   [(set (match_operand:SI 0 "register_operand" "=r,r")
 	  (and:SI
 	   (match_operand:SI 1 "register_operand"   "%r,r")
-	   (match_operand:SI 2 "reg_or_u16_operand" " r,J")))]
+	   (match_operand:SI 2 "reg_or_u16_operand" " r,K")))]
   ""
   "@
   l.and\t%0, %1, %2
@@ -166,7 +166,7 @@
   [(set (match_operand:SI 0 "register_operand" "=r,r")
 	  (ior:SI
 	   (match_operand:SI 1 "register_operand"   "%r,r")
-	   (match_operand:SI 2 "reg_or_u16_operand" " r,J")))]
+	   (match_operand:SI 2 "reg_or_u16_operand" " r,K")))]
   ""
   "@
   l.or\t%0, %1, %2
@@ -206,7 +206,7 @@
          Otherwise, check to see if it requires splitting.  */
       if (<MODE>mode == SImode
 	  && !satisfies_constraint_I (op1)
-	  && !satisfies_constraint_J (op1)
+	  && !satisfies_constraint_K (op1)
 	  && !satisfies_constraint_M (op1))
 	{
           HOST_WIDE_INT i = INTVAL (op1);
@@ -256,7 +256,7 @@
 
 (define_insn "*mov<I:mode>_internal"
   [(set (match_operand:I 0 "nonimmediate_operand" "=r,r,r,r,m,r")
-	(match_operand:I 1 "or1k_mov_operand"      "r,M,J,I,rO,m"))]
+	(match_operand:I 1 "or1k_mov_operand"      "r,M,K,I,rO,m"))]
   "register_operand (operands[0], <I:MODE>mode)
    || reg_or_0_operand (operands[1], <I:MODE>mode)"
   "@
-- 
2.18.0


From 38bd1a0e516166cb9ca1d63739d9d04bce518e0b Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 20 May 2018 20:06:45 -0700
Subject: [PATCH 075/108] or1k: Tidy or1k_legitimate_address_p

Note that REGNO_OK_FOR_BASE_P is now only used from addresses.h,
which takes care of reg_renumber for us.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/constraints.md |  7 ------
 gcc/config/or1k/or1k-protos.h  |  1 -
 gcc/config/or1k/or1k.c         | 43 ++++++++++++++++++++++++++--------
 gcc/config/or1k/or1k.h         |  3 +--
 4 files changed, 34 insertions(+), 20 deletions(-)

diff --git a/gcc/config/or1k/constraints.md b/gcc/config/or1k/constraints.md
index 3b6dc7211f3..aa321bc0f86 100644
--- a/gcc/config/or1k/constraints.md
+++ b/gcc/config/or1k/constraints.md
@@ -32,13 +32,6 @@
 (define_register_constraint "c" "SIBCALL_REGS"
   "Registers which can hold a sibling call address")
 
-;; Memory
-(define_constraint "W"
-  "A register indirect memory operand."
-  (and (match_code "mem")
-       (match_test "or1k_legitimate_address_p (GET_MODE (op),
-					       XEXP (op, 0), false)")))
-
 ;; Immediates
 (define_constraint "I"
   "A signed 16-bit immediate in the range -32768 to 32767."
diff --git a/gcc/config/or1k/or1k-protos.h b/gcc/config/or1k/or1k-protos.h
index cb33b80f150..6bab3b15c5b 100644
--- a/gcc/config/or1k/or1k-protos.h
+++ b/gcc/config/or1k/or1k-protos.h
@@ -17,7 +17,6 @@ You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
-extern bool or1k_legitimate_address_p (machine_mode, rtx, bool);
 extern int  or1k_initial_elimination_offset (int, int);
 extern void or1k_expand_prologue (void);
 extern void or1k_expand_epilogue (void);
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 8d27e97d10c..c816be32b04 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -452,19 +452,42 @@ or1k_initial_elimination_offset (int from, int to)
 
 /* Worker function for TARGET_LEGITIMATE_ADDRESS_P.  */
 
-bool
-or1k_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,
-			   rtx x, bool strict_p ATTRIBUTE_UNUSED)
+static bool
+or1k_legitimate_address_p (machine_mode, rtx x, bool strict_p)
 {
-  if (GET_CODE(x) == PLUS
-      && REG_P (XEXP (x, 0))
-      && satisfies_constraint_I (XEXP (x, 1)))
-    return true;
+  rtx base, addend;
 
-  if (REG_P (x))
-    return true;
+  switch (GET_CODE (x))
+    {
+    case REG:
+      base = x;
+      break;
+
+    case PLUS:
+      base = XEXP (x, 0);
+      addend = XEXP (x, 1);
+      if (!REG_P (base))
+	return false;
+      if (!satisfies_constraint_I (addend))
+	return false;
+      break;
 
-  return false;
+    default:
+      return false;
+    }
+
+  unsigned regno = REGNO (base);
+  if (regno >= FIRST_PSEUDO_REGISTER)
+    {
+      if (strict_p)
+	regno = reg_renumber[regno];
+      else
+	return true;
+    }
+  if (strict_p)
+    return regno <= 31;
+  else
+    return REGNO_OK_FOR_BASE_P (regno);
 }
 
 /* Worker function for TARGET_PASS_BY_REFERENCE.  */
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 78d876b57c9..bd180e2b473 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -301,8 +301,7 @@ do {                                                    \
   } while (0)
 
 #define REGNO_OK_FOR_INDEX_P(REGNO) 0
-#define REGNO_OK_FOR_BASE_P(REGNO) \
-  ((REGNO) <= SFP_REGNUM || (unsigned int) reg_renumber[REGNO] < SFP_REGNUM)
+#define REGNO_OK_FOR_BASE_P(REGNO)  ((REGNO) <= SFP_REGNUM)
 
 /* If defined, the maximum amount of space required for outgoing
    arguments will be computed and placed into the variable
-- 
2.18.0


From d8be2a54d60ca38dacd46db0a73dd4009712eaba Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 20 May 2018 21:46:43 -0700
Subject: [PATCH 076/108] or1k: Allow any offset for frame_pointer_rtx and
 arg_pointer_rtx

Splitting these offsets early makes for poor code, because these
offsets will have to be modified by reload for register elimination.
The result will be optimized by post-reload-cse.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index c816be32b04..5ad1dfefdea 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -468,6 +468,10 @@ or1k_legitimate_address_p (machine_mode, rtx x, bool strict_p)
       addend = XEXP (x, 1);
       if (!REG_P (base))
 	return false;
+      /* Register elimination is going to adjust all of these offsets.
+	 We might as well keep them as a unit until then.  */
+      if (!strict_p && (base == arg_pointer_rtx || base == frame_pointer_rtx))
+	return CONST_INT_P (addend);
       if (!satisfies_constraint_I (addend))
 	return false;
       break;
-- 
2.18.0


From 7f64a6e1393a424da1d73c27539e542be361eed2 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Mon, 21 May 2018 09:34:50 -0700
Subject: [PATCH 077/108] or1k: Allow lo_sum as a memory address

This requires the updates to binutils to handle
the *_AHI and *_SLO16 relocation types.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k-protos.h |   1 +
 gcc/config/or1k/or1k.c        | 259 ++++++++++++++++++++++++++++++----
 gcc/config/or1k/or1k.md       |  75 ++--------
 gcc/config/or1k/predicates.md |  15 +-
 4 files changed, 246 insertions(+), 104 deletions(-)

diff --git a/gcc/config/or1k/or1k-protos.h b/gcc/config/or1k/or1k-protos.h
index 6bab3b15c5b..7ae2190e1b8 100644
--- a/gcc/config/or1k/or1k-protos.h
+++ b/gcc/config/or1k/or1k-protos.h
@@ -24,5 +24,6 @@ extern void or1k_expand_eh_return (rtx);
 extern rtx  or1k_initial_frame_addr (void);
 extern rtx  or1k_dynamic_chain_addr (rtx);
 extern rtx  or1k_return_addr (int, rtx);
+extern void or1k_expand_move (machine_mode, rtx, rtx);
 extern void or1k_expand_compare (rtx *);
 extern void or1k_expand_call (rtx, rtx, rtx, bool);
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 5ad1dfefdea..9e4622ecd7e 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -476,6 +476,25 @@ or1k_legitimate_address_p (machine_mode, rtx x, bool strict_p)
 	return false;
       break;
 
+    case LO_SUM:
+      base = XEXP (x, 0);
+      if (!REG_P (base))
+	return false;
+      x = XEXP (x, 1);
+      switch (GET_CODE (x))
+	{
+	case CONST:
+	case SYMBOL_REF:
+	case LABEL_REF:
+	  /* Assume legitimize_address properly categorized
+	     the symbol.  Continue to check the base.  */
+	  break;
+
+	default:
+	  return false;
+	}
+      break;
+
     default:
       return false;
     }
@@ -494,6 +513,84 @@ or1k_legitimate_address_p (machine_mode, rtx x, bool strict_p)
     return REGNO_OK_FOR_BASE_P (regno);
 }
 
+/* Worker function for TARGET_LEGITIMIZE_ADDRESS.  */
+
+static rtx
+or1k_legitimize_address_1 (rtx x, rtx scratch)
+{
+  rtx base, addend, t1, t2;
+
+  base = x;
+  addend = const0_rtx;
+  if (GET_CODE (x) == CONST)
+    base = XEXP (x, 0);
+  if (GET_CODE (base) == PLUS && CONST_INT_P (XEXP (base, 1)))
+    {
+      addend = XEXP (base, 1);
+      base = XEXP (base, 0);
+    }
+
+  switch (GET_CODE (base))
+    {
+    default:
+      gcc_assert (can_create_pseudo_p ());
+      base = force_reg (Pmode, base);
+      break;
+
+    case REG:
+    case SUBREG:
+      break;
+
+    case SYMBOL_REF:
+    case LABEL_REF:
+      t1 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;
+      emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, x)));
+      return gen_rtx_LO_SUM (Pmode, t1, x);
+
+    /*
+     * Re-recognize what we may have already emitted.
+     */
+
+    case LO_SUM:
+      gcc_assert (register_operand (XEXP (base, 0), Pmode));
+      if (addend == const0_rtx)
+	return base;
+
+      t1 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;
+      emit_insn (gen_rtx_SET (t1, base));
+      base = t1;
+      break;
+    }
+
+  /* If we get here, we still have addend outstanding.  */
+  gcc_checking_assert (register_operand (base, Pmode));
+  if (addend == const0_rtx)
+    return base;
+  if (satisfies_constraint_I (addend))
+    return gen_rtx_PLUS (Pmode, base, addend);
+  else
+    {
+      HOST_WIDE_INT i = INTVAL (addend);
+      HOST_WIDE_INT lo = sext_hwi (i, 16);
+      HOST_WIDE_INT hi = i - lo;
+
+      t1 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;
+      t2 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;
+      emit_move_insn (t1, gen_int_mode (hi, Pmode));
+      emit_insn (gen_add3_insn (t2, base, t1));
+      return plus_constant (Pmode, t2, lo);
+    }
+}
+
+static rtx
+or1k_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED, machine_mode)
+{
+  return or1k_legitimize_address_1 (x, NULL_RTX);
+}
+
+#undef  TARGET_LEGITIMIZE_ADDRESS
+#define TARGET_LEGITIMIZE_ADDRESS or1k_legitimize_address
+
 /* Worker function for TARGET_PASS_BY_REFERENCE.  */
 
 static bool
@@ -592,51 +689,100 @@ or1k_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
   return (size == -1 || size > (2 * UNITS_PER_WORD));
 }
 
+/* Print reloc(x + add).  */
+
+static void
+output_addr_reloc (FILE *stream, rtx x, HOST_WIDE_INT add, const char *reloc)
+{
+  if (*reloc)
+    {
+      fputs (reloc, stream);
+      fputc ('(', stream);
+    }
+  output_addr_const (stream, x);
+  if (add)
+    {
+      if (add > 0)
+	fputc ('+', stream);
+      fprintf (stream, HOST_WIDE_INT_PRINT_DEC, add);
+    }
+  if (*reloc)
+    fputc (')', stream);
+}
+
+enum reloc_kind
+{
+  RKIND_LO,
+  RKIND_HI,
+  RKIND_MAX
+};
+
+enum reloc_type
+{
+  RTYPE_DIRECT,
+  RTYPE_MAX
+};
+
+static void
+print_reloc (FILE *stream, rtx x, HOST_WIDE_INT add, reloc_kind kind)
+{
+  /* All data relocations.  A NULL in this table indicates a form that
+     we expect to never generate, while "" indicates a form that requires
+     no special markup.  */
+  static const char * const relocs[RKIND_MAX][RTYPE_MAX] = {
+    { "lo" },
+    { "ha" },
+  };
+  reloc_type type = RTYPE_DIRECT;
+
+  if (GET_CODE (x) == CONST)
+    x = XEXP (x, 0);
+
+  const char *reloc = relocs[kind][type];
+  if (reloc == NULL)
+    output_operand_lossage("invalid relocation");
+  else
+    output_addr_reloc (stream, x, add, reloc);
+}
+
 /* Worker function for TARGET_PRINT_OPERAND_ADDRESS.  */
 
 static void
-or1k_print_operand_address (FILE *file, machine_mode, rtx x)
+or1k_print_operand_address (FILE *file, machine_mode, rtx addr)
 {
-  switch (GET_CODE (x))
+  rtx offset;
+
+  switch (GET_CODE (addr))
     {
     case REG:
-      fprintf (file, "0(%s)", reg_names[REGNO (x)]);
+      fputc ('0', file);
       break;
 
     case PLUS:
-      switch (GET_CODE (XEXP (x, 1)))
+      offset = XEXP (addr, 1);
+      addr = XEXP (addr, 0);
+      gcc_assert (CONST_INT_P (offset));
+      if (GET_CODE (addr) == LO_SUM)
 	{
-	case CONST_INT:
-	  fprintf (file, "%ld(%s)",
-		   INTVAL(XEXP (x, 1)), reg_names[REGNO (XEXP (x, 0))]);
-	  break;
-	case SYMBOL_REF:
-	  output_addr_const (file, XEXP (x, 1));
-	  fprintf (file, "(%s)", reg_names[REGNO (XEXP (x, 0))]);
-	  break;
-	case CONST:
-	  {
-	    rtx plus = XEXP (XEXP (x, 1), 0);
-	    if (GET_CODE (XEXP (plus, 0)) == SYMBOL_REF
-		&& CONST_INT_P (XEXP (plus, 1)))
-	      {
-		output_addr_const(file, XEXP (plus, 0));
-		fprintf (file,"+%ld(%s)", INTVAL (XEXP (plus, 1)),
-			 reg_names[REGNO (XEXP (x, 0))]);
-	      }
-	    else
-	      abort();
-	  }
-	  break;
-	default:
-	  abort();
+	  print_reloc (file, XEXP (addr, 1), INTVAL (offset), RKIND_LO);
+	  addr = XEXP (addr, 0);
 	}
+      else
+	output_addr_const (file, offset);
       break;
 
-    default:
-      output_addr_const (file, x);
+    case LO_SUM:
+      offset = XEXP (addr, 1);
+      addr = XEXP (addr, 0);
+      print_reloc (file, offset, 0, RKIND_LO);
       break;
+
+    default:
+      output_addr_const (file, addr);
+      return;
     }
+
+  fprintf (file, "(%s)", reg_names[REGNO (addr)]);
 }
 
 /* Worker function for TARGET_PRINT_OPERAND.  */
@@ -663,6 +809,13 @@ or1k_print_operand (FILE *file, rtx x, int code)
 	output_operand_lossage ("invalid %%r value");
       break;
 
+    case 'H':
+      print_reloc (file, x, 0, RKIND_HI);
+      break;
+    case 'L':
+      print_reloc (file, x, 0, RKIND_LO);
+      break;
+
     case 0:
       /* Print an operand as without a modifier letter.  */
       switch (GET_CODE (operand))
@@ -785,6 +938,52 @@ or1k_can_change_mode_class (machine_mode from, machine_mode to,
 #undef TARGET_CAN_CHANGE_MODE_CLASS
 #define TARGET_CAN_CHANGE_MODE_CLASS or1k_can_change_mode_class
 
+void
+or1k_expand_move (machine_mode mode, rtx op0, rtx op1)
+{
+  if (MEM_P (op0))
+    {
+      if (!const0_operand(op1, mode))
+	op1 = force_reg (mode, op1);
+    }
+  else if (mode == QImode || mode == HImode)
+    {
+      /* ??? Maybe promote MEMs and CONST_INT to SImode,
+	 and then squish back with gen_lowpart.  */
+    }
+  else
+    {
+      switch (GET_CODE (op1))
+        {
+        case CONST_INT:
+	  if (!input_operand (op1, mode))
+	    {
+	      HOST_WIDE_INT i = INTVAL (op1);
+	      HOST_WIDE_INT lo = i & 0xffff;
+	      HOST_WIDE_INT hi = i ^ lo;
+	      rtx subtarget = op0;
+
+	      if (!cse_not_expected && can_create_pseudo_p ())
+		subtarget = gen_reg_rtx (SImode);
+	      emit_insn (gen_rtx_SET (subtarget, GEN_INT (hi)));
+	      emit_insn (gen_iorsi3 (op0, subtarget, GEN_INT (lo)));
+	      return;
+	    }
+	  break;
+
+	case CONST:
+	case SYMBOL_REF:
+	case LABEL_REF:
+	  op1 = or1k_legitimize_address_1 (op1, op0);
+	  break;
+
+	default:
+	  break;
+	}
+    }
+  emit_insn (gen_rtx_SET (op0, op1));
+}
+
 /* Expand a comparison in operands[0] .. operands[2], where
    [0] is the operator and [1],[2] are the operands.  Split out
    the compare into SR[F] and return a new operation in operands[0].  */
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 67740b1d34c..8bbd8f6c759 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -191,72 +191,15 @@
 	(match_operand:I 1 "general_operand" ""))]
   ""
 {
-  rtx op0 = operands[0];
-  rtx op1 = operands[1];
-  rtx subtarget = op0;
-  rtx offset = NULL;
-
-  if (MEM_P (op0) && !const0_operand(op1, <MODE>mode))
-    operands[1] = op1 = force_reg (<MODE>mode, op1);
-
-  switch (GET_CODE (op1))
-    {
-    case CONST_INT:
-      /* Constants smaller than SImode can be loaded directly.
-         Otherwise, check to see if it requires splitting.  */
-      if (<MODE>mode == SImode
-	  && !satisfies_constraint_I (op1)
-	  && !satisfies_constraint_K (op1)
-	  && !satisfies_constraint_M (op1))
-	{
-          HOST_WIDE_INT i = INTVAL (op1);
-          HOST_WIDE_INT lo = i & 0xffff;
-          HOST_WIDE_INT hi = i ^ lo;
-
-          if (!cse_not_expected && can_create_pseudo_p ())
-            subtarget = gen_reg_rtx (SImode);
-          emit_move_insn (subtarget, GEN_INT (hi));
-	  emit_insn (gen_iorsi3 (op0, subtarget, GEN_INT (lo)));
-	  DONE;
-	}
-      break;
-
-    case CONST:
-      if (GET_CODE (XEXP (op1, 0)) == PLUS
-          && CONST_INT_P (XEXP (XEXP (op1, 0), 1)))
-	{
-	  offset = XEXP (XEXP (op1, 0), 1);
-          op1 = XEXP (XEXP (op1, 0), 0);
-
-          if (!cse_not_expected && can_create_pseudo_p ())
-	    subtarget = gen_reg_rtx (Pmode);
-        }
-      /* fallthru */
-
-    case SYMBOL_REF:
-    case LABEL_REF:
-      emit_insn (gen_movsi_high (subtarget, op1));
-      emit_insn (gen_movsi_lo_sum (subtarget, subtarget, op1));
-
-      if (offset != NULL)
-	{
-	  subtarget = expand_simple_binop (Pmode, PLUS, subtarget, offset,
-                                           op0, 1, OPTAB_DIRECT);
-          if (subtarget != op0)
-	    emit_move_insn(op0, subtarget);
-	}
-      DONE;
-
-    default:
-      break;
-    }
+  or1k_expand_move (<MODE>mode, operands[0], operands[1]);
+  DONE;
 })
 
 ;; 8-bit, 16-bit and 32-bit moves
 
 (define_insn "*mov<I:mode>_internal"
-  [(set (match_operand:I 0 "nonimmediate_operand" "=r,r,r,r,m,r")
-	(match_operand:I 1 "or1k_mov_operand"      "r,M,K,I,rO,m"))]
+  [(set (match_operand:I 0 "nonimmediate_operand" "=r,r,r,r, m,r")
+	(match_operand:I 1 "input_operand"        " r,M,K,I,rO,m"))]
   "register_operand (operands[0], <I:MODE>mode)
    || reg_or_0_operand (operands[1], <I:MODE>mode)"
   "@
@@ -272,17 +215,17 @@
 
 (define_insn "movsi_high"
   [(set (match_operand:SI 0 "register_operand" "=r")
-	(high:SI (match_operand:SI 1 "or1k_hilo_operand" "i")))]
+	(high:SI (match_operand:SI 1 "immediate_operand" "i")))]
   ""
-  "l.movhi\t%0, hi(%1)"
+  "l.movhi\t%0, %H1"
   [(set_attr "type" "alu")])
 
-(define_insn "movsi_lo_sum"
+(define_insn "*movsi_lo_sum_addi"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(lo_sum:SI (match_operand:SI 1 "register_operand"  "r")
-		   (match_operand:SI 2 "or1k_hilo_operand" "i")))]
+		   (match_operand:SI 2 "immediate_operand" "i")))]
   ""
-  "l.ori\t%0, %1, lo(%2)"
+  "l.addi\t%0, %1, %L2"
   [(set_attr "type" "alu")])
 
 ;; 64-bit moves
diff --git a/gcc/config/or1k/predicates.md b/gcc/config/or1k/predicates.md
index 1de2e850062..74c7dafa6a4 100644
--- a/gcc/config/or1k/predicates.md
+++ b/gcc/config/or1k/predicates.md
@@ -22,14 +22,13 @@
 ;; Predicates
 ;; -------------------------------------------------------------------------
 
-(define_predicate "or1k_mov_operand"
-  (and (match_code "reg,subreg,mem,const,const_int,const_poly_int")
-       (ior (match_operand 0 "register_operand")
-	    (ior (match_operand 0 "memory_operand")
-		 (match_operand 0 "const_int_operand")))))
-
-(define_predicate "or1k_hilo_operand"
-  (match_code "symbol_ref,label_ref,const_int"))
+(define_predicate "input_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "memory_operand")
+       (and (match_code "const_int")
+	    (match_test "satisfies_constraint_I (op)
+			 || satisfies_constraint_K (op)
+			 || satisfies_constraint_M (op)"))))
 
 (define_predicate "const0_operand"
   (and (match_code "const_int,const_wide_int,const_double,const_vector")
-- 
2.18.0


From bcd25de553a2910b32d1bfa6e37575f513d842f1 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Mon, 21 May 2018 13:47:58 -0700
Subject: [PATCH 078/108] or1k: Use unsigned for wchar_t

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.h | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index bd180e2b473..d095b90dd09 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -62,6 +62,7 @@
 #define FLOAT_TYPE_SIZE 32
 #define DOUBLE_TYPE_SIZE 64
 #define LONG_DOUBLE_TYPE_SIZE 64
+#define WCHAR_TYPE_SIZE	32
 
 #undef SIZE_TYPE
 #define SIZE_TYPE "unsigned int"
@@ -69,6 +70,9 @@
 #undef PTRDIFF_TYPE
 #define PTRDIFF_TYPE "int"
 
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "unsigned int"
+
 /* Describing Relative Costs of Operations.  */
 #define MOVE_MAX 4
 #define SLOW_BYTE_ACCESS 1
-- 
2.18.0


From f985c091765cfd1e0b9c17c3795cfbea94f3523c Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Mon, 21 May 2018 16:09:04 -0700
Subject: [PATCH 079/108] or1k: Introduce or1k/linux.h

This has the proper LINK_SPEC for linux.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config.gcc          |  1 +
 gcc/config/or1k/linux.h | 46 +++++++++++++++++++++++++++++++++++++++++
 2 files changed, 47 insertions(+)
 create mode 100644 gcc/config/or1k/linux.h

diff --git a/gcc/config.gcc b/gcc/config.gcc
index cc7bbbc6cd6..908cc04fa10 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -2383,6 +2383,7 @@ or1k*-*-*)
         case ${target} in
         or1k*-*-linux*)
                 tm_file="${tm_file} gnu-user.h linux.h glibc-stdint.h"
+                tm_file="${tm_file} or1k/linux.h"
                 ;;
 	or1k*-*-elf*)
 		tm_file="${tm_file} newlib-stdint.h or1k/elf.h"
diff --git a/gcc/config/or1k/linux.h b/gcc/config/or1k/linux.h
new file mode 100644
index 00000000000..87725edeb62
--- /dev/null
+++ b/gcc/config/or1k/linux.h
@@ -0,0 +1,46 @@
+/* Linux Definitions for OpenRISC.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   Contributed by Stafford Horne.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_OR1K_LINUX_H
+#define GCC_OR1K_LINUX_H
+
+/* elfos.h should have already been included.  Now just override
+   any conflicting definitions and add any extras.  */
+
+#define NO_IMPLICIT_EXTERN_C
+
+#define TARGET_OS_CPP_BUILTINS() \
+  GNU_USER_TARGET_OS_CPP_BUILTINS ()
+
+#define GLIBC_DYNAMIC_LINKER "/lib/ld.so.1"
+
+#undef MUSL_DYNAMIC_LINKER
+#define MUSL_DYNAMIC_LINKER  "/lib/ld.so.1"
+
+#undef LINK_SPEC
+#define LINK_SPEC "%{h*}			\
+   %{static:-Bstatic}				\
+   %{shared:-shared}				\
+   %{symbolic:-Bsymbolic}			\
+   %{!static:					\
+     %{rdynamic:-export-dynamic}		\
+     %{!shared:-dynamic-linker " GNU_USER_DYNAMIC_LINKER "}}"
+
+#endif /* GCC_OR1K_LINUX_H */
-- 
2.18.0


From f4745acaee2582bd58c44e7ec50c7baa3d90d1eb Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Mon, 21 May 2018 16:09:10 -0700
Subject: [PATCH 080/108] or1k: Extend LINK_SPEC for or1k-elf

While newlib doesn't do shared libraries, there's no reason
not to pass the usual set of linker options through.  This
could be useful to someone building some custom software.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/elf.h | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/gcc/config/or1k/elf.h b/gcc/config/or1k/elf.h
index 0bb1662b179..ee0da0c499b 100644
--- a/gcc/config/or1k/elf.h
+++ b/gcc/config/or1k/elf.h
@@ -26,7 +26,12 @@
   "%{mboard=*:-lboard-%*; :-lboard-or1ksim} --end-group"
 
 #undef	LINK_SPEC
-#define	LINK_SPEC "--entry=0x100"
+#define LINK_SPEC "%{h*}			\
+   %{static:-Bstatic}				\
+   %{shared:-shared}				\
+   %{symbolic:-Bsymbolic}			\
+   %{!static:%{rdynamic:-export-dynamic}}	\
+   --entry=0x100"
 
 #undef  STARTFILE_SPEC
 #define STARTFILE_SPEC "crt0.o%s crtbegin.o%s crti.o%s"
-- 
2.18.0


From 804e2aec6c65ff7e22b71dc213b4eb28ab606b27 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Mon, 21 May 2018 13:43:47 -0700
Subject: [PATCH 081/108] or1k: Add insn type multi

Prevent it from being in a delay slot.
Use it for asm statements.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.md | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 8bbd8f6c759..b2b30e49aca 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -44,9 +44,13 @@
 (define_attr "length" "" (const_int 4))
 
 (define_attr "type"
-  "alu,st,ld,control"
+  "alu,st,ld,control,multi"
   (const_string "alu"))
 
+;; Describe a user's asm statement.
+(define_asm_attributes
+  [(set_attr "type" "multi")])
+
 (define_automaton "or1k")
 (define_cpu_unit "cpu" "or1k")
 (define_insn_reservation "alu" 1
@@ -64,7 +68,7 @@
 
 ; Define delay slots for any branch
 (define_delay (eq_attr "type" "control")
-  [(eq_attr "type" "!control") (nil) (nil)])
+  [(eq_attr "type" "alu,st,ld") (nil) (nil)])
 
 ;; -------------------------------------------------------------------------
 ;; nop instruction
-- 
2.18.0


From 167253dce8dc97d19966106b69aab827f1df9587 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Mon, 21 May 2018 19:13:08 -0700
Subject: [PATCH 082/108] or1k: Add TARGET_RTX_COSTS

Of particular note is how this is used by CSE wrt addresses.
Costing legitimate addresses as 0 is required to convince CSE
to replicate address portions into the memory address.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c | 66 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 66 insertions(+)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 9e4622ecd7e..b9bc68a3c02 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -1067,6 +1067,72 @@ or1k_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,
 #undef TARGET_FUNCTION_OK_FOR_SIBCALL
 #define TARGET_FUNCTION_OK_FOR_SIBCALL or1k_function_ok_for_sibcall
 
+/* Worker for TARGET_RTX_COSTS.  */
+
+static bool
+or1k_rtx_costs (rtx x, machine_mode mode, int outer_code,
+		int opno ATTRIBUTE_UNUSED, int *total,
+		bool speed ATTRIBUTE_UNUSED)
+{
+  switch (GET_CODE (x))
+    {
+    case CONST_INT:
+      if (x == const0_rtx)
+	*total = 0;
+      else if ((outer_code == PLUS || outer_code == XOR || outer_code == MULT)
+	       && satisfies_constraint_I (x))
+	*total = 0;
+      else if ((outer_code == AND || outer_code == IOR)
+	       && satisfies_constraint_K (x))
+	*total = 0;
+      else if (satisfies_constraint_I (x)
+	       || satisfies_constraint_K (x)
+	       || satisfies_constraint_M (x))
+	*total = 2;
+      else
+	*total = COSTS_N_INSNS (2);
+      return true;
+
+    case CONST_DOUBLE:
+      *total = (x == CONST0_RTX (mode) ? 0 : COSTS_N_INSNS (2));
+      return true;
+
+    case HIGH:
+      /* This is effectively an 'M' constraint.  */
+      *total = 2;
+      return true;
+
+    case LO_SUM:
+      /* This is effectively an 'I' constraint.  */
+      *total = (outer_code == MEM ? 0 : 2);
+      return true;
+
+    case CONST:
+    case SYMBOL_REF:
+    case LABEL_REF:
+      if (outer_code == LO_SUM || outer_code == HIGH)
+	*total = 0;
+      else
+	{
+	  /* ??? Extra cost for GOT or TLS symbols.  */
+	  *total = COSTS_N_INSNS (1 + (outer_code != MEM));
+	}
+      return true;
+
+    case PLUS:
+      if (outer_code == MEM)
+	*total = 0;
+      break;
+
+    default:
+      break;
+    }
+  return false;
+}
+
+#undef TARGET_RTX_COSTS
+#define TARGET_RTX_COSTS or1k_rtx_costs
+
 #undef TARGET_OPTION_OVERRIDE
 #define TARGET_OPTION_OVERRIDE or1k_option_override
 
-- 
2.18.0


From af113344dd17b0eef2e95c1c2167fa23ececb805 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Mon, 21 May 2018 19:16:21 -0700
Subject: [PATCH 083/108] or1k: Add NO_FUNCTION_CSE

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.h | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index d095b90dd09..495b3581943 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -344,6 +344,9 @@ do {                                                    \
 #define DYNAMIC_CHAIN_ADDRESS      or1k_dynamic_chain_addr
 #define RETURN_ADDR_RTX            or1k_return_addr
 
+/* Always pass the SYMBOL_REF for direct calls to the expanders.  */
+#define NO_FUNCTION_CSE 1
+
 /* Profiling */
 #define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)
 
-- 
2.18.0


From ea5a142765b2efbefe392f529e4c3489e284d9cd Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Mon, 21 May 2018 20:34:11 -0700
Subject: [PATCH 084/108] or1k: Enable section anchors

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/common/config/or1k/or1k-common.c | 41 ++++++++++++++++++++++++++++
 gcc/config.gcc                       |  1 -
 gcc/config/or1k/or1k.c               |  5 ++++
 3 files changed, 46 insertions(+), 1 deletion(-)
 create mode 100644 gcc/common/config/or1k/or1k-common.c

diff --git a/gcc/common/config/or1k/or1k-common.c b/gcc/common/config/or1k/or1k-common.c
new file mode 100644
index 00000000000..044e843fd19
--- /dev/null
+++ b/gcc/common/config/or1k/or1k-common.c
@@ -0,0 +1,41 @@
+/* Common hooks for OpenRISC
+   Copyright (C) 2018 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "diagnostic-core.h"
+#include "tm.h"
+#include "common/common-target.h"
+#include "common/common-target-def.h"
+#include "opts.h"
+#include "flags.h"
+
+/* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */
+static const struct default_options or1k_option_optimization_table[] =
+  {
+    /* Enable section anchors by default at -O1 or higher.  */
+    { OPT_LEVELS_1_PLUS, OPT_fsection_anchors, NULL, 1 },
+    { OPT_LEVELS_NONE, 0, NULL, 0 }
+  };
+
+#undef TARGET_OPTION_OPTIMIZATION_TABLE
+#define TARGET_OPTION_OPTIMIZATION_TABLE or1k_option_optimization_table
+
+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 908cc04fa10..05b190bad82 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -457,7 +457,6 @@ nvptx-*-*)
 	;;
 or1k*-*-*)
 	cpu_type=or1k
-	target_has_targetm_common=no
 	;;
 powerpc*-*-*spe*)
 	cpu_type=powerpcspe
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index b9bc68a3c02..c3629972e44 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -1168,6 +1168,11 @@ or1k_rtx_costs (rtx x, machine_mode mode, int outer_code,
 #undef  TARGET_PRINT_OPERAND_ADDRESS
 #define TARGET_PRINT_OPERAND_ADDRESS or1k_print_operand_address
 
+/* Section anchor support.  */
+#undef  TARGET_MIN_ANCHOR_OFFSET
+#define TARGET_MIN_ANCHOR_OFFSET  -32768
+#undef  TARGET_MAX_ANCHOR_OFFSET
+#define TARGET_MAX_ANCHOR_OFFSET  32767
 
 struct gcc_target targetm = TARGET_INITIALIZER;
 
-- 
2.18.0


From 45299d14239f99addcc0bceadbf4d4e216864789 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Mon, 21 May 2018 11:33:40 -0700
Subject: [PATCH 085/108] or1k: Implement flag_pic

Uses the *_GOTOFF_AHI16 and *_GOTOFF_SLO16 relocations introduced
with the binutils updates.  Uses the generic pseudo pic register
support to allow leaf functions to place the pic register into a
call-clobbered register.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c        | 189 ++++++++++++++++++++++++++++------
 gcc/config/or1k/or1k.h        |  19 +++-
 gcc/config/or1k/or1k.md       |  50 +++++++--
 gcc/config/or1k/predicates.md |   6 ++
 4 files changed, 222 insertions(+), 42 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index c3629972e44..173e6f76f19 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -42,6 +42,7 @@
 #include "builtins.h"
 #include "optabs.h"
 #include "explow.h"
+#include "cfgrtl.h"
 
 /* These 4 are needed to allow using satisfies_constraint_J.  */
 #include "insn-config.h"
@@ -68,6 +69,9 @@ struct GTY(()) machine_function
    * and an optional frame pointer.
    * Used in expand_prologue () and expand_epilogue().  */
   HOST_WIDE_INT total_size;
+
+  /* Remember where the set_got_placeholder is located.  */
+  rtx_insn *set_got_insn;
 };
 
 /* Zero initialization is OK for all current fields.  */
@@ -190,7 +194,7 @@ or1k_expand_prologue (void)
 
   /* Early exit for frameless functions.  */
   if (sp_offset == 0)
-    return;
+    goto fini;
 
   /* Adjust the stack pointer.  For large stack offsets we will
      do this in multiple parts, before and after saving registers.  */
@@ -273,6 +277,18 @@ or1k_expand_prologue (void)
 	  while (sp_offset != 0);
 	}
     }
+
+ fini:
+  /* Fix up, or remove, the insn that initialized the pic register.  */
+  rtx_insn *set_got_insn = cfun->machine->set_got_insn;
+  if (crtl->uses_pic_offset_table)
+    {
+      rtx reg = SET_DEST (PATTERN (set_got_insn));
+      rtx_insn *insn = emit_insn_before (gen_set_got (reg), set_got_insn);
+      RTX_FRAME_RELATED_P (insn) = 1;
+      add_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL_RTX);
+    }
+  delete_insn (set_got_insn);
 }
 
 void
@@ -371,6 +387,29 @@ or1k_expand_epilogue (void)
   add_reg_note (insn, REG_CFA_DEF_CFA, stack_pointer_rtx);
 }
 
+/* Worker for TARGET_INIT_PIC_REG.  */
+
+static void
+or1k_init_pic_reg (void)
+{
+  start_sequence ();
+
+  cfun->machine->set_got_insn
+    = emit_insn (gen_set_got_tmp (pic_offset_table_rtx));
+
+  rtx_insn *seq = get_insns ();
+  end_sequence ();
+
+  edge entry_edge = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));
+  insert_insn_on_edge (seq, entry_edge);
+  commit_one_edge_insertion (entry_edge);
+}
+
+#undef TARGET_INIT_PIC_REG
+#define TARGET_INIT_PIC_REG  or1k_init_pic_reg
+#undef TARGET_USE_PSEUDO_PIC_REG
+#define TARGET_USE_PSEUDO_PIC_REG  hook_bool_void_true
+
 /* Worker for INITIAL_FRAME_ADDRESS_RTX.  */
 
 rtx
@@ -490,6 +529,19 @@ or1k_legitimate_address_p (machine_mode, rtx x, bool strict_p)
 	     the symbol.  Continue to check the base.  */
 	  break;
 
+	case UNSPEC:
+	  switch (XINT (x, 1))
+	    {
+	    case UNSPEC_GOT:
+	    case UNSPEC_GOTOFF:
+	      /* Assume legitimize_address properly categorized
+	         the symbol.  Continue to check the base.  */
+	      break;
+	    default:
+	      return false;
+	    }
+	  break;
+
 	default:
 	  return false;
 	}
@@ -513,23 +565,22 @@ or1k_legitimate_address_p (machine_mode, rtx x, bool strict_p)
     return REGNO_OK_FOR_BASE_P (regno);
 }
 
+/* Helper for or1k_legitimize_address_1.  Wrap X in an unspec.  */
+static rtx
+gen_sym_unspec (rtx x, int kind)
+{
+  return gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), kind);
+}
+
 /* Worker function for TARGET_LEGITIMIZE_ADDRESS.  */
 
 static rtx
 or1k_legitimize_address_1 (rtx x, rtx scratch)
 {
   rtx base, addend, t1, t2;
+  bool is_local = true;
 
-  base = x;
-  addend = const0_rtx;
-  if (GET_CODE (x) == CONST)
-    base = XEXP (x, 0);
-  if (GET_CODE (base) == PLUS && CONST_INT_P (XEXP (base, 1)))
-    {
-      addend = XEXP (base, 1);
-      base = XEXP (base, 0);
-    }
-
+  split_const(x, &base, &addend);
   switch (GET_CODE (base))
     {
     default:
@@ -542,24 +593,42 @@ or1k_legitimize_address_1 (rtx x, rtx scratch)
       break;
 
     case SYMBOL_REF:
+      is_local = SYMBOL_REF_LOCAL_P (base);
+      /* FALLTHRU */
+
     case LABEL_REF:
       t1 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;
-      emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, x)));
-      return gen_rtx_LO_SUM (Pmode, t1, x);
+      if (!flag_pic)
+	{
+          emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, x)));
+          return gen_rtx_LO_SUM (Pmode, t1, x);
+	}
+      else if (is_local)
+	{
+	  crtl->uses_pic_offset_table = 1;
+	  t2 = gen_sym_unspec (x, UNSPEC_GOTOFF);
+	  emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, t2)));
+	  emit_insn (gen_add3_insn (t1, t1, pic_offset_table_rtx));
+	  return gen_rtx_LO_SUM (Pmode, t1, copy_rtx (t2));
+	}
+      else
+	{
+	  base = gen_sym_unspec (base, UNSPEC_GOT);
+	  crtl->uses_pic_offset_table = 1;
+	  t2 = gen_rtx_LO_SUM (Pmode, pic_offset_table_rtx, base);
+	  t2 = gen_const_mem (Pmode, t2);
+	  emit_insn (gen_rtx_SET (t1, t2));
+	  base = t1;
+	}
+      break;
 
     /*
-     * Re-recognize what we may have already emitted.
+     * Accept what we may have already emitted.
      */
 
     case LO_SUM:
-      gcc_assert (register_operand (XEXP (base, 0), Pmode));
-      if (addend == const0_rtx)
-	return base;
-
-      t1 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;
-      emit_insn (gen_rtx_SET (t1, base));
-      base = t1;
-      break;
+    case UNSPEC:
+      return x;
     }
 
   /* If we get here, we still have addend outstanding.  */
@@ -591,6 +660,40 @@ or1k_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED, machine_mode)
 #undef  TARGET_LEGITIMIZE_ADDRESS
 #define TARGET_LEGITIMIZE_ADDRESS or1k_legitimize_address
 
+/* Worker for TARGET_DELEGITIMIZE_ADDRESS.
+   In the name of slightly smaller debug output, and to cater to
+   general assembler lossage, recognize PIC+GOTOFF and turn it back
+   into a direct symbol reference.  */
+
+static rtx
+or1k_delegitimize_address (rtx x)
+{
+  if (GET_CODE (x) == UNSPEC)
+    {
+      /* The LO_SUM to which X was attached has been stripped.
+	 Since the only legitimate address we could have been computing
+	 is that of the symbol, assume that's what we've done.  */
+      if (XINT (x, 1) == UNSPEC_GOTOFF)
+	return XVECEXP (x, 0, 0);
+    }
+  else if (MEM_P (x))
+    {
+      rtx addr = XEXP (x, 0);
+      if (GET_CODE (addr) == LO_SUM
+	  && XEXP (addr, 0) == pic_offset_table_rtx)
+	{
+	  rtx inner = XEXP (addr, 1);
+	  if (GET_CODE (inner) == UNSPEC
+	      && XINT (inner, 1) == UNSPEC_GOT)
+	    return XVECEXP (inner, 0, 0);
+	}
+    }
+  return delegitimize_mem_from_attrs (x);
+}
+
+#undef  TARGET_DELEGITIMIZE_ADDRESS
+#define TARGET_DELEGITIMIZE_ADDRESS or1k_delegitimize_address
+
 /* Worker function for TARGET_PASS_BY_REFERENCE.  */
 
 static bool
@@ -720,6 +823,8 @@ enum reloc_kind
 enum reloc_type
 {
   RTYPE_DIRECT,
+  RTYPE_GOT,
+  RTYPE_GOTOFF,
   RTYPE_MAX
 };
 
@@ -730,13 +835,27 @@ print_reloc (FILE *stream, rtx x, HOST_WIDE_INT add, reloc_kind kind)
      we expect to never generate, while "" indicates a form that requires
      no special markup.  */
   static const char * const relocs[RKIND_MAX][RTYPE_MAX] = {
-    { "lo" },
-    { "ha" },
+    { "lo", "got", "gotofflo" },
+    { "ha", NULL,  "gotoffha" },
   };
   reloc_type type = RTYPE_DIRECT;
 
-  if (GET_CODE (x) == CONST)
-    x = XEXP (x, 0);
+  if (GET_CODE (x) == UNSPEC)
+    {
+      switch (XINT (x, 1))
+	{
+	case UNSPEC_GOT:
+	  type = RTYPE_GOT;
+	  break;
+	case UNSPEC_GOTOFF:
+	  type = RTYPE_GOTOFF;
+	  break;
+	default:
+	  output_operand_lossage("invalid relocation");
+	  return;
+	}
+      x = XVECEXP (x, 0, 0);
+    }
 
   const char *reloc = relocs[kind][type];
   if (reloc == NULL)
@@ -815,6 +934,12 @@ or1k_print_operand (FILE *file, rtx x, int code)
     case 'L':
       print_reloc (file, x, 0, RKIND_LO);
       break;
+    case 'P':
+      if (!flag_pic || SYMBOL_REF_LOCAL_P (x))
+	output_addr_const (file, x);
+      else
+	output_addr_reloc (file, x, 0, "plt");
+      break;
 
     case 0:
       /* Print an operand as without a modifier letter.  */
@@ -1008,16 +1133,16 @@ or1k_expand_call (rtx retval, rtx fnaddr, rtx callarg1, bool sibcall)
 {
   rtx call, use = NULL;
 
-#if 0
   /* Calls via the PLT require the PIC register.  */
   if (flag_pic
       && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF
       && !SYMBOL_REF_LOCAL_P (XEXP (fnaddr, 0)))
     {
       crtl->uses_pic_offset_table = 1;
-      use_reg (&use, pic_offset_table_rtx);
+      rtx hard_pic = gen_rtx_REG (Pmode, REAL_PIC_OFFSET_TABLE_REGNUM);
+      emit_move_insn (hard_pic, pic_offset_table_rtx);
+      use_reg (&use, hard_pic);
     }
-#endif
 
   if (!call_insn_operand (XEXP (fnaddr, 0), Pmode))
     {
@@ -1048,7 +1173,6 @@ static bool
 or1k_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,
 			      tree exp ATTRIBUTE_UNUSED)
 {
-#if 0
   /* We can sibcall to any function if not PIC.  */
   if (!flag_pic)
     return true;
@@ -1058,10 +1182,7 @@ or1k_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,
     return true;
 
   /* If the call may go through the PLT, we need r16 live.  */
-  if (!targetm.binds_local_p (decl))
-    return false;
-#endif
-  return true;
+  return targetm.binds_local_p (decl);
 }
 
 #undef TARGET_FUNCTION_OK_FOR_SIBCALL
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 495b3581943..0ed0a12ab82 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -163,14 +163,21 @@
   1, 1, 1 }
 
 /* List the order in which to allocate registers.  Each register must
-   be listed once, even those in FIXED_REGISTERS.  */
+   be listed once, even those in FIXED_REGISTERS.
+
+   ??? Note that placing REAL_PIC_OFFSET_TABLE_REGNUM (r16 = 24) first
+   happens to make it most likely selected *as* the pic register when
+   compiling without optimization, simply because the pic pseudo happens
+   to be allocated with the lowest pseudo regno.  */
 
 #define REG_ALLOC_ORDER { \
   16, 17, 18, 19, 20, 21, 22, 23,	/* r17-r31 (odd), non-saved */	\
   13, 15,				/* non-saved */			\
   12, 11,				/* non-saved return values */	\
   8, 7, 6, 5, 4, 3,			/* non-saved argument regs */	\
-  14, 24, 25, 26, 27, 28, 29, 30, 31,	/* r14,r16-r31 (even), saved */	\
+  24,					/* r16, saved, pic reg */	\
+  25, 26, 27, 28, 29, 30, 31,		/* r18-r31 (even), saved */	\
+  14,					/* r14, saved */		\
   2,					/* saved hard frame pointer */	\
   9,					/* saved return address */	\
   0,					/* fixed zero reg */		\
@@ -282,6 +289,14 @@ do {                                                    \
    access the function's argument list.  */
 #define ARG_POINTER_REGNUM AP_REGNUM
 
+/* Position Independent Code.  See or1k_init_pic_reg.  */
+#define REAL_PIC_OFFSET_TABLE_REGNUM  HW_TO_GCC_REGNO (16)
+
+/* ??? Follow i386 in working around gimple costing estimation, which
+   happens without properly initializing the pic_offset_table pseudo.  */
+#define PIC_OFFSET_TABLE_REGNUM \
+  (pic_offset_table_rtx ? INVALID_REGNUM : REAL_PIC_OFFSET_TABLE_REGNUM)
+
 /* A C expression that is nonzero if REGNO is the number of a hard
    register in which function arguments are sometimes passed.  */
 #define FUNCTION_ARG_REGNO_P(r) (r >= 3 && r <= 8)
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index b2b30e49aca..a4f7bbb6984 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -38,6 +38,16 @@
    (SR_F_REGNUM    34)]
 )
 
+(define_c_enum "unspec" [
+  UNSPEC_SET_GOT
+  UNSPEC_GOT
+  UNSPEC_GOTOFF
+])
+
+(define_c_enum "unspecv" [
+  UNSPECV_SET_GOT
+])
+
 ;; Instruction scheduler
 
 ; Most instructions are 4 bytes long.
@@ -219,7 +229,7 @@
 
 (define_insn "movsi_high"
   [(set (match_operand:SI 0 "register_operand" "=r")
-	(high:SI (match_operand:SI 1 "immediate_operand" "i")))]
+	(high:SI (match_operand:SI 1 "high_operand" "")))]
   ""
   "l.movhi\t%0, %H1"
   [(set_attr "type" "alu")])
@@ -227,7 +237,7 @@
 (define_insn "*movsi_lo_sum_addi"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(lo_sum:SI (match_operand:SI 1 "register_operand"  "r")
-		   (match_operand:SI 2 "immediate_operand" "i")))]
+		   (match_operand:SI 2 "losum_add_operand" "")))]
   ""
   "l.addi\t%0, %1, %L2"
   [(set_attr "type" "alu")])
@@ -499,6 +509,34 @@
   DONE;
 })
 
+;; This is a placeholder, during RA, in order to create the PIC regiter.
+;; We do this so that we don't unconditionally mark the LR register as
+;; clobbered.  It is replaced during prologue generation with the proper
+;; set_got pattern below.  This works because the set_got_tmp insn is the
+;; first insn in the stream and that it isn't moved during RA.
+(define_insn "set_got_tmp"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec_volatile:SI [(const_int 0)] UNSPECV_SET_GOT))]
+  ""
+{
+  gcc_unreachable ();
+})
+
+;; The insn to initialize the GOT.
+(define_insn "set_got"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(const_int 0)] UNSPEC_SET_GOT))
+   (clobber (reg:SI LR_REGNUM))]
+  ""
+{
+  return ("l.jal\t8\;"
+	  " l.movhi\t%0, gotpchi(_GLOBAL_OFFSET_TABLE_-4)\;"
+	  "l.ori\t%0, %0, gotpclo(_GLOBAL_OFFSET_TABLE_+0)\;"
+	  "l.add\t%0, %0, r9");
+}
+  [(set_attr "length" "16")
+   (set_attr "type" "multi")])
+
 ;; -------------------------------------------------------------------------
 ;; Call Instructions
 ;; -------------------------------------------------------------------------
@@ -545,7 +583,7 @@
   "!SIBLING_CALL_P (insn)"
   "@
    l.jalr\t%0%#
-   l.jal\t%0%#"
+   l.jal\t%P0%#"
   [(set_attr "type" "control")])
 
 (define_insn "*sibcall"
@@ -554,7 +592,7 @@
   "SIBLING_CALL_P (insn)"
   "@
    l.jr\t%0%#
-   l.j\t%0%#"
+   l.j\t%P0%#"
   [(set_attr "type" "control")])
 
 (define_insn "*call_value"
@@ -565,7 +603,7 @@
   "!SIBLING_CALL_P (insn)"
   "@
    l.jalr\t%1%#
-   l.jal\t%1%#"
+   l.jal\t%P1%#"
   [(set_attr "type" "control")])
 
 (define_insn "*sibcall_value"
@@ -575,5 +613,5 @@
   "SIBLING_CALL_P (insn)"
   "@
    l.jr\t%1%#
-   l.j\t%1%#"
+   l.j\t%P1%#"
   [(set_attr "type" "control")])
diff --git a/gcc/config/or1k/predicates.md b/gcc/config/or1k/predicates.md
index 74c7dafa6a4..8a1eb1588fa 100644
--- a/gcc/config/or1k/predicates.md
+++ b/gcc/config/or1k/predicates.md
@@ -56,3 +56,9 @@
 (define_predicate "call_insn_operand"
   (ior (match_code "symbol_ref")
        (match_operand 0 "register_operand")))
+
+(define_predicate "high_operand"
+  (match_code "symbol_ref,label_ref,const,unspec"))
+
+(define_predicate "losum_add_operand"
+  (match_code "symbol_ref,label_ref,const,unspec"))
-- 
2.18.0


From 07c93f5379074f2e95332c81a0ab386f9b7029d3 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Mon, 21 May 2018 22:38:46 -0700
Subject: [PATCH 086/108] or1k: Implement TLS

Uses the *TPOFF_AHI16 and *TPOFF_SLO16 relocations introduced
with the binutils updates.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c        | 178 ++++++++++++++++++++++++++++++----
 gcc/config/or1k/or1k.md       |  11 +++
 gcc/config/or1k/predicates.md |   6 ++
 gcc/configure                 |  12 +++
 gcc/configure.ac              |  12 +++
 5 files changed, 199 insertions(+), 20 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 173e6f76f19..4adf0dcb4c3 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -534,6 +534,8 @@ or1k_legitimate_address_p (machine_mode, rtx x, bool strict_p)
 	    {
 	    case UNSPEC_GOT:
 	    case UNSPEC_GOTOFF:
+	    case UNSPEC_TPOFF:
+	    case UNSPEC_GOTTPOFF:
 	      /* Assume legitimize_address properly categorized
 	         the symbol.  Continue to check the base.  */
 	      break;
@@ -565,6 +567,39 @@ or1k_legitimate_address_p (machine_mode, rtx x, bool strict_p)
     return REGNO_OK_FOR_BASE_P (regno);
 }
 
+/* Return the TLS type for TLS symbols, 0 otherwise.  */
+
+tls_model
+or1k_tls_symbolic_operand (rtx op)
+{
+  rtx sym, addend;
+  split_const (op, &sym, &addend);
+  if (SYMBOL_REF_P (sym))
+    return SYMBOL_REF_TLS_MODEL (sym);
+  return TLS_MODEL_NONE;
+}
+
+/* Get a reference to the '__tls_get_addr' symbol.  */
+
+static GTY(()) rtx gen_tls_tga;
+
+static rtx
+gen_tls_get_addr (void)
+{
+  if (!gen_tls_tga)
+    gen_tls_tga = init_one_libfunc ("__tls_get_addr");
+  return gen_tls_tga;
+}
+
+/* Emit a call to '__tls_get_addr'.  */
+
+static void
+or1k_tls_call (rtx dest, rtx arg)
+{
+  emit_library_call_value (gen_tls_get_addr (), dest, LCT_CONST,
+			   Pmode, arg, Pmode);
+}
+
 /* Helper for or1k_legitimize_address_1.  Wrap X in an unspec.  */
 static rtx
 gen_sym_unspec (rtx x, int kind)
@@ -578,6 +613,7 @@ static rtx
 or1k_legitimize_address_1 (rtx x, rtx scratch)
 {
   rtx base, addend, t1, t2;
+  tls_model tls_kind = TLS_MODEL_NONE;
   bool is_local = true;
 
   split_const(x, &base, &addend);
@@ -593,32 +629,76 @@ or1k_legitimize_address_1 (rtx x, rtx scratch)
       break;
 
     case SYMBOL_REF:
+      tls_kind = SYMBOL_REF_TLS_MODEL (base);
       is_local = SYMBOL_REF_LOCAL_P (base);
       /* FALLTHRU */
 
     case LABEL_REF:
-      t1 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;
-      if (!flag_pic)
-	{
-          emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, x)));
-          return gen_rtx_LO_SUM (Pmode, t1, x);
-	}
-      else if (is_local)
+      switch (tls_kind)
 	{
+	case TLS_MODEL_NONE:
+	  t1 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;
+	  if (!flag_pic)
+	    {
+	      emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, x)));
+	      return gen_rtx_LO_SUM (Pmode, t1, x);
+	    }
+	  else if (is_local)
+	    {
+	      crtl->uses_pic_offset_table = 1;
+	      t2 = gen_sym_unspec (x, UNSPEC_GOTOFF);
+	      emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, t2)));
+	      emit_insn (gen_add3_insn (t1, t1, pic_offset_table_rtx));
+	      return gen_rtx_LO_SUM (Pmode, t1, copy_rtx (t2));
+	    }
+	  else
+	    {
+	      base = gen_sym_unspec (base, UNSPEC_GOT);
+	      crtl->uses_pic_offset_table = 1;
+	      t2 = gen_rtx_LO_SUM (Pmode, pic_offset_table_rtx, base);
+	      t2 = gen_const_mem (Pmode, t2);
+	      emit_insn (gen_rtx_SET (t1, t2));
+	      base = t1;
+	    }
+	  break;
+
+	case TLS_MODEL_GLOBAL_DYNAMIC:
+	case TLS_MODEL_LOCAL_DYNAMIC:
+	  /* TODO: For now, treat LD as GD.  */
+	  t1 = gen_reg_rtx (Pmode);
+	  base = gen_sym_unspec (base, UNSPEC_TLSGD);
+	  emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, base)));
+	  emit_insn (gen_rtx_SET (t1, gen_rtx_LO_SUM (Pmode, t1, base)));
 	  crtl->uses_pic_offset_table = 1;
-	  t2 = gen_sym_unspec (x, UNSPEC_GOTOFF);
-	  emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, t2)));
 	  emit_insn (gen_add3_insn (t1, t1, pic_offset_table_rtx));
-	  return gen_rtx_LO_SUM (Pmode, t1, copy_rtx (t2));
-	}
-      else
-	{
-	  base = gen_sym_unspec (base, UNSPEC_GOT);
+	  base = gen_reg_rtx (Pmode);
+	  or1k_tls_call (base, t1);
+	  break;
+
+	case TLS_MODEL_INITIAL_EXEC:
+	  t1 = gen_reg_rtx (Pmode);
+	  t2 = gen_reg_rtx (Pmode);
+	  base = gen_sym_unspec (base, UNSPEC_GOTTPOFF);
+	  emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, base)));
 	  crtl->uses_pic_offset_table = 1;
-	  t2 = gen_rtx_LO_SUM (Pmode, pic_offset_table_rtx, base);
-	  t2 = gen_const_mem (Pmode, t2);
-	  emit_insn (gen_rtx_SET (t1, t2));
-	  base = t1;
+	  emit_insn (gen_add3_insn (t1, t1, pic_offset_table_rtx));
+	  t1 = gen_rtx_LO_SUM (Pmode, t1, base);
+	  emit_move_insn (t2, gen_const_mem (Pmode, t1));
+	  t1 = gen_rtx_REG (Pmode, TLS_REGNUM);
+	  emit_insn (gen_add3_insn (t2, t2, t1));
+	  base = t2;
+	  break;
+
+	case TLS_MODEL_LOCAL_EXEC:
+	  x = gen_sym_unspec (x, UNSPEC_TPOFF);
+	  t1 = gen_reg_rtx (Pmode);
+	  emit_insn (gen_rtx_SET (t1, gen_rtx_HIGH (Pmode, x)));
+	  t2 = gen_rtx_REG (Pmode, TLS_REGNUM);
+	  emit_insn (gen_add3_insn (t1, t1, t2));
+	  return gen_rtx_LO_SUM (Pmode, t1, x);
+
+	default:
+	  gcc_unreachable ();
 	}
       break;
 
@@ -694,6 +774,49 @@ or1k_delegitimize_address (rtx x)
 #undef  TARGET_DELEGITIMIZE_ADDRESS
 #define TARGET_DELEGITIMIZE_ADDRESS or1k_delegitimize_address
 
+/* Worker for TARGET_CANNOT_FORCE_CONST_MEM.
+   Primarily this is required for TLS symbols, but given that our move
+   patterns *ought* to be able to handle any symbol at any time, we
+   should never be spilling symbolic operands to the constant pool, ever.  */
+
+static bool
+or1k_cannot_force_const_mem (machine_mode, rtx x)
+{
+  rtx_code code = GET_CODE (x);
+  return (code == SYMBOL_REF
+	  || code == LABEL_REF
+	  || code == CONST
+	  || code == HIGH);
+}
+
+#undef  TARGET_CANNOT_FORCE_CONST_MEM
+#define TARGET_CANNOT_FORCE_CONST_MEM or1k_cannot_force_const_mem
+
+static bool
+or1k_legitimate_constant_p (machine_mode, rtx x)
+{
+  switch (GET_CODE (x))
+    {
+    case CONST_INT:
+    case CONST_WIDE_INT:
+    case HIGH:
+      /* We construct these, rather than spilling to memory.  */
+      return true;
+
+    case CONST:
+    case SYMBOL_REF:
+    case LABEL_REF:
+      /* These may need to be split and not reconstructed.  */
+      return or1k_tls_symbolic_operand (x) == TLS_MODEL_NONE;
+
+    default:
+      return false;
+    }
+}
+
+#undef  TARGET_LEGITIMATE_CONSTANT_P
+#define TARGET_LEGITIMATE_CONSTANT_P or1k_legitimate_constant_p
+
 /* Worker function for TARGET_PASS_BY_REFERENCE.  */
 
 static bool
@@ -825,6 +948,9 @@ enum reloc_type
   RTYPE_DIRECT,
   RTYPE_GOT,
   RTYPE_GOTOFF,
+  RTYPE_TPOFF,
+  RTYPE_GOTTPOFF,
+  RTYPE_TLSGD,
   RTYPE_MAX
 };
 
@@ -835,8 +961,8 @@ print_reloc (FILE *stream, rtx x, HOST_WIDE_INT add, reloc_kind kind)
      we expect to never generate, while "" indicates a form that requires
      no special markup.  */
   static const char * const relocs[RKIND_MAX][RTYPE_MAX] = {
-    { "lo", "got", "gotofflo" },
-    { "ha", NULL,  "gotoffha" },
+    { "lo", "got", "gotofflo", "tpofflo", "gottpofflo", "tlsgdlo" },
+    { "ha", NULL,  "gotoffha", "tpoffha", "gottpoffha", "tlsgdhi" },
   };
   reloc_type type = RTYPE_DIRECT;
 
@@ -850,6 +976,15 @@ print_reloc (FILE *stream, rtx x, HOST_WIDE_INT add, reloc_kind kind)
 	case UNSPEC_GOTOFF:
 	  type = RTYPE_GOTOFF;
 	  break;
+	case UNSPEC_TPOFF:
+	  type = RTYPE_TPOFF;
+	  break;
+	case UNSPEC_GOTTPOFF:
+	  type = RTYPE_GOTTPOFF;
+	  break;
+	case UNSPEC_TLSGD:
+	  type = RTYPE_TLSGD;
+	  break;
 	default:
 	  output_operand_lossage("invalid relocation");
 	  return;
@@ -1263,6 +1398,9 @@ or1k_rtx_costs (rtx x, machine_mode mode, int outer_code,
 #undef TARGET_LEGITIMATE_ADDRESS_P
 #define TARGET_LEGITIMATE_ADDRESS_P or1k_legitimate_address_p
 
+#undef  TARGET_HAVE_TLS
+#define TARGET_HAVE_TLS true
+
 /* Calling Conventions.  */
 #undef TARGET_FUNCTION_VALUE
 #define TARGET_FUNCTION_VALUE or1k_function_value
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index a4f7bbb6984..7c05061c794 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -42,6 +42,9 @@
   UNSPEC_SET_GOT
   UNSPEC_GOT
   UNSPEC_GOTOFF
+  UNSPEC_TPOFF
+  UNSPEC_GOTTPOFF
+  UNSPEC_TLSGD
 ])
 
 (define_c_enum "unspecv" [
@@ -234,6 +237,14 @@
   "l.movhi\t%0, %H1"
   [(set_attr "type" "alu")])
 
+(define_insn "*movsi_lo_sum_iori"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lo_sum:SI (match_operand:SI 1 "register_operand"  "r")
+		   (match_operand:SI 2 "losum_ior_operand" "")))]
+  ""
+  "l.ori\t%0, %1, %L2"
+  [(set_attr "type" "alu")])
+
 (define_insn "*movsi_lo_sum_addi"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(lo_sum:SI (match_operand:SI 1 "register_operand"  "r")
diff --git a/gcc/config/or1k/predicates.md b/gcc/config/or1k/predicates.md
index 8a1eb1588fa..46e892163b0 100644
--- a/gcc/config/or1k/predicates.md
+++ b/gcc/config/or1k/predicates.md
@@ -60,5 +60,11 @@
 (define_predicate "high_operand"
   (match_code "symbol_ref,label_ref,const,unspec"))
 
+;; Return true for relocations that must use MOVHI+ADDI
 (define_predicate "losum_add_operand"
   (match_code "symbol_ref,label_ref,const,unspec"))
+
+;; Return true for relocations that must use MOVHI+ORI
+(define_predicate "losum_ior_operand"
+  (and (match_code "unspec")
+       (match_test "XINT(op, 1) == UNSPEC_TLSGD")))
diff --git a/gcc/configure b/gcc/configure
index 6121e163259..435fc00a4c1 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -24124,6 +24124,18 @@ foo:	.long	25
 	tls_first_minor=20
 	tls_as_opt='--fatal-warnings'
 	;;
+  or1k*-*-*)
+    conftest_s='
+        .section ".tdata","awT",@progbits
+foo:    .long   25
+        .text
+        l.movhi r3, tpoffha(foo)
+        l.add   r3, r3, r10
+        l.lwz   r4, tpofflo(foo)(r3)'
+    tls_first_major=2
+    tls_first_minor=30
+    tls_as_opt=--fatal-warnings
+    ;;
   powerpc-ibm-aix*)
     conftest_s='
 	.extern __get_tpointer
diff --git a/gcc/configure.ac b/gcc/configure.ac
index b066cc609e1..4b746fc3d66 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -3363,6 +3363,18 @@ foo:	.long	25
 	tls_first_minor=20
 	tls_as_opt='--fatal-warnings'
 	;;
+  or1k*-*-*)
+    conftest_s='
+	.section ".tdata","awT",@progbits
+foo:	.long	25
+	.text
+	l.movhi	r3, tpoffha(foo)
+	l.add	r3, r3, r10
+	l.lwz	r4, tpofflo(foo)(r3)'
+    tls_first_major=2
+    tls_first_minor=30
+    tls_as_opt=--fatal-warnings
+    ;;
   powerpc-ibm-aix*)
     conftest_s='
 	.extern __get_tpointer
-- 
2.18.0


From ce424c1f202354e4205286f0bc6d792b8c80ff8b Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Tue, 22 May 2018 13:47:34 -0700
Subject: [PATCH 087/108] or1k: Add libgcc1 functions

We currently have multiply and divide expanded inline.
However, we were going to require this eventually, and
my pre-built copy of musl requires this for static linking.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 libgcc/config/or1k/lib1funcs.S | 188 +++++++++++++++++++++++++++++++++
 libgcc/config/or1k/t-or1k      |   3 +-
 2 files changed, 190 insertions(+), 1 deletion(-)
 create mode 100644 libgcc/config/or1k/lib1funcs.S

diff --git a/libgcc/config/or1k/lib1funcs.S b/libgcc/config/or1k/lib1funcs.S
new file mode 100644
index 00000000000..938fe05e50f
--- /dev/null
+++ b/libgcc/config/or1k/lib1funcs.S
@@ -0,0 +1,188 @@
+/* Copyright (C) 2018 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3, or (at your option) any
+later version.
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+
+#ifdef L__mulsi3
+	.balign 4
+	.globl	__mulsi3
+	.type	__mulsi3, @function
+__mulsi3:
+	l.movhi		r11, 0			/* initial r */
+
+	/* Given R = X * Y ... */
+1:	l.sfeqi		r4, 0			/* while (y != 0) */
+	l.bf		2f
+	 l.andi		r5, r4, 1		/* if (y & 1) ... */
+	l.add		r12, r11, r3
+	l.sfnei		r5, 0
+	l.cmov		r11, r12, r11		/* ... r += x. */
+	l.srli		r4, r4, 1		/* y >>= 1 */
+	l.j		1b
+	 l.add		r3, r3, r3		/* x <<= 1 */
+
+2:	l.jr		r9
+	 l.nop
+
+	.size	__mulsi3, . - __mulsi3
+#endif
+
+#if defined(L__udivsi3) || defined(L__umodsi3) \
+    || defined(L__divsi3) || defined(L__modsi3)
+	.global	__udivmodsi3_internal
+	.hidden	__udivmodsi3_internal
+	.type	__udivmodsi3_internal, @function
+#endif
+
+#ifdef L__udivsi3
+	.balign	4
+	.global	__udivsi3
+	.type	__udivsi3, @function
+__udivsi3:
+__udivmodsi3_internal:
+	/* Note that the other division routines assume that r13
+	   is not clobbered by this routine, and use that as to
+	   save a return address without creating a stack frame.  */
+
+        l.sfeqi		r4, 0		/* division by zero; return 0.  */
+        l.ori		r11, r0, 0	/* initial quotient */
+	l.bf		9f
+	 l.ori		r12, r3, 0	/* initial remainder */
+
+	/* Given X/Y, shift Y left until Y >= X.  */
+	l.ori		r6, r0, 1	/* mask = 1 */
+1:	l.sfltsi	r4, 0		/* y has msb set */
+	l.bf		2f
+	 l.sfltu	r4, r12		/* y < x */
+	l.add		r4, r4, r4	/* y <<= 1 */
+	l.bnf		1b
+	 l.add		r6, r6, r6	/* mask <<= 1 */
+
+	/* Shift Y back to the right again, subtracting from X.  */
+2:	l.add		r7, r11, r6	/* tmp1 = quot + mask */
+3:	l.srli		r6, r6, 1	/* mask >>= 1 */
+	l.sub		r8, r12, r4	/* tmp2 = x - y */
+	l.sfleu		r4, r12		/* y <= x */
+	l.srli		r4, r4, 1	/* y >>= 1 */
+	l.cmov		r11, r7, r11	/* if (y <= x) quot = tmp1 */
+	l.cmov		r12, r8, r12	/* if (y <= x) x = tmp2 */
+	l.sfnei		r6, 0		/* loop until mask == 0 */
+	l.bf		3b
+	 l.add		r7, r11, r6	/* delay fill from loop start */
+
+9:	l.jr		r9
+	 l.nop
+
+	.size	__udivsi3, . - __udivsi3
+	.size	__udivmodsi3_internal, . - __udivmodsi3_internal
+#endif
+
+#ifdef L__umodsi3
+	.balign	4
+	.global	__umodsi3
+	.type	__umodsi3, @function
+	.cfi_startproc
+__umodsi3:
+	/* Know that __udivmodsi3_internal does not clobber r13.  */
+	l.ori		r13, r9, 0
+	.cfi_register	9, 13
+	l.jal		__udivmodsi3_internal
+	 l.nop
+	l.jr		r13		/* return to saved lr */
+	 l.ori		r11, r12, 0	/* move remainder to rv */
+
+	.cfi_endproc
+	.size	__umodsi3, . - __umodsi3
+#endif
+
+/* For signed division we do:
+ *
+ *   -x / y = x / -y = -(x / y)
+ *   -x % y = -(x % y)
+ *   x % -y = x % b
+ *
+ * which has the property that (x/y)*y + (x%y) = x.
+ */
+
+#ifdef L__divsi3
+	.balign	4
+	.global	__divsi3
+	.type	__divsi3, @function
+	.cfi_startproc
+__divsi3:
+	l.xor		r6, r3, r4	/* need result negate?  */
+
+	l.sfltsi	r3, 0		/* abs(x) */
+	l.sub		r5, r0, r3
+	l.cmov		r3, r5, r3
+
+	l.sfltsi	r4, 0		/* abs(y) */
+	l.sub		r5, r0, r4
+	l.cmov		r4, r5, r4
+
+	/* If the result will not require sign flip, tail call.  */
+	l.sfltsi	r6, 0
+        l.bnf		__udivmodsi3_internal
+	 l.ori		r13, r9, 0	/* save lr */
+
+	/* Otherwise, know that __udivmodsi3_internal does not clobber r13.
+	   Perform a normal call, then negate and return via saved lr.  */
+	.cfi_register	9, 13
+        l.jal		__udivmodsi3_internal
+	 l.nop
+	l.jr		r13
+	 l.sub		r11, r0, r11
+
+	.cfi_endproc
+	.size	__divsi3, . - __divsi3
+#endif
+
+#ifdef L__modsi3
+	.balign	4
+	.global	__modsi3
+	.type	__modsi3, @function
+	.cfi_startproc
+__modsi3:
+	l.sfltsi	r4, 0		/* abs(y) */
+	l.sub		r5, r0, r4
+	l.cmov		r4, r5, r4
+
+	l.sfltsi	r3, 0		/* x negative? */
+	l.bf		1f
+	 l.ori		r13, r9, 0	/* save lr */
+
+	/* Know that __udivmodsi3_internal does not clobber r13.  */
+	.cfi_register	9, 13
+
+	/* X positive; no negate of the result required.  */
+	l.jal		__udivmodsi3_internal
+	 l.nop
+	l.jr		r13		/* return to saved lr */
+	 l.ori		r11, r12, 0	/* move remainder to rv */
+
+	/* X negative; negate both X and the result.  */
+1:	l.jal		__udivmodsi3_internal
+	 l.sub		r3, r0, r3
+	l.jr		r13		/* return to saved lr */
+	 l.sub		r11, r0, r12	/* negate remainder to rv */
+
+	.cfi_endproc
+	.size __modsi3, .- __modsi3
+#endif
diff --git a/libgcc/config/or1k/t-or1k b/libgcc/config/or1k/t-or1k
index 583470af589..73a703ac58d 100644
--- a/libgcc/config/or1k/t-or1k
+++ b/libgcc/config/or1k/t-or1k
@@ -18,4 +18,5 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-
+LIB1ASMSRC = or1k/lib1funcs.S
+LIB1ASMFUNCS = __mulsi3 __udivsi3 __divsi3 __umodsi3 __modsi3
-- 
2.18.0


From 8d113310489fde6394c152fca63dc2860285b60c Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Wed, 23 May 2018 12:48:09 -0700
Subject: [PATCH 088/108] or1k: Allow any offset for virtual registers

Like an earlier patch to allow such offsets for
frame_pointer_rtx and arg_pointer_rtx, allow the
same for the "virtual frame registers" that exist
during the very first pass of rtl expansion.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c        |  5 +++--
 gcc/config/or1k/predicates.md | 11 +++++++++++
 2 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 4adf0dcb4c3..2a02fececa2 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -509,7 +509,7 @@ or1k_legitimate_address_p (machine_mode, rtx x, bool strict_p)
 	return false;
       /* Register elimination is going to adjust all of these offsets.
 	 We might as well keep them as a unit until then.  */
-      if (!strict_p && (base == arg_pointer_rtx || base == frame_pointer_rtx))
+      if (!strict_p && virtual_frame_reg_operand (base, VOIDmode))
 	return CONST_INT_P (addend);
       if (!satisfies_constraint_I (addend))
 	return false;
@@ -715,7 +715,8 @@ or1k_legitimize_address_1 (rtx x, rtx scratch)
   gcc_checking_assert (register_operand (base, Pmode));
   if (addend == const0_rtx)
     return base;
-  if (satisfies_constraint_I (addend))
+  if (satisfies_constraint_I (addend)
+      || virtual_frame_reg_operand (base, VOIDmode))
     return gen_rtx_PLUS (Pmode, base, addend);
   else
     {
diff --git a/gcc/config/or1k/predicates.md b/gcc/config/or1k/predicates.md
index 46e892163b0..c459d38de52 100644
--- a/gcc/config/or1k/predicates.md
+++ b/gcc/config/or1k/predicates.md
@@ -68,3 +68,14 @@
 (define_predicate "losum_ior_operand"
   (and (match_code "unspec")
        (match_test "XINT(op, 1) == UNSPEC_TLSGD")))
+
+;; Return true for a "virtual" or "soft" register that will be
+;; adjusted to a "soft" or "hard" register during elimination.
+(define_predicate "virtual_frame_reg_operand"
+  (match_code "reg")
+{
+  unsigned regno = REGNO (op);
+  return (regno != STACK_POINTER_REGNUM
+          && regno != HARD_FRAME_POINTER_REGNUM
+          && REGNO_PTR_FRAME_P (regno));
+})
-- 
2.18.0


From f5b2d791afe2243c8d7e91843230e051f7d0961a Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Wed, 23 May 2018 12:52:22 -0700
Subject: [PATCH 089/108] or1k: Add TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT

This will fold the low part of an out-of-range stack frame
address into the memory operand, saving one insn.

Reuse the hook itself as a helper for legitimize_address_1
and it's own pre-reload address displacement splitting.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c | 64 +++++++++++++++++++++++++++++++++++++-----
 1 file changed, 57 insertions(+), 7 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 2a02fececa2..c906adcefb7 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -607,6 +607,47 @@ gen_sym_unspec (rtx x, int kind)
   return gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), kind);
 }
 
+/* Worker for TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT.
+   Split an out-of-range address displacement into hi and lo parts.
+   The hi part will have to be loaded into a register separately,
+   but the low part will be folded into the memory operand.  */
+
+static bool
+or1k_legitimize_address_displacement (rtx *off1, rtx *off2,
+				      poly_int64 poly_offset, machine_mode)
+{
+  HOST_WIDE_INT orig_offset = poly_offset;
+  HOST_WIDE_INT lo, hi;
+
+  /* If the displacement is within range of 2 addi insns, prefer that.
+     Otherwise split as per normal, at which point the register allocator
+     will see that OFF1 is not a valid add3 operand and load it into
+     a register, as desired.  */
+  if (orig_offset >= 0 && orig_offset < 2 * 32767)
+    {
+      hi = 32767;
+      lo = orig_offset - hi;
+    }
+  else if (orig_offset < 0 && orig_offset >= 2 * -32768)
+    {
+      hi = -32768;
+      lo = orig_offset - hi;
+    }
+  else
+    {
+      lo = sext_hwi (orig_offset, 16);
+      hi = orig_offset - lo;
+    }
+
+  *off1 = GEN_INT (hi);
+  *off2 = GEN_INT (lo);
+  return true;
+}
+
+#undef  TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT
+#define TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT \
+  or1k_legitimize_address_displacement
+
 /* Worker function for TARGET_LEGITIMIZE_ADDRESS.  */
 
 static rtx
@@ -720,15 +761,24 @@ or1k_legitimize_address_1 (rtx x, rtx scratch)
     return gen_rtx_PLUS (Pmode, base, addend);
   else
     {
-      HOST_WIDE_INT i = INTVAL (addend);
-      HOST_WIDE_INT lo = sext_hwi (i, 16);
-      HOST_WIDE_INT hi = i - lo;
+      rtx hi, lo;
+      bool ok = (or1k_legitimize_address_displacement
+		 (&hi, &lo, INTVAL (addend), SImode));
+      gcc_assert (ok);
 
-      t1 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;
       t2 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;
-      emit_move_insn (t1, gen_int_mode (hi, Pmode));
-      emit_insn (gen_add3_insn (t2, base, t1));
-      return plus_constant (Pmode, t2, lo);
+      if (satisfies_constraint_I (hi))
+	emit_insn (gen_addsi3 (t2, base, hi));
+      else
+	{
+	  t1 = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : scratch;
+	  emit_move_insn (t1, hi);
+	  emit_insn (gen_add3_insn (t2, base, t1));
+	}
+      if (lo == const0_rtx)
+	return t2;
+      else
+	return gen_rtx_PLUS (Pmode, t2, lo);
     }
 }
 
-- 
2.18.0


From 21209cf6ff91110a44e5643f714fa394a732f118 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Thu, 24 May 2018 14:03:52 -0700
Subject: [PATCH 090/108] or1k: Add atomic operations

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k-protos.h |   9 +
 gcc/config/or1k/or1k.c        | 414 ++++++++++++++++++++++++++++++++++
 gcc/config/or1k/or1k.md       | 280 ++++++++++++++++++++---
 gcc/config/or1k/predicates.md |   3 +
 4 files changed, 673 insertions(+), 33 deletions(-)

diff --git a/gcc/config/or1k/or1k-protos.h b/gcc/config/or1k/or1k-protos.h
index 7ae2190e1b8..f6256b2ee04 100644
--- a/gcc/config/or1k/or1k-protos.h
+++ b/gcc/config/or1k/or1k-protos.h
@@ -27,3 +27,12 @@ extern rtx  or1k_return_addr (int, rtx);
 extern void or1k_expand_move (machine_mode, rtx, rtx);
 extern void or1k_expand_compare (rtx *);
 extern void or1k_expand_call (rtx, rtx, rtx, bool);
+
+#ifdef RTX_CODE
+void or1k_expand_atomic_compare_and_swap (rtx operands[]);
+void or1k_expand_atomic_compare_and_swap_qihi (rtx operands[]);
+void or1k_expand_atomic_exchange (rtx operands[]);
+void or1k_expand_atomic_exchange_qihi (rtx operands[]);
+void or1k_expand_atomic_op (rtx_code, rtx, rtx, rtx, rtx);
+void or1k_expand_atomic_op_qihi (rtx_code, rtx, rtx, rtx, rtx);
+#endif
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index c906adcefb7..a28b4a8683d 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -43,6 +43,7 @@
 #include "optabs.h"
 #include "explow.h"
 #include "cfgrtl.h"
+#include "alias.h"
 
 /* These 4 are needed to allow using satisfies_constraint_J.  */
 #include "insn-config.h"
@@ -1440,6 +1441,419 @@ or1k_rtx_costs (rtx x, machine_mode mode, int outer_code,
 #undef TARGET_RTX_COSTS
 #define TARGET_RTX_COSTS or1k_rtx_costs
 
+
+/* A subroutine of the atomic operation splitters.  Jump to LABEL if
+   COND is true.  Mark the jump as unlikely to be taken.  */
+
+static void
+emit_unlikely_jump (rtx_code code, rtx label)
+{
+  rtx x;
+
+  x = gen_rtx_REG (BImode, SR_F_REGNUM);
+  x = gen_rtx_fmt_ee (code, VOIDmode, x, const0_rtx);
+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label, pc_rtx);
+  emit_jump_insn (gen_rtx_SET (pc_rtx, x));
+
+  // Disable this for now -- producing verify_cfg failures on probabilities.
+  // int very_unlikely = REG_BR_PROB_BASE / 100 - 1;
+  // add_int_reg_note (insn, REG_BR_PROB, very_unlikely);
+}
+
+/* A subroutine of the atomic operation splitters.
+   Emit a raw comparison for A CODE B.  */
+
+static void
+emit_compare (rtx_code code, rtx a, rtx b)
+{
+  emit_insn (gen_rtx_SET (gen_rtx_REG (BImode, SR_F_REGNUM),
+			  gen_rtx_fmt_ee (code, BImode, a, b)));
+}
+
+/* A subroutine of the atomic operation splitters.
+   Emit a load-locked instruction in MODE.  */
+
+static void
+emit_load_locked (machine_mode mode, rtx reg, rtx mem)
+{
+  gcc_assert (mode == SImode);
+  emit_insn (gen_load_locked_si (reg, mem));
+}
+
+/* A subroutine of the atomic operation splitters.
+   Emit a store-conditional instruction in MODE.  */
+
+static void
+emit_store_conditional (machine_mode mode, rtx mem, rtx val)
+{
+  gcc_assert (mode == SImode);
+  emit_insn (gen_store_conditional_si (mem, val));
+}
+
+/* A subroutine of the various atomic expanders.  For sub-word operations,
+   we must adjust things to operate on SImode.  Given the original MEM,
+   return a new aligned memory.  Also build and return the quantities by
+   which to shift and mask.  */
+
+static rtx
+or1k_adjust_atomic_subword (rtx orig_mem, rtx *pshift, rtx *pmask)
+{
+  rtx addr, align, shift, mask, mem;
+  machine_mode mode = GET_MODE (orig_mem);
+
+  addr = XEXP (orig_mem, 0);
+  addr = force_reg (Pmode, addr);
+
+  /* Aligned memory containing subword.  Generate a new memory.  We
+     do not want any of the existing MEM_ATTR data, as we're now
+     accessing memory outside the original object.  */
+  align = expand_binop (Pmode, and_optab, addr, GEN_INT (-4),
+			NULL_RTX, 1, OPTAB_LIB_WIDEN);
+  mem = gen_rtx_MEM (SImode, align);
+  MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (orig_mem);
+  if (MEM_ALIAS_SET (orig_mem) == ALIAS_SET_MEMORY_BARRIER)
+    set_mem_alias_set (mem, ALIAS_SET_MEMORY_BARRIER);
+
+  /* Shift amount for subword relative to aligned word.  */
+  rtx mode_mask = GEN_INT (mode == QImode ? 3 : 2);
+  shift = expand_binop (SImode, and_optab, gen_lowpart (SImode, addr),
+			mode_mask, NULL_RTX, 1, OPTAB_LIB_WIDEN);
+  if (BYTES_BIG_ENDIAN)
+    shift = expand_binop (SImode, xor_optab, shift, mode_mask,
+			  shift, 1, OPTAB_LIB_WIDEN);
+  shift = expand_binop (SImode, ashl_optab, shift, GEN_INT (3),
+			shift, 1, OPTAB_LIB_WIDEN);
+  *pshift = shift;
+
+  /* Mask for insertion.  */
+  mask = expand_binop (SImode, ashl_optab, GEN_INT (GET_MODE_MASK (mode)),
+		       shift, NULL_RTX, 1, OPTAB_LIB_WIDEN);
+  *pmask = mask;
+
+  return mem;
+}
+
+/* A subroutine of the various atomic expanders.  For sub-word operations,
+   complete the operation by shifting result to the lsb of the SImode
+   temporary and then extracting the result in MODE with a SUBREG.  */
+
+static void
+or1k_finish_atomic_subword (machine_mode mode, rtx o, rtx n, rtx shift)
+{
+  n = expand_binop (SImode, lshr_optab, n, shift,
+		    NULL_RTX, 1, OPTAB_LIB_WIDEN);
+  emit_move_insn (o, gen_lowpart (mode, n));
+}
+
+/* Expand an atomic compare and swap operation.  */
+
+void
+or1k_expand_atomic_compare_and_swap (rtx operands[])
+{
+  rtx boolval, retval, mem, oldval, newval;
+  rtx label1, label2;
+  machine_mode mode;
+  bool is_weak;
+
+  boolval = operands[0];
+  retval = operands[1];
+  mem = operands[2];
+  oldval = operands[3];
+  newval = operands[4];
+  is_weak = (INTVAL (operands[5]) != 0);
+  mode = GET_MODE (mem);
+
+  if (reg_overlap_mentioned_p (retval, oldval))
+    oldval = copy_to_reg (oldval);
+
+  label1 = NULL_RTX;
+  if (!is_weak)
+    {
+      label1 = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+      emit_label (XEXP (label1, 0));
+    }
+  label2 = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+
+  emit_load_locked (mode, retval, mem);
+  emit_compare (EQ, retval, oldval);
+  emit_unlikely_jump (EQ, label2);
+  emit_store_conditional (mode, mem, newval);
+
+  if (!is_weak)
+    emit_unlikely_jump (EQ, label1);
+  emit_label (XEXP (label2, 0));
+
+  /* In all cases, SR_F contains 1 on success, and 0 on failure.  */
+  emit_insn (gen_sne_sr_f (boolval));
+}
+
+void
+or1k_expand_atomic_compare_and_swap_qihi (rtx operands[])
+{
+  rtx boolval, orig_retval, retval, scratch, mem, oldval, newval;
+  rtx label1, label2, mask, shift;
+  machine_mode mode;
+  bool is_weak;
+
+  boolval = operands[0];
+  orig_retval = operands[1];
+  mem = operands[2];
+  oldval = operands[3];
+  newval = operands[4];
+  is_weak = (INTVAL (operands[5]) != 0);
+  mode = GET_MODE (mem);
+
+  mem = or1k_adjust_atomic_subword (mem, &shift, &mask);
+
+  /* Shift and mask OLDVAL and NEWVAL into position with the word.  */
+  if (oldval != const0_rtx)
+    {
+      oldval = convert_modes (SImode, mode, oldval, 1);
+      oldval = expand_binop (SImode, ashl_optab, oldval, shift,
+			     NULL_RTX, 1, OPTAB_LIB_WIDEN);
+    }
+  if (newval != const0_rtx)
+    {
+      newval = convert_modes (SImode, mode, newval, 1);
+      newval = expand_binop (SImode, ashl_optab, newval, shift,
+			     NULL_RTX, 1, OPTAB_LIB_WIDEN);
+    }
+
+  label1 = NULL_RTX;
+  if (!is_weak)
+    {
+      label1 = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+      emit_label (XEXP (label1, 0));
+    }
+  label2 = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+
+  scratch = gen_reg_rtx (SImode);
+  emit_load_locked (SImode, scratch, mem);
+
+  retval = expand_binop (SImode, and_optab, scratch, mask,
+			 NULL_RTX, 1, OPTAB_LIB_WIDEN);
+  scratch = expand_binop (SImode, xor_optab, scratch, retval,
+			  scratch, 1, OPTAB_LIB_WIDEN);
+
+  emit_compare (EQ, retval, oldval);
+  emit_unlikely_jump (EQ, label2);
+
+  if (newval != const0_rtx)
+    scratch = expand_binop (SImode, ior_optab, scratch, newval,
+			    scratch, 1, OPTAB_LIB_WIDEN);
+
+  emit_store_conditional (SImode, mem, scratch);
+
+  if (!is_weak)
+    emit_unlikely_jump (EQ, label1);
+  emit_label (XEXP (label2, 0));
+
+  or1k_finish_atomic_subword (mode, orig_retval, retval, shift);
+
+  /* In all cases, CR0 contains EQ on success, and NE on failure.  */
+  emit_insn (gen_sne_sr_f (boolval));
+}
+
+/* Expand an atomic exchange operation.  */
+
+void
+or1k_expand_atomic_exchange (rtx operands[])
+{
+  rtx retval, mem, val, label;
+  machine_mode mode;
+
+  retval = operands[0];
+  mem = operands[1];
+  val = operands[2];
+  mode = GET_MODE (mem);
+
+  if (reg_overlap_mentioned_p (retval, val))
+    val = copy_to_reg (val);
+
+  label = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+  emit_label (XEXP (label, 0));
+
+  emit_load_locked (mode, retval, mem);
+  emit_store_conditional (mode, mem, val);
+  emit_unlikely_jump (EQ, label);
+}
+
+void
+or1k_expand_atomic_exchange_qihi (rtx operands[])
+{
+  rtx orig_retval, retval, mem, val, scratch;
+  rtx label, mask, shift;
+  machine_mode mode;
+
+  orig_retval = operands[0];
+  mem = operands[1];
+  val = operands[2];
+  mode = GET_MODE (mem);
+
+  mem = or1k_adjust_atomic_subword (mem, &shift, &mask);
+
+  /* Shift and mask VAL into position with the word.  */
+  if (val != const0_rtx)
+    {
+      val = convert_modes (SImode, mode, val, 1);
+      val = expand_binop (SImode, ashl_optab, val, shift,
+		          NULL_RTX, 1, OPTAB_LIB_WIDEN);
+    }
+
+  label = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+  emit_label (XEXP (label, 0));
+
+  scratch = gen_reg_rtx (SImode);
+  emit_load_locked (SImode, scratch, mem);
+
+  retval = expand_binop (SImode, and_optab, scratch, mask,
+			 NULL_RTX, 1, OPTAB_LIB_WIDEN);
+  scratch = expand_binop (SImode, xor_optab, scratch, retval,
+			  scratch, 1, OPTAB_LIB_WIDEN);
+  if (val != const0_rtx)
+    scratch = expand_binop (SImode, ior_optab, scratch, val,
+			    scratch, 1, OPTAB_LIB_WIDEN);
+
+  emit_store_conditional (SImode, mem, scratch);
+  emit_unlikely_jump (EQ, label);
+
+  or1k_finish_atomic_subword (mode, orig_retval, retval, shift);
+}
+
+/* Expand an atomic fetch-and-operate pattern.  CODE is the binary operation
+   to perform (with MULT as a stand-in for NAND).  MEM is the memory on which
+   to operate.  VAL is the second operand of the binary operator.  BEFORE and
+   AFTER are optional locations to return the value of MEM either before of
+   after the operation.  */
+
+void
+or1k_expand_atomic_op (rtx_code code, rtx mem, rtx val,
+		       rtx orig_before, rtx orig_after)
+{
+  machine_mode mode = GET_MODE (mem);
+  rtx before = orig_before, after = orig_after;
+  rtx label;
+
+  label = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+  emit_label (XEXP (label, 0));
+
+  if (before == NULL_RTX)
+    before = gen_reg_rtx (mode);
+
+  emit_load_locked (mode, before, mem);
+
+  if (code == MULT)
+    {
+      after = expand_binop (mode, and_optab, before, val,
+			    after, 1, OPTAB_LIB_WIDEN);
+      after = expand_unop (mode, one_cmpl_optab, after, after, 1);
+    }
+  else
+    after = expand_simple_binop (mode, code, before, val,
+				 after, 1, OPTAB_LIB_WIDEN);
+
+  emit_store_conditional (mode, mem, after);
+  emit_unlikely_jump (EQ, label);
+
+  if (orig_before)
+    emit_move_insn (orig_before, before);
+  if (orig_after)
+    emit_move_insn (orig_after, after);
+}
+
+void
+or1k_expand_atomic_op_qihi (rtx_code code, rtx mem, rtx val,
+			    rtx orig_before, rtx orig_after)
+{
+  machine_mode mode = GET_MODE (mem);
+  rtx label, mask, shift, x;
+  rtx before, after, scratch;
+
+  mem = or1k_adjust_atomic_subword (mem, &shift, &mask);
+
+  /* Shift and mask VAL into position with the word.  */
+  val = convert_modes (SImode, mode, val, 1);
+  val = expand_binop (SImode, ashl_optab, val, shift,
+		      NULL_RTX, 1, OPTAB_LIB_WIDEN);
+
+  switch (code)
+    {
+    case IOR:
+    case XOR:
+      /* We've already zero-extended VAL.  That is sufficient to
+	 make certain that it does not affect other bits.  */
+      break;
+
+    case AND:
+    case MULT: /* NAND */
+      /* If we make certain that all of the other bits in VAL are
+	 set, that will be sufficient to not affect other bits.  */
+      x = expand_unop (SImode, one_cmpl_optab, mask, NULL_RTX, 1);
+      val = expand_binop (SImode, ior_optab, val, x,
+			  val, 1, OPTAB_LIB_WIDEN);
+      break;
+
+    case PLUS:
+    case MINUS:
+      /* These will all affect bits outside the field and need
+	 adjustment via MASK within the loop.  */
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+
+  label = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+  emit_label (XEXP (label, 0));
+
+  before = scratch = gen_reg_rtx (SImode);
+  emit_load_locked (SImode, before, mem);
+
+  switch (code)
+    {
+    case IOR:
+    case XOR:
+    case AND:
+      after = expand_simple_binop (SImode, code, before, val,
+				   NULL_RTX, 1, OPTAB_LIB_WIDEN);
+      scratch = after;
+      break;
+
+    case PLUS:
+    case MINUS:
+      before = expand_binop (SImode, and_optab, scratch, mask,
+			     NULL_RTX, 1, OPTAB_LIB_WIDEN);
+      scratch = expand_binop (SImode, xor_optab, scratch, before,
+			      scratch, 1, OPTAB_LIB_WIDEN);
+      after = expand_simple_binop (SImode, code, before, val,
+				   NULL_RTX, 1, OPTAB_LIB_WIDEN);
+      after = expand_binop (SImode, and_optab, after, mask,
+			    after, 1, OPTAB_LIB_WIDEN);
+      scratch = expand_binop (SImode, ior_optab, scratch, after,
+			      scratch, 1, OPTAB_LIB_WIDEN);
+      break;
+
+    case MULT: /* NAND */
+      after = expand_binop (SImode, and_optab, before, val,
+			    NULL_RTX, 1, OPTAB_LIB_WIDEN);
+      after = expand_binop (SImode, xor_optab, after, mask,
+			    after, 1, OPTAB_LIB_WIDEN);
+      scratch = after;
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+
+  emit_store_conditional (SImode, mem, scratch);
+  emit_unlikely_jump (EQ, label);
+
+  if (orig_before)
+    or1k_finish_atomic_subword (mode, orig_before, before, shift);
+  if (orig_after)
+    or1k_finish_atomic_subword (mode, orig_after, after, shift);
+}
+
 #undef TARGET_OPTION_OVERRIDE
 #define TARGET_OPTION_OVERRIDE or1k_option_override
 
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 7c05061c794..85ad4843940 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -45,10 +45,13 @@
   UNSPEC_TPOFF
   UNSPEC_GOTTPOFF
   UNSPEC_TLSGD
+  UNSPEC_MSYNC
 ])
 
 (define_c_enum "unspecv" [
   UNSPECV_SET_GOT
+  UNSPECV_LL
+  UNSPECV_SC
 ])
 
 ;; Instruction scheduler
@@ -200,6 +203,7 @@
 ;; -------------------------------------------------------------------------
 
 (define_mode_iterator I [QI HI SI])
+(define_mode_iterator I12 [QI HI])
 
 (define_mode_attr ldst [(QI "b") (HI "h") (SI "w")])
 
@@ -349,7 +353,7 @@
 ;;     l.sfge{s,u}[i] - greater than or equal, signed or unsigned, r r or r i
 ;;
 ;;  EQ,NE,LT,LTU,LE,LEU,GT,GTU,GE,GEU
-;;  We try to iterate all of thse
+;;  We iterate through all of these
 ;;
 
 (define_code_iterator intcmpcc [ne eq lt ltu gt gtu ge le geu leu])
@@ -381,9 +385,36 @@
   ""
 {
   or1k_expand_compare (operands + 1);
-  emit_move_insn (operands[0], const1_rtx);
+  PUT_MODE (operands[1], SImode);
+  emit_insn (gen_rtx_SET (operands[0], operands[1]));
+  DONE;
 })
 
+;; Being able to "copy" SR_F to a general register is helpful for
+;; the atomic insns, wherein the usual usage is to test the success
+;; of the compare-and-swap.  Representing the operation in this way,
+;; rather than exposing the cmov immediately, allows the optimizers
+;; to propagate the use of SR_F directly into a branch.
+
+(define_expand "sne_sr_f"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ne:SI (reg:BI SR_F_REGNUM) (const_int 0)))]
+  "")
+
+(define_insn_and_split "*scc"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operator:SI 1 "equality_comparison_operator"
+	  [(reg:BI SR_F_REGNUM) (const_int 0)]))]
+  ""
+  "#"
+  "reload_completed"
+  [(set (match_dup 0) (const_int 1))
+   (set (match_dup 0)
+	(if_then_else:SI (match_dup 1)
+	  (match_dup 0)
+	  (const_int 0)))]
+  "")
+
 (define_expand "mov<I:mode>cc"
   [(set (match_operand:I 0 "register_operand" "")
 	(if_then_else:I (match_operand 1 "comparison_operator" "")
@@ -396,44 +427,24 @@
   operands[1] = xops[0];
 })
 
-(define_insn "*cmov<I:mode>_positive"
-  [(set (match_operand:I 0 "register_operand" "=r")
-	(if_then_else:I (ne (reg:BI SR_F_REGNUM) (const_int 0))
-		      (match_operand:I 1 "reg_or_0_operand" "rO")
-		      (match_operand:I 2 "reg_or_0_operand" "rO")))]
-  ""
-  "l.cmov\t%0, %r1, %r2")
-
-(define_insn "*cmov<I:mode>_negative"
+(define_insn "*cmov<I:mode>"
   [(set (match_operand:I 0 "register_operand" "=r")
-	(if_then_else:I (eq (reg:BI SR_F_REGNUM) (const_int 0))
-		      (match_operand:I 1 "reg_or_0_operand" "rO")
-		      (match_operand:I 2 "reg_or_0_operand" "rO")))]
+	(if_then_else:I
+	  (match_operator 3 "equality_comparison_operator"
+	    [(reg:BI SR_F_REGNUM) (const_int 0)])
+	  (match_operand:I 1 "reg_or_0_operand" "rO")
+	  (match_operand:I 2 "reg_or_0_operand" "rO")))]
   ""
-  "l.cmov\t%0, %r2, %r1")
+{
+  return (GET_CODE (operands[3]) == NE
+	  ? "l.cmov\t%0, %r1, %r2"
+	  : "l.cmov\t%0, %r2, %r1");
+})
 
 ;; -------------------------------------------------------------------------
 ;; Branch instructions
 ;; -------------------------------------------------------------------------
 
-(define_insn "*cbranch_positive"
-  [(set (pc)
-	(if_then_else (ne (reg:BI SR_F_REGNUM) (const_int 0))
-		      (label_ref (match_operand 0 "" ""))
-		      (pc)))]
-  ""
-  "l.bf\t%0%#"
-  [(set_attr "type" "control")])
-
-(define_insn "*cbranch_negative"
-  [(set (pc)
-	(if_then_else (eq (reg:BI SR_F_REGNUM) (const_int 0))
-		      (label_ref (match_operand 0 "" ""))
-		      (pc)))]
-  ""
-  "l.bnf\t%0%#"
-  [(set_attr "type" "control")])
-
 (define_expand "cbranchsi4"
   [(set (pc)
 	(if_then_else
@@ -447,6 +458,21 @@
   or1k_expand_compare (operands);
 })
 
+(define_insn "*cbranch"
+  [(set (pc)
+	(if_then_else
+	  (match_operator 1 "equality_comparison_operator"
+	    [(reg:BI SR_F_REGNUM) (const_int 0)])
+	  (label_ref (match_operand 0 "" ""))
+	  (pc)))]
+  ""
+{
+  return (GET_CODE (operands[1]) == NE
+	  ? "l.bf\t%0%#"
+	  : "l.bnf\t%0%#");
+}
+  [(set_attr "type" "control")])
+
 ;; -------------------------------------------------------------------------
 ;; Jump instructions
 ;; -------------------------------------------------------------------------
@@ -548,6 +574,194 @@
   [(set_attr "length" "16")
    (set_attr "type" "multi")])
 
+;; -------------------------------------------------------------------------
+;; Atomic Operations
+;; -------------------------------------------------------------------------
+
+;; Note that MULT stands in for the non-existant NAND rtx_code.
+(define_code_iterator FETCHOP [plus minus ior xor and mult])
+
+(define_code_attr fetchop_name
+  [(plus "add")
+   (minus "sub")
+   (ior "or")
+   (xor "xor")
+   (and "and")
+   (mult "nand")])
+
+(define_code_attr fetchop_pred
+  [(plus "reg_or_s16_operand")
+   (minus "register_operand")
+   (ior "reg_or_u16_operand")
+   (xor "reg_or_s16_operand")
+   (and "reg_or_u16_operand")
+   (mult "reg_or_u16_operand")])
+
+(define_expand "mem_thread_fence"
+  [(match_operand:SI 0 "const_int_operand" "")]		;; model
+  ""
+{
+  memmodel model = memmodel_base (INTVAL (operands[0]));
+  if (model != MEMMODEL_RELAXED)
+    emit_insn (gen_msync ());
+  DONE;
+})
+
+(define_expand "msync"
+  [(set (match_dup 0) (unspec:BLK [(match_dup 0)] UNSPEC_MSYNC))]
+  ""
+{
+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[0]) = 1;
+})
+
+(define_insn "*msync"
+  [(set (match_operand:BLK 0 "" "")
+	(unspec:BLK [(match_dup 0)] UNSPEC_MSYNC))]
+  ""
+  "l.msync")
+
+(define_insn "load_locked_si"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec_volatile:SI
+	  [(match_operand:SI 1 "memory_operand" "m")] UNSPECV_LL))]
+  ""
+  "l.lwa\t%0,%1"
+  [(set_attr "type" "ld")])
+
+(define_insn "store_conditional_si"
+  [(set (reg:BI SR_F_REGNUM)
+	(unspec_volatile:BI [(const_int 0)] UNSPECV_SC))
+   (set (match_operand:SI 0 "memory_operand" "=m")
+	(match_operand:SI 1 "reg_or_0_operand" "rO"))]
+  ""
+  "l.swa\t%0,%r1"
+  [(set_attr "type" "st")])
+
+(define_expand "atomic_compare_and_swapsi"
+  [(match_operand:SI 0 "register_operand")   ;; bool output
+   (match_operand:SI 1 "register_operand")   ;; val output
+   (match_operand:SI 2 "memory_operand")     ;; memory
+   (match_operand:SI 3 "reg_or_s16_operand") ;; expected
+   (match_operand:SI 4 "reg_or_0_operand")   ;; desired
+   (match_operand:SI 5 "const_int_operand")  ;; is_weak
+   (match_operand:SI 6 "const_int_operand")  ;; mod_s
+   (match_operand:SI 7 "const_int_operand")] ;; mod_f
+  ""
+{
+  or1k_expand_atomic_compare_and_swap (operands);
+  DONE;
+})
+
+(define_expand "atomic_compare_and_swap<mode>"
+  [(match_operand:SI 0 "register_operand")   ;; bool output
+   (match_operand:I12 1 "register_operand")  ;; val output
+   (match_operand:I12 2 "memory_operand")    ;; memory
+   (match_operand:I12 3 "register_operand")  ;; expected
+   (match_operand:I12 4 "reg_or_0_operand")  ;; desired
+   (match_operand:SI 5 "const_int_operand")  ;; is_weak
+   (match_operand:SI 6 "const_int_operand")  ;; mod_s
+   (match_operand:SI 7 "const_int_operand")] ;; mod_f
+  ""
+{
+  or1k_expand_atomic_compare_and_swap_qihi (operands);
+  DONE;
+})
+
+(define_expand "atomic_exchangesi"
+  [(match_operand:SI 0 "register_operand")	;; output
+   (match_operand:SI 1 "memory_operand")	;; memory
+   (match_operand:SI 2 "reg_or_0_operand")	;; input
+   (match_operand:SI 3 "const_int_operand")]	;; model
+  ""
+{
+  or1k_expand_atomic_exchange (operands);
+  DONE;
+})
+
+(define_expand "atomic_exchange<mode>"
+  [(match_operand:I12 0 "register_operand")	;; output
+   (match_operand:I12 1 "memory_operand")	;; memory
+   (match_operand:I12 2 "reg_or_0_operand")	;; input
+   (match_operand:SI 3 "const_int_operand")]	;; model
+  ""
+{
+  or1k_expand_atomic_exchange_qihi (operands);
+  DONE;
+})
+
+(define_expand "atomic_<fetchop_name>si"
+  [(match_operand:SI 0 "memory_operand")	;; memory
+   (FETCHOP:SI (match_dup 0)
+     (match_operand:SI 1 "<fetchop_pred>"))	;; operand
+   (match_operand:SI 2 "const_int_operand")]	;; model
+  ""
+{
+  or1k_expand_atomic_op (<CODE>, operands[0], operands[1], NULL, NULL);
+  DONE;
+})
+
+(define_expand "atomic_<fetchop_name><mode>"
+  [(match_operand:I12 0 "memory_operand")	;; memory
+   (FETCHOP:I12 (match_dup 0)
+     (match_operand:I12 1 "register_operand"))	;; operand
+   (match_operand:SI 2 "const_int_operand")]	;; model
+  ""
+{
+  or1k_expand_atomic_op_qihi (<CODE>, operands[0], operands[1], NULL, NULL);
+  DONE;
+})
+
+(define_expand "atomic_fetch_<fetchop_name>si"
+  [(match_operand:SI 0 "register_operand" "")		;; output
+   (match_operand:SI 1 "memory_operand" "")		;; memory
+   (FETCHOP:SI (match_dup 1)
+     (match_operand:SI 2 "<fetchop_pred>" ""))		;; operand
+   (match_operand:SI 3 "const_int_operand" "")]		;; model
+  ""
+{
+  or1k_expand_atomic_op (<CODE>, operands[1], operands[2], operands[0], NULL);
+  DONE;
+})
+
+(define_expand "atomic_fetch_<fetchop_name><mode>"
+  [(match_operand:I12 0 "register_operand" "")		;; output
+   (match_operand:I12 1 "memory_operand" "")		;; memory
+   (FETCHOP:I12 (match_dup 1)
+     (match_operand:I12 2 "<fetchop_pred>" ""))		;; operand
+   (match_operand:SI 3 "const_int_operand" "")]		;; model
+  ""
+{
+  or1k_expand_atomic_op_qihi (<CODE>, operands[1], operands[2],
+			      operands[0], NULL);
+  DONE;
+})
+
+(define_expand "atomic_<fetchop_name>_fetchsi"
+  [(match_operand:SI 0 "register_operand" "")		;; output
+   (match_operand:SI 1 "memory_operand" "")		;; memory
+   (FETCHOP:SI (match_dup 1)
+     (match_operand:SI 2 "<fetchop_pred>" ""))		;; operand
+   (match_operand:SI 3 "const_int_operand" "")]		;; model
+  ""
+{
+  or1k_expand_atomic_op (<CODE>, operands[1], operands[2], NULL, operands[0]);
+  DONE;
+})
+
+(define_expand "atomic_<fetchop_name>_fetch<mode>"
+  [(match_operand:I12 0 "register_operand" "")		;; output
+   (match_operand:I12 1 "memory_operand" "")		;; memory
+   (FETCHOP:I12 (match_dup 1)
+     (match_operand:I12 2 "<fetchop_pred>" ""))	;; operand
+   (match_operand:SI 3 "const_int_operand" "")]		;; model
+  ""
+{
+  or1k_expand_atomic_op_qihi (<CODE>, operands[1], operands[2],
+			      NULL, operands[0]);
+  DONE;
+})
+
 ;; -------------------------------------------------------------------------
 ;; Call Instructions
 ;; -------------------------------------------------------------------------
diff --git a/gcc/config/or1k/predicates.md b/gcc/config/or1k/predicates.md
index c459d38de52..10e39de5d08 100644
--- a/gcc/config/or1k/predicates.md
+++ b/gcc/config/or1k/predicates.md
@@ -79,3 +79,6 @@
           && regno != HARD_FRAME_POINTER_REGNUM
           && REGNO_PTR_FRAME_P (regno));
 })
+
+(define_predicate "equality_comparison_operator"
+  (match_code "ne,eq"))
-- 
2.18.0


From 6dc090daa5e296d46ebe0f7a741864887dc11e23 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Thu, 24 May 2018 14:05:15 -0700
Subject: [PATCH 091/108] or1k: Always use DT_INITARRAY for linux

Both musl and glibc support this feature, so we can avoid
going through the .init + .ctors indirection.

I've left this not enabled by default for or1k-elf, because
I've no idea what sort of standalone things are out there.
It can be enabled for whomever with a configure switch.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config.gcc | 1 +
 1 file changed, 1 insertion(+)

diff --git a/gcc/config.gcc b/gcc/config.gcc
index 05b190bad82..710d6709f62 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -2383,6 +2383,7 @@ or1k*-*-*)
         or1k*-*-linux*)
                 tm_file="${tm_file} gnu-user.h linux.h glibc-stdint.h"
                 tm_file="${tm_file} or1k/linux.h"
+                enable_initfini_array=yes
                 ;;
 	or1k*-*-elf*)
 		tm_file="${tm_file} newlib-stdint.h or1k/elf.h"
-- 
2.18.0


From b309042e0ddb10f95576d4068d2c1190a79d3610 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 26 May 2018 08:50:05 -0700
Subject: [PATCH 092/108] or1k: Add TARGET_STRICT_ARGUMENT_NAMING as true

Fix varargs abi.  Test case is musl and its __clone assembly
routine: the call to that from C failed to place the fourth
named argument in r6.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index a28b4a8683d..83289befa39 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -917,6 +917,18 @@ or1k_function_value_regno_p (const unsigned int regno)
   return (regno == RV_REGNUM);
 }
 
+/* Worker function for TARGET_STRICT_ARGUMENT_NAMING.
+   The final named argument in a variatic function is named.  */
+
+static bool
+or1k_strict_argument_naming (cumulative_args_t ca ATTRIBUTE_UNUSED)
+{
+  return true;
+}
+
+#undef  TARGET_STRICT_ARGUMENT_NAMING
+#define TARGET_STRICT_ARGUMENT_NAMING or1k_strict_argument_naming
+
 /* Worker function for TARGET_FUNCTION_ARG.  Return the next register to be
    used to hold a function argument or NULL_RTX if there's no more space.  */
 
-- 
2.18.0


From 67ac73eda1fc744c6f5fb6f3071fae15002d7636 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 26 May 2018 13:52:23 -0700
Subject: [PATCH 093/108] or1k: Set
 check_effective_target_logical_op_short_circuit

Disables about 20 tests that do not apply to this target.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/testsuite/lib/target-supports.exp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index c591acd0a26..88f459b4f36 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -8788,6 +8788,7 @@ proc check_effective_target_logical_op_short_circuit {} {
 	 || [istarget nios2*-*-*]
 	 || [istarget riscv*-*-*]
 	 || [istarget visium-*-*]
+	 || [istarget or1k*-*-*]
 	 || [check_effective_target_arm_cortex_m] } {
 	return 1
     }
-- 
2.18.0


From 3bd4e1062849e62681345dc5def834ab95933157 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 26 May 2018 22:51:13 -0500
Subject: [PATCH 094/108] or1k: Disable some tree-ssa/reassoc-* tests

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/testsuite/gcc.dg/tree-ssa/reassoc-33.c | 2 +-
 gcc/testsuite/gcc.dg/tree-ssa/reassoc-34.c | 2 +-
 gcc/testsuite/gcc.dg/tree-ssa/reassoc-35.c | 2 +-
 gcc/testsuite/gcc.dg/tree-ssa/reassoc-36.c | 2 +-
 4 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-33.c b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-33.c
index 5572df4ae24..243508c872c 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-33.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-33.c
@@ -1,4 +1,4 @@
-/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-*"} } } */
+/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-* or1k-*-*-*"} } } */
 
 /* { dg-options "-O2 -fno-inline -fdump-tree-reassoc1-details" } */
 /* { dg-additional-options "-mbranch-cost=2" { target branch_cost } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-34.c b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-34.c
index 9b45f1cd9be..24070046ef2 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-34.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-34.c
@@ -1,4 +1,4 @@
-/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-*"} } } */
+/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-* or1k*-*-*"} } } */
 
 /* { dg-options "-O2 -fno-inline -fdump-tree-reassoc1-details" } */
 /* { dg-additional-options "-mbranch-cost=2" { target branch_cost } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-35.c b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-35.c
index 9ee3abca04e..e5ba101e001 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-35.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-35.c
@@ -1,4 +1,4 @@
-/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-*"} } } */
+/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-* or1k*-*-*"} } } */
 
 /* { dg-options "-O2 -fno-inline -fdump-tree-reassoc1-details" } */
 /* { dg-additional-options "-mbranch-cost=2" { target branch_cost } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-36.c b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-36.c
index ac3a04291b7..4df5840859c 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-36.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-36.c
@@ -1,4 +1,4 @@
-/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-*"} } } */
+/* { dg-do run { target { ! "m68k*-*-* mmix*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* nios2*-*-* or1k*-*-*"} } } */
 
 /* { dg-options "-O2 -fno-inline -fdump-tree-reassoc1-details" } */
 /* { dg-additional-options "-mbranch-cost=2" { target branch_cost } } */
-- 
2.18.0


From 8fbf9f5b93bbbc86846362fa6a5a7632a0e6125b Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 27 May 2018 20:35:35 -0500
Subject: [PATCH 095/108] or1k: Disable some more testcases

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/testsuite/gcc.dg/attr-alloc_size-11.c  | 4 ++--
 gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/gcc/testsuite/gcc.dg/attr-alloc_size-11.c b/gcc/testsuite/gcc.dg/attr-alloc_size-11.c
index 3ec44dc1463..6bb904f4794 100644
--- a/gcc/testsuite/gcc.dg/attr-alloc_size-11.c
+++ b/gcc/testsuite/gcc.dg/attr-alloc_size-11.c
@@ -47,8 +47,8 @@ typedef __SIZE_TYPE__    size_t;
 
 /* The following tests fail because of missing range information.  The xfail
    exclusions are PR79356.  */
-TEST (signed char, SCHAR_MIN + 2, ALLOC_MAX);   /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" "missing range info for signed char" { xfail { ! { aarch64*-*-* arm*-*-* avr-*-* alpha*-*-* ia64-*-* mips*-*-* powerpc*-*-* sparc*-*-* s390*-*-* visium-*-* } } } } */
-TEST (short, SHRT_MIN + 2, ALLOC_MAX); /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" "missing range info for short" { xfail { ! { aarch64*-*-* arm*-*-* alpha*-*-* avr-*-* ia64-*-* mips*-*-* powerpc*-*-* sparc*-*-* s390x-*-* visium-*-* } } } } */
+TEST (signed char, SCHAR_MIN + 2, ALLOC_MAX);   /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" "missing range info for signed char" { xfail { ! { aarch64*-*-* arm*-*-* avr-*-* alpha*-*-* ia64-*-* mips*-*-* powerpc*-*-* sparc*-*-* s390*-*-* visium-*-* or1k*-*-* } } } } */
+TEST (short, SHRT_MIN + 2, ALLOC_MAX); /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" "missing range info for short" { xfail { ! { aarch64*-*-* arm*-*-* alpha*-*-* avr-*-* ia64-*-* mips*-*-* powerpc*-*-* sparc*-*-* s390x-*-* visium-*-* or1k*-*-* } } } } */
 TEST (int, INT_MIN + 2, ALLOC_MAX);    /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" } */
 TEST (int, -3, ALLOC_MAX);             /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" } */
 TEST (int, -2, ALLOC_MAX);             /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c b/gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c
index a1237cf839b..bc486e32586 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c
@@ -33,4 +33,4 @@ void test55 (int x, int y)
    that the && should be emitted (based on BRANCH_COST).  Fix this
    by teaching dom to look through && and register all components
    as true.  */
-/* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" { xfail { ! "alpha*-*-* arm*-*-* aarch64*-*-* powerpc*-*-* cris-*-* crisv32-*-* hppa*-*-* i?86-*-* mmix-*-* mips*-*-* m68k*-*-* moxie-*-* nds32*-*-* s390*-*-* sh*-*-* sparc*-*-* spu-*-* visium-*-* x86_64-*-* riscv*-*-*" } } } } */
+/* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" { xfail { ! "alpha*-*-* arm*-*-* aarch64*-*-* powerpc*-*-* cris-*-* crisv32-*-* hppa*-*-* i?86-*-* mmix-*-* mips*-*-* m68k*-*-* moxie-*-* nds32*-*-* s390*-*-* sh*-*-* sparc*-*-* spu-*-* visium-*-* x86_64-*-* riscv*-*-* or1k*-*-*" } } } } */
-- 
2.18.0


From 28f66ad925a56f28e8b73aba8ea5b5f5e9dabc6a Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sat, 26 May 2018 22:52:38 -0500
Subject: [PATCH 096/108] or1k: Define EH_RETURN macros

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c | 16 +++++++++++++++-
 gcc/config/or1k/or1k.h | 11 +++++++++++
 2 files changed, 26 insertions(+), 1 deletion(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 83289befa39..743c25b399f 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -114,6 +114,13 @@ callee_saved_regno_p (int regno)
 	      || crtl->uses_pic_offset_table
 	      || df_regs_ever_live_p (regno));
 
+    case HW_TO_GCC_REGNO (25):
+    case HW_TO_GCC_REGNO (27):
+    case HW_TO_GCC_REGNO (29):
+    case HW_TO_GCC_REGNO (31):
+      /* See EH_RETURN_DATA_REGNO.  */
+      return crtl->calls_eh_return;
+
     default:
       return false;
     }
@@ -375,7 +382,9 @@ or1k_expand_epilogue (void)
   /* Restore link register.  */
   if (callee_saved_regno_p (LR_REGNUM))
     {
-      cfa_restores = or1k_restore_reg (LR_REGNUM, reg_offset, cfa_restores);
+      /* Note that eh_return sets the LR -- do not overwrite.  */
+      if (!crtl->calls_eh_return)
+	cfa_restores = or1k_restore_reg (LR_REGNUM, reg_offset, cfa_restores);
       reg_offset += UNITS_PER_WORD;
     }
   gcc_assert (reg_offset == sp_offset);
@@ -386,6 +395,11 @@ or1k_expand_epilogue (void)
   RTX_FRAME_RELATED_P (insn) = 1;
   REG_NOTES (insn) = cfa_restores;
   add_reg_note (insn, REG_CFA_DEF_CFA, stack_pointer_rtx);
+
+  /* Move up to the stack frame of an exception handler.  */
+  if (crtl->calls_eh_return)
+    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
+			   EH_RETURN_STACKADJ_RTX));
 }
 
 /* Worker for TARGET_INIT_PIC_REG.  */
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 0ed0a12ab82..278e586c191 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -370,4 +370,15 @@ do {                                                    \
 #define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, LR_REGNUM)
 #define DWARF_FRAME_RETURN_COLUMN LR_REGNUM
 
+/* Describe how we implement __builtin_eh_return.  */
+#define EH_RETURN_REGNUM	HW_TO_GCC_REGNO (23)
+/* Use r25, r27, r29 and r31 (clobber regs) for exception data.
+   Recall that these are remapped consecutively.  */
+#define EH_RETURN_DATA_REGNO(N)	\
+    ((N) < 4 ? HW_TO_GCC_REGNO (25) + (N) : INVALID_REGNUM)
+#define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, EH_RETURN_REGNUM)
+/* Make eh_return use the link register. Epilogue LR restore
+   is suppressed for eh_return. */
+#define EH_RETURN_HANDLER_RTX   INCOMING_RETURN_ADDR_RTX
+
 #endif /* GCC_OR1K_H */
-- 
2.18.0


From 3492597074231995cc161cfc28ea5ffc81a39b85 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 27 May 2018 20:35:04 -0500
Subject: [PATCH 097/108] or1k: Add linux-unwind.h

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 libgcc/config.host                |  8 ++-
 libgcc/config/or1k/linux-unwind.h | 87 +++++++++++++++++++++++++++++++
 2 files changed, 94 insertions(+), 1 deletion(-)
 create mode 100644 libgcc/config/or1k/linux-unwind.h

diff --git a/libgcc/config.host b/libgcc/config.host
index 7822a9b1ed5..e9625d8c632 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -1008,8 +1008,14 @@ nios2-*-*)
 	tmake_file="$tmake_file nios2/t-nios2 t-softfp-sfdf t-softfp-excl t-softfp"
 	extra_parts="$extra_parts crti.o crtn.o"
 	;;
+or1k-*-linux*)
+	tmake_file="$tmake_file or1k/t-or1k"
+	tmake_file="$tmake_file t-softfp-sfdf t-softfp-excl t-softfp"
+	md_unwind_header=or1k/linux-unwind.h
+	;;
 or1k-*-*)
-	tmake_file="$tmake_file or1k/t-or1k t-softfp-sfdf t-softfp-excl t-softfp"
+	tmake_file="$tmake_file or1k/t-or1k"
+	tmake_file="$tmake_file t-softfp-sfdf t-softfp-excl t-softfp"
 	extra_parts="$extra_parts crti.o crtn.o"
 	;;
 pdp11-*-*)
diff --git a/libgcc/config/or1k/linux-unwind.h b/libgcc/config/or1k/linux-unwind.h
new file mode 100644
index 00000000000..e80e9e0f309
--- /dev/null
+++ b/libgcc/config/or1k/linux-unwind.h
@@ -0,0 +1,87 @@
+/* DWARF2 EH unwinding support for OpenRISC Linux.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef inhibit_libc
+/* Do code reading to identify a signal frame, and set the frame
+   state data appropriately.  See unwind-dw2.c for the structs.  */
+
+#include <signal.h>
+#include <sys/ucontext.h>
+
+#define MD_FALLBACK_FRAME_STATE_FOR or1k_fallback_frame_state
+
+static _Unwind_Reason_Code
+or1k_fallback_frame_state (struct _Unwind_Context *context,
+			   _Unwind_FrameState *fs)
+{
+  unsigned int *pc = context->ra;
+  struct rt_sigframe {
+    siginfo_t info;
+    ucontext_t uc;
+  } *rt;
+  struct sigcontext *sc;
+  long new_cfa;
+  int i;
+
+  if (pc[0] != 0xa960008b		/* l.ori r11, r0, NR_rt_sigreturn */
+      || pc[1] != 0x20000001)		/* l.sys 1 */
+    return _URC_END_OF_STACK;
+  if (context->cfa == 0)
+    return _URC_END_OF_STACK;
+
+  rt = context->cfa;
+  sc = &rt->uc.uc_mcontext;
+
+  new_cfa = sc->regs.gpr[1];
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = 1;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+  for (i = 2; i < 32; ++i)
+    {
+      fs->regs.reg[i].how = REG_SAVED_OFFSET;
+      fs->regs.reg[i].loc.offset = (long) &sc->regs.gpr[i] - new_cfa;
+    }
+  fs->regs.reg[32].how = REG_SAVED_OFFSET;
+  fs->regs.reg[32].loc.offset = (long)&sc->regs.pc - new_cfa;
+  fs->retaddr_column = 32;
+  fs->signal_frame = 1;
+
+  return _URC_NO_REASON;
+}
+
+#define MD_FROB_UPDATE_CONTEXT or1k_frob_update_context
+
+/* Fix up for signal handlers that don't have S flag set.  */
+
+static void
+or1k_frob_update_context (struct _Unwind_Context *context,
+			   _Unwind_FrameState *fs ATTRIBUTE_UNUSED)
+{
+  unsigned int *pc = context->ra;
+
+  if (pc[0] == 0xa960008b		/* l.ori r11, r0, NR_rt_sigreturn */
+      && pc[1] == 0x20000001)		/* l.sys 1 */
+    _Unwind_SetSignalFrame (context, 1);
+}
+#endif
-- 
2.18.0


From 050a26767fa1e3641dd524922df285c1ebd67cee Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Mon, 28 May 2018 09:40:04 -0500
Subject: [PATCH 098/108] or1k: Fix GCC_TO_HW_REGNO

Off-by-one brown bag time.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 278e586c191..06630a1664c 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -135,7 +135,7 @@
 
 #define GCC_TO_HW_REGNO(X)		\
   ((X) < 16 || (X) > 31 ? (X)		\
-   : (X) < 24 ? ((X) - 16) * 2 + 16	\
+   : (X) < 24 ? ((X) - 16) * 2 + 17	\
    : ((X) - 24) * 2 + 16)
 
 #define DBX_REGISTER_NUMBER(X)  GCC_TO_HW_REGNO(X)
-- 
2.18.0


From 8acaafb1a5c980cc1a2a57c2b33453e5eeea3825 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Mon, 28 May 2018 21:49:07 -0500
Subject: [PATCH 099/108] or1k: Implement multiple-inheritence thunking

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c | 105 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 105 insertions(+)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 743c25b399f..f9e8dc10ff8 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -1880,6 +1880,111 @@ or1k_expand_atomic_op_qihi (rtx_code code, rtx mem, rtx val,
     or1k_finish_atomic_subword (mode, orig_after, after, shift);
 }
 
+/* Worker for TARGET_ASM_OUTPUT_MI_THUNK.
+   Output the assembler code for a thunk function.  THUNK_DECL is the
+   declaration for the thunk function itself, FUNCTION is the decl for
+   the target function.  DELTA is an immediate constant offset to be
+   added to THIS.  If VCALL_OFFSET is nonzero, the word at address
+   (*THIS + VCALL_OFFSET) should be additionally added to THIS.  */
+
+static void
+or1k_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
+		      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,
+		      tree function)
+{
+  rtx this_rtx, funexp;
+  rtx_insn *insn;
+
+  reload_completed = 1;
+  epilogue_completed = 1;
+
+  emit_note (NOTE_INSN_PROLOGUE_END);
+
+  /* Find the "this" pointer.  Normally in r3, but if the function
+     returns a structure, the structure return pointer is in r3 and
+     the "this" pointer is in r4 instead.  */
+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))
+    this_rtx = gen_rtx_REG (Pmode, 4);
+  else
+    this_rtx = gen_rtx_REG (Pmode, 3);
+
+  /* Add DELTA.  When possible use a plain add, otherwise load it
+     into a register first.  */
+  if (delta)
+    {
+      rtx delta_rtx = GEN_INT (delta);
+
+      if (!satisfies_constraint_I (delta_rtx))
+	{
+	  rtx scratch = gen_rtx_REG (Pmode, PE_TMP_REGNUM);
+	  emit_move_insn (scratch, delta_rtx);
+	  delta_rtx = scratch;
+	}
+
+      /* THIS_RTX += DELTA.  */
+      emit_insn (gen_add2_insn (this_rtx, delta_rtx));
+    }
+
+  /* Add the word at address (*THIS_RTX + VCALL_OFFSET).  */
+  if (vcall_offset)
+    {
+      rtx scratch = gen_rtx_REG (Pmode, PE_TMP_REGNUM);
+      HOST_WIDE_INT lo = sext_hwi(vcall_offset, 16);
+      HOST_WIDE_INT hi = vcall_offset - lo;
+      rtx tmp = this_rtx;
+
+      if (hi != 0)
+	{
+	  emit_move_insn (scratch, GEN_INT (hi));
+	  emit_insn (gen_add2_insn (scratch, this_rtx));
+          tmp = scratch;
+        }
+
+      /* SCRATCH = *(*THIS_RTX + VCALL_OFFSET).  */
+      tmp = plus_constant (Pmode, tmp, lo);
+      tmp = gen_rtx_MEM (Pmode, tmp);
+      emit_move_insn (scratch, tmp);
+
+      /* THIS_RTX += *(*THIS_RTX + VCALL_OFFSET).  */
+      emit_insn (gen_add2_insn (this_rtx, scratch));
+    }
+
+  /* Generate a tail call to the target function.  */
+  if (! TREE_USED (function))
+    {
+      assemble_external (function);
+      TREE_USED (function) = 1;
+    }
+  funexp = XEXP (DECL_RTL (function), 0);
+
+  /* The symbol will be a local alias and therefore always binds local.  */
+  gcc_assert (SYMBOL_REF_LOCAL_P (funexp));
+
+  funexp = gen_rtx_MEM (FUNCTION_MODE, funexp);
+  insn = emit_call_insn (gen_sibcall (funexp, const0_rtx));
+  SIBLING_CALL_P (insn) = 1;
+  emit_barrier ();
+
+  /* Run just enough of rest_of_compilation to get the insns emitted.
+     There's not really enough bulk here to make other passes such as
+     instruction scheduling worth while.  Note that use_thunk calls
+     assemble_start_function and assemble_end_function.  */
+  insn = get_insns ();
+  shorten_branches (insn);
+  final_start_function (insn, file, 1);
+  final (insn, file, 1);
+  final_end_function ();
+
+  reload_completed = 0;
+  epilogue_completed = 0;
+}
+
+#undef  TARGET_ASM_OUTPUT_MI_THUNK
+#define TARGET_ASM_OUTPUT_MI_THUNK or1k_output_mi_thunk
+#undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK
+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK \
+  hook_bool_const_tree_hwi_hwi_const_tree_true
+
 #undef TARGET_OPTION_OVERRIDE
 #define TARGET_OPTION_OVERRIDE or1k_option_override
 
-- 
2.18.0


From 77d4df93b29e9762aadf6dd9f09b7ba47ea1ce7f Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 3 Jun 2018 20:53:52 -0700
Subject: [PATCH 100/108] or1k: Set FRAME_GROWS_DOWNWARD

There are some features, like -fstack-protect, that depend on
having the local variable space grow downward.  It's easy enough
to adjust the elimination to compensate.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k-protos.h | 2 +-
 gcc/config/or1k/or1k.c        | 9 ++++-----
 gcc/config/or1k/or1k.h        | 2 ++
 3 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/gcc/config/or1k/or1k-protos.h b/gcc/config/or1k/or1k-protos.h
index f6256b2ee04..e18383ae781 100644
--- a/gcc/config/or1k/or1k-protos.h
+++ b/gcc/config/or1k/or1k-protos.h
@@ -17,7 +17,7 @@ You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
-extern int  or1k_initial_elimination_offset (int, int);
+extern HOST_WIDE_INT or1k_initial_elimination_offset (int, int);
 extern void or1k_expand_prologue (void);
 extern void or1k_expand_epilogue (void);
 extern void or1k_expand_eh_return (rtx);
diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index f9e8dc10ff8..8fc5d7ec9ba 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -475,10 +475,10 @@ or1k_expand_eh_return (rtx eh_addr)
 
   HFP and AP are the same which is handled below.
  */
-int
+HOST_WIDE_INT
 or1k_initial_elimination_offset (int from, int to)
 {
-  int offset;
+  HOST_WIDE_INT offset;
 
   /* Set OFFSET to the offset from the stack pointer.  */
   switch (from)
@@ -488,9 +488,9 @@ or1k_initial_elimination_offset (int from, int to)
       offset = cfun->machine->total_size;
       break;
 
-    /* Local args, are just past the ougoing args if any.  */
+    /* Local args grow downward from the saved registers.  */
     case FRAME_POINTER_REGNUM:
-      offset = cfun->machine->args_size;
+      offset = cfun->machine->args_size + cfun->machine->local_vars_size;
       break;
 
     default:
@@ -501,7 +501,6 @@ or1k_initial_elimination_offset (int from, int to)
     offset -= cfun->machine->total_size;
 
   return offset;
-
 }
 
 /* Worker function for TARGET_LEGITIMATE_ADDRESS_P.  */
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 06630a1664c..458d60c7993 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -341,6 +341,8 @@ do {                                                    \
    pointer to a smaller address.  */
 #define STACK_GROWS_DOWNWARD 1
 
+#define FRAME_GROWS_DOWNWARD 1
+
 /* An alias for a machine mode name.  This is the machine mode that
    elements of a jump-table should have.  */
 #define CASE_VECTOR_MODE SImode
-- 
2.18.0


From 794cb00cfd5098791cf168b82d112cab8ec924e5 Mon Sep 17 00:00:00 2001
From: Richard Henderson <rth@twiddle.net>
Date: Sun, 3 Jun 2018 22:46:30 -0700
Subject: [PATCH 101/108] or1k: Fix or1k_output_mi_thunk

Missed a dereference.

Signed-off-by: Richard Henderson <rth@twiddle.net>
---
 gcc/config/or1k/or1k.c | 14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 8fc5d7ec9ba..f503c64479f 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -1930,17 +1930,21 @@ or1k_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
       rtx scratch = gen_rtx_REG (Pmode, PE_TMP_REGNUM);
       HOST_WIDE_INT lo = sext_hwi(vcall_offset, 16);
       HOST_WIDE_INT hi = vcall_offset - lo;
-      rtx tmp = this_rtx;
+      rtx tmp;
+
+      /* SCRATCH = *THIS_RTX.  */
+      tmp = gen_rtx_MEM (Pmode, this_rtx);
+      emit_move_insn (scratch, tmp);
 
       if (hi != 0)
 	{
-	  emit_move_insn (scratch, GEN_INT (hi));
-	  emit_insn (gen_add2_insn (scratch, this_rtx));
-          tmp = scratch;
+	  rtx scratch2 = gen_rtx_REG (Pmode, RV_REGNUM);
+	  emit_move_insn (scratch2, GEN_INT (hi));
+	  emit_insn (gen_add2_insn (scratch, scratch2));
         }
 
       /* SCRATCH = *(*THIS_RTX + VCALL_OFFSET).  */
-      tmp = plus_constant (Pmode, tmp, lo);
+      tmp = plus_constant (Pmode, scratch, lo);
       tmp = gen_rtx_MEM (Pmode, tmp);
       emit_move_insn (scratch, tmp);
 
-- 
2.18.0


From 06c7049c926172619cf54ff734141249f7137659 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Sun, 10 Jun 2018 05:31:11 +0900
Subject: [PATCH 102/108] or1k: Use 'H' for high register, and 'h' for hi
 relocations

This is to match the old port, there is some code in the linux kernel
using the 'H' construct.  Its a bit strange, so if we should change the
kernel I am open for that. But this maintains compatibility.

Also, fixed some whitespace.

In: arch/openrisc/include/asm/uaccess.h

    #define __put_user_asm2(x, addr, err)				\
	    __asm__ __volatile__(					\
		    "1:	l.sw 0(%2),%1\n"			\
		    "2:	l.sw 4(%2),%H1\n"			\
		    "3:\n"						\
		    ".section .fixup,\"ax\"\n"			\
		    "4:	l.addi %0,r0,%3\n"			\
		    "	l.j 3b\n"				\
		    "	l.nop\n"				\
		    ".previous\n"					\
		    ".section __ex_table,\"a\"\n"			\
		    "	.align 2\n"				\
		    "	.long 1b,4b\n"				\
		    "	.long 2b,4b\n"				\
		    ".previous"					\
		    : "=r"(err)					\
		    : "r"(x), "r"(addr), "i"(-EFAULT), "0"(err))

    #define __put_user_size(x, ptr, size, retval)				\
    do {									\
	    retval = 0;							\
	    switch (size) {							\
	    case 1: __put_user_asm(x, ptr, retval, "l.sb"); break;		\
	    case 2: __put_user_asm(x, ptr, retval, "l.sh"); break;		\
	    case 4: __put_user_asm(x, ptr, retval, "l.sw"); break;		\
	    case 8: __put_user_asm2(x, ptr, retval); break;			\
	    default: __put_user_bad();					\
	    }								\
    } while (0)
---
 gcc/config/or1k/or1k.c  | 11 +++++++++--
 gcc/config/or1k/or1k.md |  2 +-
 2 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index f503c64479f..91015bc9222 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -1133,14 +1133,21 @@ or1k_print_operand (FILE *file, rtx x, int code)
 
     case 'r':
       if (REG_P (x))
-        fprintf (file, "%s", reg_names[REGNO (operand)]);
+	fprintf (file, "%s", reg_names[REGNO (operand)]);
       else if (x == CONST0_RTX (GET_MODE (x)))
-        fprintf (file, "r0");
+	fprintf (file, "r0");
       else
 	output_operand_lossage ("invalid %%r value");
       break;
 
     case 'H':
+      if (REG_P (x))
+	fprintf (file, "%s", reg_names[REGNO (operand) + 1]);
+      else
+	output_operand_lossage ("invalid %%H value");
+      break;
+
+    case 'h':
       print_reloc (file, x, 0, RKIND_HI);
       break;
     case 'L':
diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 85ad4843940..843b17ee9c6 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -238,7 +238,7 @@
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(high:SI (match_operand:SI 1 "high_operand" "")))]
   ""
-  "l.movhi\t%0, %H1"
+  "l.movhi\t%0, %h1"
   [(set_attr "type" "alu")])
 
 (define_insn "*movsi_lo_sum_iori"
-- 
2.18.0


From c5192af141bdf16dda65b35b6befe8dca150a7a1 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 12 Jun 2018 08:10:21 +0900
Subject: [PATCH 103/108] or1k: add msoft-mul, msoft-div

Add the msoft/mhard flags as were available in the old port.  The old
port didnt seem to have these as multilib options but I think its needed
otherwise we would link with libgcc containing hard l.div and l.mul
instructions.

(This was checked after I implemented it this way)
---
 gcc/config/or1k/or1k.md  |  6 +++---
 gcc/config/or1k/or1k.opt | 15 +++++++++++++++
 gcc/config/or1k/t-or1k   |  2 +-
 3 files changed, 19 insertions(+), 4 deletions(-)

diff --git a/gcc/config/or1k/or1k.md b/gcc/config/or1k/or1k.md
index 843b17ee9c6..9027dd9f402 100644
--- a/gcc/config/or1k/or1k.md
+++ b/gcc/config/or1k/or1k.md
@@ -114,7 +114,7 @@
 	  (mult:SI
 	   (match_operand:SI 1 "register_operand"   "%r,r")
 	   (match_operand:SI 2 "reg_or_s16_operand" " r,I")))]
-  ""
+  "!TARGET_SOFT_MUL"
   "@
   l.mul\t%0, %1, %2
   l.muli\t%0, %1, %2")
@@ -124,7 +124,7 @@
 	  (div:SI
 	   (match_operand:SI 1 "register_operand" "r")
 	   (match_operand:SI 2 "register_operand" "r")))]
-  ""
+  "!TARGET_SOFT_DIV"
   "l.div\t%0, %1, %2")
 
 (define_insn "udivsi3"
@@ -132,7 +132,7 @@
 	  (udiv:SI
 	   (match_operand:SI 1 "register_operand" "r")
 	   (match_operand:SI 2 "register_operand" "r")))]
-  ""
+  "!TARGET_SOFT_DIV"
   "l.divu\t%0, %1, %2")
 
 (define_insn "subsi3"
diff --git a/gcc/config/or1k/or1k.opt b/gcc/config/or1k/or1k.opt
index 930c50a7811..01b4e3ef88e 100644
--- a/gcc/config/or1k/or1k.opt
+++ b/gcc/config/or1k/or1k.opt
@@ -23,4 +23,19 @@
 
 ; Please try to keep this file in ASCII collating order.
 
+mhard-mul
+Target RejectNegative InverseMask(SOFT_MUL).
+Use hardware multiply instructions, use -msoft-mul for emulation.
+
+mhard-div
+Target RejectNegative InverseMask(SOFT_DIV)
+Use hardware divide instructions, use -msoft-div for emulation.
+
+msoft-mul
+Target RejectNegative Mask(SOFT_MUL).
+Use multiply emulation.
+
+msoft-div
+Target RejectNegative Mask(SOFT_DIV)
+Use divide emulation.
 
diff --git a/gcc/config/or1k/t-or1k b/gcc/config/or1k/t-or1k
index e8b4d60fe90..76805ef2c98 100644
--- a/gcc/config/or1k/t-or1k
+++ b/gcc/config/or1k/t-or1k
@@ -18,4 +18,4 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-
+MULTILIB_OPTIONS = msoft-mul msoft-div
-- 
2.18.0


From 5fb7a3608a37317f0d40850dc1491241fc602cb4 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Thu, 12 Jul 2018 06:48:27 +0900
Subject: [PATCH 104/108] or1k: set musl linker to ld-musl-or1k.so.1

This is what musl expects.
---
 gcc/config/or1k/linux.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/gcc/config/or1k/linux.h b/gcc/config/or1k/linux.h
index 87725edeb62..4429c552299 100644
--- a/gcc/config/or1k/linux.h
+++ b/gcc/config/or1k/linux.h
@@ -32,7 +32,7 @@
 #define GLIBC_DYNAMIC_LINKER "/lib/ld.so.1"
 
 #undef MUSL_DYNAMIC_LINKER
-#define MUSL_DYNAMIC_LINKER  "/lib/ld.so.1"
+#define MUSL_DYNAMIC_LINKER  "/lib/ld-musl-or1k.so.1"
 
 #undef LINK_SPEC
 #define LINK_SPEC "%{h*}			\
-- 
2.18.0


From 4d49e0cd277126e1bfd242b1475cb2b075a5861a Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Fri, 13 Jul 2018 21:28:32 +0900
Subject: [PATCH 105/108] or1k: Add testsuite

Add tests for confirming a few things
 - multilib build options work
 - calling conventions are to spec
   * passing struct args
   * returning structs
   * passing regular args
 - we use cmov instruction where expected
 - sibcall functions dont use stack
---
 gcc/config/or1k/or1k.c                    |  2 --
 gcc/testsuite/gcc.target/or1k/args-1.c    | 19 +++++++++++
 gcc/testsuite/gcc.target/or1k/args-2.c    | 15 +++++++++
 gcc/testsuite/gcc.target/or1k/cmov-1.c    |  8 +++++
 gcc/testsuite/gcc.target/or1k/div-mul-1.c |  9 +++++
 gcc/testsuite/gcc.target/or1k/div-mul-2.c |  9 +++++
 gcc/testsuite/gcc.target/or1k/or1k.exp    | 41 +++++++++++++++++++++++
 gcc/testsuite/gcc.target/or1k/return-1.c  | 10 ++++++
 gcc/testsuite/gcc.target/or1k/return-2.c  | 19 +++++++++++
 gcc/testsuite/gcc.target/or1k/return-3.c  | 19 +++++++++++
 gcc/testsuite/gcc.target/or1k/return-4.c  | 19 +++++++++++
 gcc/testsuite/gcc.target/or1k/sibcall-1.c | 18 ++++++++++
 12 files changed, 186 insertions(+), 2 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/or1k/args-1.c
 create mode 100644 gcc/testsuite/gcc.target/or1k/args-2.c
 create mode 100644 gcc/testsuite/gcc.target/or1k/cmov-1.c
 create mode 100644 gcc/testsuite/gcc.target/or1k/div-mul-1.c
 create mode 100644 gcc/testsuite/gcc.target/or1k/div-mul-2.c
 create mode 100644 gcc/testsuite/gcc.target/or1k/or1k.exp
 create mode 100644 gcc/testsuite/gcc.target/or1k/return-1.c
 create mode 100644 gcc/testsuite/gcc.target/or1k/return-2.c
 create mode 100644 gcc/testsuite/gcc.target/or1k/return-3.c
 create mode 100644 gcc/testsuite/gcc.target/or1k/return-4.c
 create mode 100644 gcc/testsuite/gcc.target/or1k/sibcall-1.c

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 91015bc9222..696274a87cb 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -907,7 +907,6 @@ or1k_function_value (const_tree valtype,
 		     const_tree fn_decl_or_type ATTRIBUTE_UNUSED,
 		     bool outgoing ATTRIBUTE_UNUSED)
 {
-  /* TODO support 2 reg return values and return on stack?  */
   return gen_rtx_REG (TYPE_MODE (valtype), RV_REGNUM);
 }
 
@@ -917,7 +916,6 @@ static rtx
 or1k_libcall_value (machine_mode mode,
 		    const_rtx fun ATTRIBUTE_UNUSED)
 {
-  /* TODO support 2 reg return values and return on stack?  */
   return gen_rtx_REG (mode, RV_REGNUM);
 }
 
diff --git a/gcc/testsuite/gcc.target/or1k/args-1.c b/gcc/testsuite/gcc.target/or1k/args-1.c
new file mode 100644
index 00000000000..7538705d07f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/or1k/args-1.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+struct a {
+  long x;
+  long y;
+  long z;
+};
+
+int passlibstruct (int b, struct a aa);
+
+int main() {
+  struct a aa = { 55, 66, 77 };
+
+  return passlibstruct(-1, aa);
+}
+
+/* Ensure we pass a stack reference in the second arg.  */
+/* { dg-final { scan-assembler-times "r4, r1, " 1 } } */
diff --git a/gcc/testsuite/gcc.target/or1k/args-2.c b/gcc/testsuite/gcc.target/or1k/args-2.c
new file mode 100644
index 00000000000..362f7c0c9e9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/or1k/args-2.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+struct a {
+  long x;
+  long y;
+  long z;
+};
+
+int passstruct (int b, struct a aa) {
+  return aa.z + aa.y + b;
+}
+
+/* Ensure our struct reads are offset from the address in arg 2.  */
+/* { dg-final { scan-assembler-times "l.lwz\\s+r\\d+, \\d+.r4." 2 } } */
diff --git a/gcc/testsuite/gcc.target/or1k/cmov-1.c b/gcc/testsuite/gcc.target/or1k/cmov-1.c
new file mode 100644
index 00000000000..fcac129175d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/or1k/cmov-1.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int cond (int a, int b) {
+  return a > b;
+}
+
+/* { dg-final { scan-assembler "l.cmov" } } */
diff --git a/gcc/testsuite/gcc.target/or1k/div-mul-1.c b/gcc/testsuite/gcc.target/or1k/div-mul-1.c
new file mode 100644
index 00000000000..a5e8d286545
--- /dev/null
+++ b/gcc/testsuite/gcc.target/or1k/div-mul-1.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -msoft-mul -msoft-div" } */
+
+int calc (int a, int b, int c) {
+  return a * b / c;
+}
+
+/* { dg-final { scan-assembler-not "l.mul" } } */
+/* { dg-final { scan-assembler-not "l.div" } } */
diff --git a/gcc/testsuite/gcc.target/or1k/div-mul-2.c b/gcc/testsuite/gcc.target/or1k/div-mul-2.c
new file mode 100644
index 00000000000..a567d7d9f50
--- /dev/null
+++ b/gcc/testsuite/gcc.target/or1k/div-mul-2.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -msoft-div" } */
+
+int calc (int a, int b, int c) {
+  return a * b / c;
+}
+
+/* { dg-final { scan-assembler "l.mul" } } */
+/* { dg-final { scan-assembler-not "l.div" } } */
diff --git a/gcc/testsuite/gcc.target/or1k/or1k.exp b/gcc/testsuite/gcc.target/or1k/or1k.exp
new file mode 100644
index 00000000000..1a4d53a9f79
--- /dev/null
+++ b/gcc/testsuite/gcc.target/or1k/or1k.exp
@@ -0,0 +1,41 @@
+# Copyright (C) 2017-2018 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# GCC testsuite that uses the `dg.exp' driver.
+
+# Exit immediately if this isn't an OpenRISC target.
+if ![istarget or1k*-*-*] then {
+  return
+}
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+# If a testcase doesn't have special options, use these.
+global DEFAULT_CFLAGS
+if ![info exists DEFAULT_CFLAGS] then {
+    set DEFAULT_CFLAGS " -ansi -pedantic-errors"
+}
+
+# Initialize `dg'.
+dg-init
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cS\]]] \
+	"" $DEFAULT_CFLAGS
+
+# All done.
+dg-finish
diff --git a/gcc/testsuite/gcc.target/or1k/return-1.c b/gcc/testsuite/gcc.target/or1k/return-1.c
new file mode 100644
index 00000000000..6dd04197164
--- /dev/null
+++ b/gcc/testsuite/gcc.target/or1k/return-1.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+long long calc (long long a, long long b) {
+  return a * b + 5;
+}
+
+/* Ensure our return value is set in the r11, r12 pair.  */
+/* { dg-final { scan-assembler "r11," } } */
+/* { dg-final { scan-assembler "r12," } } */
diff --git a/gcc/testsuite/gcc.target/or1k/return-2.c b/gcc/testsuite/gcc.target/or1k/return-2.c
new file mode 100644
index 00000000000..c072ae23142
--- /dev/null
+++ b/gcc/testsuite/gcc.target/or1k/return-2.c
@@ -0,0 +1,19 @@
+/* Large structs are returned at a memory address passed in r3.  */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+struct a {
+  long x;
+  long y;
+  long z;
+};
+
+struct a getstruct (long aa) {
+  struct a as = { 22, aa, -5 };
+  return as;
+}
+
+/* Ensure our return value is returned on stack.  */
+/* { dg-final { scan-assembler-not "r12," } } */
+/* { dg-final { scan-assembler "l.or\\s+r11, r3, r3" } } */
+/* { dg-final { scan-assembler-times "l.sw\\s+\\d+.r3.," 3 } } */
diff --git a/gcc/testsuite/gcc.target/or1k/return-3.c b/gcc/testsuite/gcc.target/or1k/return-3.c
new file mode 100644
index 00000000000..5c2e5f5ad91
--- /dev/null
+++ b/gcc/testsuite/gcc.target/or1k/return-3.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+struct a {
+  long x;
+  long y;
+  long z;
+};
+
+struct a getlibstruct (long aa);
+
+int main() {
+  struct a rs = getlibstruct(123);
+
+  return rs.x;
+}
+
+/* Ensure our return value is read from memory.  */
+/* { dg-final { scan-assembler "l.lwz\\s+r11," } } */
diff --git a/gcc/testsuite/gcc.target/or1k/return-4.c b/gcc/testsuite/gcc.target/or1k/return-4.c
new file mode 100644
index 00000000000..b866f58a307
--- /dev/null
+++ b/gcc/testsuite/gcc.target/or1k/return-4.c
@@ -0,0 +1,19 @@
+/* Test to ensure small structs are returned in memory too.  */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+struct a {
+  long x;
+  long y;
+};
+
+struct a getlibstruct (long aa);
+
+int main() {
+  struct a rs = getlibstruct(123);
+
+  return rs.x;
+}
+
+/* Ensure our return value is read from memory.  */
+/* { dg-final { scan-assembler "l.lwz\\s+r11," } } */
diff --git a/gcc/testsuite/gcc.target/or1k/sibcall-1.c b/gcc/testsuite/gcc.target/or1k/sibcall-1.c
new file mode 100644
index 00000000000..8134f0cfe35
--- /dev/null
+++ b/gcc/testsuite/gcc.target/or1k/sibcall-1.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+/* Just create some dummy call that should trigger sibcall, no
+   stack logic.  */
+int calc (int a, int b, int c) {
+  if (c <= 0) return a;
+  return calc (a * b, b, --c);
+}
+
+int main() {
+   return calc (4, 3, 4);
+}
+
+/* Ensure sibcalls do not need to manipulate the stack.  */
+/* { dg-final { scan-assembler-not "r1," } } */
+/* Ensure sibcall maintains the body of the function.  */
+/* { dg-final { scan-assembler "l.mul" } } */
-- 
2.18.0


From 757e66ce9569152763bacf8c3cb06f765888b594 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Sun, 22 Jul 2018 00:07:17 +0900
Subject: [PATCH 106/108] or1k: fix crtx.o linking orders

We need to link the crti.o file before crtbegin (fromt crtstuff.c)
and crtn.o after crtend.  Otherwise would _init() function is not
going to call anything as we had here.  This resulted in exception
handler frames eh_frames not being setup correctly.
---
 gcc/config/or1k/elf.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/gcc/config/or1k/elf.h b/gcc/config/or1k/elf.h
index ee0da0c499b..901f2b94388 100644
--- a/gcc/config/or1k/elf.h
+++ b/gcc/config/or1k/elf.h
@@ -34,9 +34,9 @@
    --entry=0x100"
 
 #undef  STARTFILE_SPEC
-#define STARTFILE_SPEC "crt0.o%s crtbegin.o%s crti.o%s"
+#define STARTFILE_SPEC "crt0.o%s crti.o%s crtbegin.o%s"
 
 #undef  ENDFILE_SPEC
-#define ENDFILE_SPEC "crtn.o%s crtend.o%s"
+#define ENDFILE_SPEC "crtend.o%s crtn.o%s"
 
 #endif /* GCC_OR1K_ELF_H */
-- 
2.18.0


From 1867a5d50f79d38bf96902b120ef9f585306d3f3 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Sun, 22 Jul 2018 00:27:14 +0900
Subject: [PATCH 107/108] or1k: Implement CRT_CALL_STATIC_FUNCTION

This is done to save a bit of noise generated from the generic
_init() / _fini() call generation in crtstuff.c.  Found this out
when working on the .eh_frame initialization bug.
---
 gcc/config/or1k/or1k.h | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 458d60c7993..7c80b326fa9 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -265,6 +265,16 @@ do {                                                    \
     }							\
   while (0)
 
+/* This is used in crtstuff to create call stubs in the
+   _init() and _fini() functions.  Defining this here saves
+   a few bytes created by the dummy call_xxx() functions.  */
+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)	\
+  asm (SECTION_OP "\n"					\
+"	l.jal " #FUNC "\n"				\
+"	 l.nop\n"					\
+"	.previous");
+
+
 #define PRINT_OPERAND_PUNCT_VALID_P(CODE) (code == '#')
 
 /* Calling convention definitions.  */
-- 
2.18.0


From c28b2bd73387a24e09014da27950ec9933ea6edb Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Mon, 30 Jul 2018 19:41:00 +0900
Subject: [PATCH 108/108] or1k:  Fix exception handling for fallthrough case

The exception handling code worked fine for cases when exception were
caught and we returned through __builtin_eh_return,  However when we
ended up ending up at end_of_stack in _Unwind_RaiseException we failed
to restore the link register and returned to nowhere.

Fixed this by always restoring the link register in the epilogue, and
overriding the saved stack link register in eh_return, so we can
restore from that.
---
 gcc/config/or1k/or1k.c | 21 +++++++++++++++------
 gcc/config/or1k/or1k.h |  3 ---
 2 files changed, 15 insertions(+), 9 deletions(-)

diff --git a/gcc/config/or1k/or1k.c b/gcc/config/or1k/or1k.c
index 696274a87cb..c2f72c92433 100644
--- a/gcc/config/or1k/or1k.c
+++ b/gcc/config/or1k/or1k.c
@@ -382,9 +382,7 @@ or1k_expand_epilogue (void)
   /* Restore link register.  */
   if (callee_saved_regno_p (LR_REGNUM))
     {
-      /* Note that eh_return sets the LR -- do not overwrite.  */
-      if (!crtl->calls_eh_return)
-	cfa_restores = or1k_restore_reg (LR_REGNUM, reg_offset, cfa_restores);
+      cfa_restores = or1k_restore_reg (LR_REGNUM, reg_offset, cfa_restores);
       reg_offset += UNITS_PER_WORD;
     }
   gcc_assert (reg_offset == sp_offset);
@@ -461,12 +459,23 @@ or1k_frame_pointer_required ()
   return (crtl->accesses_prior_frames || crtl->profile);
 }
 
-/* TODO, do we need to just set to r9? or should we put it to where r9
-   is stored on the stack?  */
+/* Helper for defining __builtin_eh_return, this will override the current
+   function's return address stored on the stack.  This is called before
+   running the function epilogue so we can't just update the link register.
+   This is used when handling exceptions to jump into the exception handler
+   catch block upon return from _Unwind_RaiseException.  */
+
 void
 or1k_expand_eh_return (rtx eh_addr)
 {
-  emit_move_insn (gen_rtx_REG (Pmode, LR_REGNUM), eh_addr);
+  rtx lraddr;
+
+  lraddr = gen_frame_mem (Pmode, plus_constant (Pmode,
+					      hard_frame_pointer_rtx,
+					      -UNITS_PER_WORD));
+  /* Set address to volitile to ensure the store doesn't get optimized out.  */
+  MEM_VOLATILE_P (lraddr) = true;
+  emit_move_insn (lraddr, eh_addr);
 }
 
 /* We allow the following eliminiations:
diff --git a/gcc/config/or1k/or1k.h b/gcc/config/or1k/or1k.h
index 7c80b326fa9..a6afc735b83 100644
--- a/gcc/config/or1k/or1k.h
+++ b/gcc/config/or1k/or1k.h
@@ -389,8 +389,5 @@ do {                                                    \
 #define EH_RETURN_DATA_REGNO(N)	\
     ((N) < 4 ? HW_TO_GCC_REGNO (25) + (N) : INVALID_REGNUM)
 #define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, EH_RETURN_REGNUM)
-/* Make eh_return use the link register. Epilogue LR restore
-   is suppressed for eh_return. */
-#define EH_RETURN_HANDLER_RTX   INCOMING_RETURN_ADDR_RTX
 
 #endif /* GCC_OR1K_H */
-- 
2.18.0

